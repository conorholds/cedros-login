{"version":3,"file":"shamir-OAB2zD9Y.js","sources":["../src/crypto/argon2WorkerClient.ts","../src/utils/cryptoShim.ts","../node_modules/secrets.js-grempe/secrets.js","../node_modules/@noble/curves/node_modules/@noble/hashes/utils.js","../node_modules/@noble/curves/node_modules/@noble/hashes/_md.js","../node_modules/@noble/curves/node_modules/@noble/hashes/_u64.js","../node_modules/@noble/curves/node_modules/@noble/hashes/sha2.js","../node_modules/@noble/curves/utils.js","../node_modules/@noble/curves/abstract/modular.js","../node_modules/@noble/curves/abstract/curve.js","../node_modules/@noble/curves/abstract/edwards.js","../node_modules/@noble/curves/ed25519.js","../node_modules/@noble/hashes/esm/utils.js","../node_modules/@noble/hashes/esm/_md.js","../node_modules/@noble/hashes/esm/sha2.js","../node_modules/@noble/hashes/esm/sha256.js","../src/crypto/solanaKeypair.ts","../src/crypto/shamir.ts"],"sourcesContent":["import { argon2Derive, validateKdfParams } from './argon2';\nimport type { Argon2Salt, EncryptionKey, KdfParams } from './types';\nimport { DEFAULT_KDF_PARAMS } from './types';\n\ntype PendingRequest = {\n  resolve: (key: EncryptionKey) => void;\n  reject: (error: Error) => void;\n};\n\ntype WorkerRequest = {\n  id: number;\n  password: string;\n  salt: Uint8Array;\n  params: KdfParams;\n};\n\ntype WorkerResponse = {\n  id: number;\n  key?: Uint8Array;\n  error?: string;\n};\n\nlet worker: Worker | null = null;\nlet nextId = 0;\nconst pending = new Map<number, PendingRequest>();\n\nfunction getWorker(): Worker | null {\n  if (typeof Worker === 'undefined') {\n    return null;\n  }\n\n  if (!worker) {\n    worker = new Worker(new URL('./argon2Worker.ts', import.meta.url), {\n      type: 'module',\n    });\n\n    worker.onmessage = (event: MessageEvent<WorkerResponse>) => {\n      const { id, key, error } = event.data;\n      const handlers = pending.get(id);\n      if (!handlers) return;\n      pending.delete(id);\n\n      if (error) {\n        handlers.reject(new Error(error));\n        return;\n      }\n\n      if (!key) {\n        handlers.reject(new Error('Argon2 worker returned no key'));\n        return;\n      }\n\n      handlers.resolve(key as EncryptionKey);\n    };\n\n    worker.onerror = (event) => {\n      const error = event instanceof ErrorEvent ? event.error : new Error('Argon2 worker error');\n      for (const handlers of pending.values()) {\n        handlers.reject(error instanceof Error ? error : new Error(String(error)));\n      }\n      pending.clear();\n      worker?.terminate();\n      worker = null;\n    };\n  }\n\n  return worker;\n}\n\n/**\n * Derive an encryption key from password using Argon2id in a Web Worker.\n *\n * Offloads CPU-intensive Argon2id KDF to a background thread to avoid\n * blocking the main thread. Falls back to synchronous derivation if\n * Web Workers are not available.\n *\n * @param password - User's password\n * @param salt - 16-byte random salt\n * @param params - KDF parameters (memory, iterations, parallelism)\n * @returns 32-byte encryption key\n *\n * @security **CALLER MUST WIPE RETURNED KEY AFTER USE**\n * The returned key contains sensitive cryptographic material.\n * Callers are responsible for wiping it when no longer needed:\n * ```ts\n * const key = await argon2DeriveInWorker(password, salt);\n * try {\n *   // use key for encryption/decryption\n * } finally {\n *   wipeBytes(key);\n * }\n * ```\n * Failure to wipe may leave key material in memory, vulnerable to memory\n * dump attacks.\n */\nexport async function argon2DeriveInWorker(\n  password: string,\n  salt: Argon2Salt,\n  params: KdfParams = DEFAULT_KDF_PARAMS\n): Promise<EncryptionKey> {\n  // S-8: Validate params before dispatching to worker.\n  // Extreme params would block the worker thread before rejection.\n  validateKdfParams(params);\n\n  const argonWorker = getWorker();\n  if (!argonWorker) {\n    return argon2Derive(password, salt, params);\n  }\n\n  return new Promise((resolve, reject) => {\n    const id = nextId++;\n    pending.set(id, { resolve, reject });\n\n    const payload: WorkerRequest = {\n      id,\n      password,\n      salt,\n      params,\n    };\n\n    argonWorker.postMessage(payload);\n  });\n}\n","/**\n * Shim for Node's `crypto` module.\n * Maps `require('crypto')` / `import 'crypto'` to Web Crypto API in the browser.\n * Used by vite.config.ts alias to support CJS dependencies that expect Node crypto.\n */\n\n// Re-export Web Crypto API\nexport default globalThis.crypto;\nexport const webcrypto = globalThis.crypto;\nexport const subtle = globalThis.crypto.subtle;\nexport const getRandomValues = globalThis.crypto.getRandomValues.bind(globalThis.crypto);\nexport const randomUUID = globalThis.crypto.randomUUID.bind(globalThis.crypto);\n","// @preserve author Alexander Stetsyuk\n// @preserve author Glenn Rempe <glenn@rempe.us>\n// @license MIT\n\n/*jslint passfail: false, bitwise: true, nomen: true, plusplus: true, todo: false, maxerr: 1000 */\n/*global define, require, module, exports, window, Uint32Array */\n\n// eslint : http://eslint.org/docs/configuring/\n/*eslint-env node, browser, jasmine */\n/*eslint no-underscore-dangle:0 */\n\n// UMD (Universal Module Definition)\n// Uses Node, AMD or browser globals to create a module. This module creates\n// a global even when AMD is used. This is useful if you have some scripts\n// that are loaded by an AMD loader, but they still want access to globals.\n// See : https://github.com/umdjs/umd\n// See : https://github.com/umdjs/umd/blob/master/returnExportsGlobal.js\n//\n;(function(root, factory) {\n    \"use strict\"\n\n    if (typeof define === \"function\" && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], function() {\n            /*eslint-disable no-return-assign */\n            return (root.secrets = factory())\n            /*eslint-enable no-return-assign */\n        })\n    } else if (typeof exports === \"object\") {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require(\"crypto\"))\n    } else {\n        // Browser globals (root is window)\n        root.secrets = factory(root.crypto)\n    }\n})(this, function(crypto) {\n    \"use strict\"\n\n    var defaults, config, preGenPadding, runCSPRNGTest, CSPRNGTypes\n\n    function reset() {\n        defaults = {\n            bits: 8, // default number of bits\n            radix: 16, // work with HEX by default\n            minBits: 3,\n            maxBits: 20, // this permits 1,048,575 shares, though going this high is NOT recommended in JS!\n            bytesPerChar: 2,\n            maxBytesPerChar: 6, // Math.pow(256,7) > Math.pow(2,53)\n\n            // Primitive polynomials (in decimal form) for Galois Fields GF(2^n), for 2 <= n <= 30\n            // The index of each term in the array corresponds to the n for that polynomial\n            // i.e. to get the polynomial for n=16, use primitivePolynomials[16]\n            primitivePolynomials: [\n                null,\n                null,\n                1,\n                3,\n                3,\n                5,\n                3,\n                3,\n                29,\n                17,\n                9,\n                5,\n                83,\n                27,\n                43,\n                3,\n                45,\n                9,\n                39,\n                39,\n                9,\n                5,\n                3,\n                33,\n                27,\n                9,\n                71,\n                39,\n                9,\n                5,\n                83\n            ]\n        }\n        config = {}\n        preGenPadding = new Array(1024).join(\"0\") // Pre-generate a string of 1024 0's for use by padLeft().\n        runCSPRNGTest = true\n\n        // WARNING : Never use 'testRandom' except for testing.\n        CSPRNGTypes = [\n            \"nodeCryptoRandomBytes\",\n            \"browserCryptoGetRandomValues\",\n            \"testRandom\"\n        ]\n    }\n\n    function isSetRNG() {\n        if (config && config.rng && typeof config.rng === \"function\") {\n            return true\n        }\n\n        return false\n    }\n\n    // Pads a string `str` with zeros on the left so that its length is a multiple of `bits`\n    function padLeft(str, multipleOfBits) {\n        var missing\n\n        if (multipleOfBits === 0 || multipleOfBits === 1) {\n            return str\n        }\n\n        if (multipleOfBits && multipleOfBits > 1024) {\n            throw new Error(\n                \"Padding must be multiples of no larger than 1024 bits.\"\n            )\n        }\n\n        multipleOfBits = multipleOfBits || config.bits\n\n        if (str) {\n            missing = str.length % multipleOfBits\n        }\n\n        if (missing) {\n            return (preGenPadding + str).slice(\n                -(multipleOfBits - missing + str.length)\n            )\n        }\n\n        return str\n    }\n\n    function hex2bin(str) {\n        var bin = \"\",\n            num,\n            i\n\n        for (i = str.length - 1; i >= 0; i--) {\n            num = parseInt(str[i], 16)\n\n            if (isNaN(num)) {\n                throw new Error(\"Invalid hex character.\")\n            }\n\n            bin = padLeft(num.toString(2), 4) + bin\n        }\n        return bin\n    }\n\n    function bin2hex(str) {\n        var hex = \"\",\n            num,\n            i\n\n        str = padLeft(str, 4)\n\n        for (i = str.length; i >= 4; i -= 4) {\n            num = parseInt(str.slice(i - 4, i), 2)\n            if (isNaN(num)) {\n                throw new Error(\"Invalid binary character.\")\n            }\n            hex = num.toString(16) + hex\n        }\n\n        return hex\n    }\n\n    // Browser supports crypto.getRandomValues()\n    function hasCryptoGetRandomValues() {\n        if (\n            crypto &&\n            typeof crypto === \"object\" &&\n            (typeof crypto.getRandomValues === \"function\" ||\n                typeof crypto.getRandomValues === \"object\") &&\n            (typeof Uint32Array === \"function\" ||\n                typeof Uint32Array === \"object\")\n        ) {\n            return true\n        }\n\n        return false\n    }\n\n    // Node.js support for crypto.randomBytes()\n    function hasCryptoRandomBytes() {\n        if (\n            typeof crypto === \"object\" &&\n            typeof crypto.randomBytes === \"function\"\n        ) {\n            return true\n        }\n\n        return false\n    }\n\n    // Returns a pseudo-random number generator of the form function(bits){}\n    // which should output a random string of 1's and 0's of length `bits`.\n    // `type` (Optional) : A string representing the CSPRNG that you want to\n    // force to be loaded, overriding feature detection. Can be one of:\n    //    \"nodeCryptoRandomBytes\"\n    //    \"browserCryptoGetRandomValues\"\n    //\n    function getRNG(type) {\n        function construct(bits, arr, radix, size) {\n            var i = 0,\n                len,\n                str = \"\",\n                parsedInt\n\n            if (arr) {\n                len = arr.length - 1\n            }\n\n            while (i < len || str.length < bits) {\n                // convert any negative nums to positive with Math.abs()\n                parsedInt = Math.abs(parseInt(arr[i], radix))\n                str = str + padLeft(parsedInt.toString(2), size)\n                i++\n            }\n\n            str = str.substr(-bits)\n\n            // return null so this result can be re-processed if the result is all 0's.\n            if ((str.match(/0/g) || []).length === str.length) {\n                return null\n            }\n\n            return str\n        }\n\n        // Node.js : crypto.randomBytes()\n        // Note : Node.js and crypto.randomBytes() uses the OpenSSL RAND_bytes() function for its CSPRNG.\n        //        Node.js will need to have been compiled with OpenSSL for this to work.\n        // See : https://github.com/joyent/node/blob/d8baf8a2a4481940bfed0196308ae6189ca18eee/src/node_crypto.cc#L4696\n        // See : https://www.openssl.org/docs/crypto/rand.html\n        function nodeCryptoRandomBytes(bits) {\n            var buf,\n                bytes,\n                radix,\n                size,\n                str = null\n\n            radix = 16\n            size = 4\n            bytes = Math.ceil(bits / 8)\n\n            while (str === null) {\n                buf = crypto.randomBytes(bytes)\n                str = construct(bits, buf.toString(\"hex\"), radix, size)\n            }\n\n            return str\n        }\n\n        // Browser : crypto.getRandomValues()\n        // See : https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-Crypto\n        // See : https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues\n        // Supported Browsers : http://caniuse.com/#search=crypto.getRandomValues\n        function browserCryptoGetRandomValues(bits) {\n            var elems,\n                radix,\n                size,\n                str = null\n\n            radix = 10\n            size = 32\n            elems = Math.ceil(bits / 32)\n            while (str === null) {\n                str = construct(\n                    bits,\n                    crypto.getRandomValues(new Uint32Array(elems)),\n                    radix,\n                    size\n                )\n            }\n\n            return str\n        }\n\n        // /////////////////////////////////////////////////////////////\n        // WARNING : DO NOT USE. For testing purposes only.\n        // /////////////////////////////////////////////////////////////\n        // This function will return repeatable non-random test bits. Can be used\n        // for testing only. Node.js does not return proper random bytes\n        // when run within a PhantomJS container.\n        function testRandom(bits) {\n            var arr,\n                elems,\n                int,\n                radix,\n                size,\n                str = null\n\n            radix = 10\n            size = 32\n            elems = Math.ceil(bits / 32)\n            int = 123456789\n            arr = new Uint32Array(elems)\n\n            // Fill every element of the Uint32Array with the same int.\n            for (var i = 0; i < arr.length; i++) {\n                arr[i] = int\n            }\n\n            while (str === null) {\n                str = construct(bits, arr, radix, size)\n            }\n\n            return str\n        }\n\n        // Return a random generator function for browsers that support\n        // crypto.getRandomValues() or Node.js compiled with OpenSSL support.\n        // WARNING : NEVER use testRandom outside of a testing context. Totally non-random!\n        if (type && type === \"testRandom\") {\n            config.typeCSPRNG = type\n            return testRandom\n        } else if (type && type === \"nodeCryptoRandomBytes\") {\n            config.typeCSPRNG = type\n            return nodeCryptoRandomBytes\n        } else if (type && type === \"browserCryptoGetRandomValues\") {\n            config.typeCSPRNG = type\n            return browserCryptoGetRandomValues\n        } else if (hasCryptoRandomBytes()) {\n            config.typeCSPRNG = \"nodeCryptoRandomBytes\"\n            return nodeCryptoRandomBytes\n        } else if (hasCryptoGetRandomValues()) {\n            config.typeCSPRNG = \"browserCryptoGetRandomValues\"\n            return browserCryptoGetRandomValues\n        }\n    }\n\n    // Splits a number string `bits`-length segments, after first\n    // optionally zero-padding it to a length that is a multiple of `padLength.\n    // Returns array of integers (each less than 2^bits-1), with each element\n    // representing a `bits`-length segment of the input string from right to left,\n    // i.e. parts[0] represents the right-most `bits`-length segment of the input string.\n    function splitNumStringToIntArray(str, padLength) {\n        var parts = [],\n            i\n\n        if (padLength) {\n            str = padLeft(str, padLength)\n        }\n\n        for (i = str.length; i > config.bits; i -= config.bits) {\n            parts.push(parseInt(str.slice(i - config.bits, i), 2))\n        }\n\n        parts.push(parseInt(str.slice(0, i), 2))\n\n        return parts\n    }\n\n    // Polynomial evaluation at `x` using Horner's Method\n    // NOTE: fx=fx * x + coeff[i] ->  exp(log(fx) + log(x)) + coeff[i],\n    //       so if fx===0, just set fx to coeff[i] because\n    //       using the exp/log form will result in incorrect value\n    function horner(x, coeffs) {\n        var logx = config.logs[x],\n            fx = 0,\n            i\n\n        for (i = coeffs.length - 1; i >= 0; i--) {\n            if (fx !== 0) {\n                fx =\n                    config.exps[(logx + config.logs[fx]) % config.maxShares] ^\n                    coeffs[i]\n            } else {\n                fx = coeffs[i]\n            }\n        }\n\n        return fx\n    }\n\n    // Evaluate the Lagrange interpolation polynomial at x = `at`\n    // using x and y Arrays that are of the same length, with\n    // corresponding elements constituting points on the polynomial.\n    function lagrange(at, x, y) {\n        var sum = 0,\n            len,\n            product,\n            i,\n            j\n\n        for (i = 0, len = x.length; i < len; i++) {\n            if (y[i]) {\n                product = config.logs[y[i]]\n\n                for (j = 0; j < len; j++) {\n                    if (i !== j) {\n                        if (at === x[j]) {\n                            // happens when computing a share that is in the list of shares used to compute it\n                            product = -1 // fix for a zero product term, after which the sum should be sum^0 = sum, not sum^1\n                            break\n                        }\n                        product =\n                            (product +\n                                config.logs[at ^ x[j]] -\n                                config.logs[x[i] ^ x[j]] +\n                                config.maxShares) %\n                            config.maxShares // to make sure it's not negative\n                    }\n                }\n\n                // though exps[-1] === undefined and undefined ^ anything = anything in\n                // chrome, this behavior may not hold everywhere, so do the check\n                sum = product === -1 ? sum : sum ^ config.exps[product]\n            }\n        }\n\n        return sum\n    }\n\n    // This is the basic polynomial generation and evaluation function\n    // for a `config.bits`-length secret (NOT an arbitrary length)\n    // Note: no error-checking at this stage! If `secret` is NOT\n    // a NUMBER less than 2^bits-1, the output will be incorrect!\n    function getShares(secret, numShares, threshold) {\n        var shares = [],\n            coeffs = [secret],\n            i,\n            len\n\n        for (i = 1; i < threshold; i++) {\n            coeffs[i] = parseInt(config.rng(config.bits), 2)\n        }\n\n        for (i = 1, len = numShares + 1; i < len; i++) {\n            shares[i - 1] = {\n                x: i,\n                y: horner(i, coeffs)\n            }\n        }\n\n        return shares\n    }\n\n    function constructPublicShareString(bits, id, data) {\n        var bitsBase36, idHex, idMax, idPaddingLen, newShareString\n\n        id = parseInt(id, config.radix)\n        bits = parseInt(bits, 10) || config.bits\n        bitsBase36 = bits.toString(36).toUpperCase()\n        idMax = Math.pow(2, bits) - 1\n        idPaddingLen = idMax.toString(config.radix).length\n        idHex = padLeft(id.toString(config.radix), idPaddingLen)\n\n        if (typeof id !== \"number\" || id % 1 !== 0 || id < 1 || id > idMax) {\n            throw new Error(\n                \"Share id must be an integer between 1 and \" +\n                    idMax +\n                    \", inclusive.\"\n            )\n        }\n\n        newShareString = bitsBase36 + idHex + data\n\n        return newShareString\n    }\n\n    // EXPORTED FUNCTIONS\n    // //////////////////\n\n    var secrets = {\n        init: function(bits, rngType) {\n            var logs = [],\n                exps = [],\n                x = 1,\n                primitive,\n                i\n\n            // reset all config back to initial state\n            reset()\n\n            if (\n                bits &&\n                (typeof bits !== \"number\" ||\n                    bits % 1 !== 0 ||\n                    bits < defaults.minBits ||\n                    bits > defaults.maxBits)\n            ) {\n                throw new Error(\n                    \"Number of bits must be an integer between \" +\n                        defaults.minBits +\n                        \" and \" +\n                        defaults.maxBits +\n                        \", inclusive.\"\n                )\n            }\n\n            if (rngType && CSPRNGTypes.indexOf(rngType) === -1) {\n                throw new Error(\"Invalid RNG type argument : '\" + rngType + \"'\")\n            }\n\n            config.radix = defaults.radix\n            config.bits = bits || defaults.bits\n            config.size = Math.pow(2, config.bits)\n            config.maxShares = config.size - 1\n\n            // Construct the exp and log tables for multiplication.\n            primitive = defaults.primitivePolynomials[config.bits]\n\n            for (i = 0; i < config.size; i++) {\n                exps[i] = x\n                logs[x] = i\n                x = x << 1 // Left shift assignment\n                if (x >= config.size) {\n                    x = x ^ primitive // Bitwise XOR assignment\n                    x = x & config.maxShares // Bitwise AND assignment\n                }\n            }\n\n            config.logs = logs\n            config.exps = exps\n\n            if (rngType) {\n                this.setRNG(rngType)\n            }\n\n            if (!isSetRNG()) {\n                this.setRNG()\n            }\n\n            if (\n                !isSetRNG() ||\n                !config.bits ||\n                !config.size ||\n                !config.maxShares ||\n                !config.logs ||\n                !config.exps ||\n                config.logs.length !== config.size ||\n                config.exps.length !== config.size\n            ) {\n                throw new Error(\"Initialization failed.\")\n            }\n        },\n\n        // Evaluates the Lagrange interpolation polynomial at x=`at` for\n        // individual config.bits-length segments of each share in the `shares`\n        // Array. Each share is expressed in base `inputRadix`. The output\n        // is expressed in base `outputRadix'.\n        combine: function(shares, at) {\n            var i,\n                j,\n                len,\n                len2,\n                result = \"\",\n                setBits,\n                share,\n                splitShare,\n                x = [],\n                y = []\n\n            at = at || 0\n\n            for (i = 0, len = shares.length; i < len; i++) {\n                share = this.extractShareComponents(shares[i])\n\n                // All shares must have the same bits settings.\n                if (setBits === undefined) {\n                    setBits = share.bits\n                } else if (share.bits !== setBits) {\n                    throw new Error(\n                        \"Mismatched shares: Different bit settings.\"\n                    )\n                }\n\n                // Reset everything to the bit settings of the shares.\n                if (config.bits !== setBits) {\n                    this.init(setBits)\n                }\n\n                // Proceed if this share.id is not already in the Array 'x' and\n                // then split each share's hex data into an Array of Integers,\n                // then 'rotate' those arrays where the first element of each row is converted to\n                // its own array, the second element of each to its own Array, and so on for all of the rest.\n                // Essentially zipping all of the shares together.\n                //\n                // e.g.\n                //   [ 193, 186, 29, 150, 5, 120, 44, 46, 49, 59, 6, 1, 102, 98, 177, 196 ]\n                //   [ 53, 105, 139, 49, 187, 240, 91, 92, 98, 118, 12, 2, 204, 196, 127, 149 ]\n                //   [ 146, 211, 249, 167, 209, 136, 118, 114, 83, 77, 10, 3, 170, 166, 206, 81 ]\n                //\n                // becomes:\n                //\n                // [ [ 193, 53, 146 ],\n                //   [ 186, 105, 211 ],\n                //   [ 29, 139, 249 ],\n                //   [ 150, 49, 167 ],\n                //   [ 5, 187, 209 ],\n                //   [ 120, 240, 136 ],\n                //   [ 44, 91, 118 ],\n                //   [ 46, 92, 114 ],\n                //   [ 49, 98, 83 ],\n                //   [ 59, 118, 77 ],\n                //   [ 6, 12, 10 ],\n                //   [ 1, 2, 3 ],\n                //   [ 102, 204, 170 ],\n                //   [ 98, 196, 166 ],\n                //   [ 177, 127, 206 ],\n                //   [ 196, 149, 81 ] ]\n                //\n                if (x.indexOf(share.id) === -1) {\n                    x.push(share.id)\n                    splitShare = splitNumStringToIntArray(hex2bin(share.data))\n                    for (j = 0, len2 = splitShare.length; j < len2; j++) {\n                        y[j] = y[j] || []\n                        y[j][x.length - 1] = splitShare[j]\n                    }\n                }\n            }\n\n            // Extract the secret from the 'rotated' share data and return a\n            // string of Binary digits which represent the secret directly. or in the\n            // case of a newShare() return the binary string representing just that\n            // new share.\n            for (i = 0, len = y.length; i < len; i++) {\n                result = padLeft(lagrange(at, x, y[i]).toString(2)) + result\n            }\n\n            // If 'at' is non-zero combine() was called from newShare(). In this\n            // case return the result (the new share data) directly.\n            //\n            // Otherwise find the first '1' which was added in the share() function as a padding marker\n            // and return only the data after the padding and the marker. Convert this Binary string\n            // to hex, which represents the final secret result (which can be converted from hex back\n            // to the original string in user space using `hex2str()`).\n            return bin2hex(\n                at >= 1 ? result : result.slice(result.indexOf(\"1\") + 1)\n            )\n        },\n\n        getConfig: function() {\n            var obj = {}\n            obj.radix = config.radix\n            obj.bits = config.bits\n            obj.maxShares = config.maxShares\n            obj.hasCSPRNG = isSetRNG()\n            obj.typeCSPRNG = config.typeCSPRNG\n            return obj\n        },\n\n        // Given a public share, extract the bits (Integer), share ID (Integer), and share data (Hex)\n        // and return an Object containing those components.\n        extractShareComponents: function(share) {\n            var bits,\n                id,\n                idLen,\n                max,\n                obj = {},\n                regexStr,\n                shareComponents\n\n            // Extract the first char which represents the bits in Base 36\n            bits = parseInt(share.substr(0, 1), 36)\n\n            if (\n                bits &&\n                (typeof bits !== \"number\" ||\n                    bits % 1 !== 0 ||\n                    bits < defaults.minBits ||\n                    bits > defaults.maxBits)\n            ) {\n                throw new Error(\n                    \"Invalid share : Number of bits must be an integer between \" +\n                        defaults.minBits +\n                        \" and \" +\n                        defaults.maxBits +\n                        \", inclusive.\"\n                )\n            }\n\n            // calc the max shares allowed for given bits\n            max = Math.pow(2, bits) - 1\n\n            // Determine the ID length which is variable and based on the bit count.\n            idLen = (Math.pow(2, bits) - 1).toString(config.radix).length\n\n            // Extract all the parts now that the segment sizes are known.\n            regexStr =\n                \"^([a-kA-K3-9]{1})([a-fA-F0-9]{\" + idLen + \"})([a-fA-F0-9]+)$\"\n            shareComponents = new RegExp(regexStr).exec(share)\n\n            // The ID is a Hex number and needs to be converted to an Integer\n            if (shareComponents) {\n                id = parseInt(shareComponents[2], config.radix)\n            }\n\n            if (typeof id !== \"number\" || id % 1 !== 0 || id < 1 || id > max) {\n                throw new Error(\n                    \"Invalid share : Share id must be an integer between 1 and \" +\n                        config.maxShares +\n                        \", inclusive.\"\n                )\n            }\n\n            if (shareComponents && shareComponents[3]) {\n                obj.bits = bits\n                obj.id = id\n                obj.data = shareComponents[3]\n                return obj\n            }\n\n            throw new Error(\"The share data provided is invalid : \" + share)\n        },\n\n        // Set the PRNG to use. If no RNG function is supplied, pick a default using getRNG()\n        setRNG: function(rng) {\n            var errPrefix = \"Random number generator is invalid \",\n                errSuffix =\n                    \" Supply an CSPRNG of the form function(bits){} that returns a string containing 'bits' number of random 1's and 0's.\"\n\n            if (\n                rng &&\n                typeof rng === \"string\" &&\n                CSPRNGTypes.indexOf(rng) === -1\n            ) {\n                throw new Error(\"Invalid RNG type argument : '\" + rng + \"'\")\n            }\n\n            // If RNG was not specified at all,\n            // try to pick one appropriate for this env.\n            if (!rng) {\n                rng = getRNG()\n            }\n\n            // If `rng` is a string, try to forcibly\n            // set the RNG to the type specified.\n            if (rng && typeof rng === \"string\") {\n                rng = getRNG(rng)\n            }\n\n            if (runCSPRNGTest) {\n                if (rng && typeof rng !== \"function\") {\n                    throw new Error(errPrefix + \"(Not a function).\" + errSuffix)\n                }\n\n                if (rng && typeof rng(config.bits) !== \"string\") {\n                    throw new Error(\n                        errPrefix + \"(Output is not a string).\" + errSuffix\n                    )\n                }\n\n                if (rng && !parseInt(rng(config.bits), 2)) {\n                    throw new Error(\n                        errPrefix +\n                            \"(Binary string output not parseable to an Integer).\" +\n                            errSuffix\n                    )\n                }\n\n                if (rng && rng(config.bits).length > config.bits) {\n                    throw new Error(\n                        errPrefix +\n                            \"(Output length is greater than config.bits).\" +\n                            errSuffix\n                    )\n                }\n\n                if (rng && rng(config.bits).length < config.bits) {\n                    throw new Error(\n                        errPrefix +\n                            \"(Output length is less than config.bits).\" +\n                            errSuffix\n                    )\n                }\n            }\n\n            config.rng = rng\n\n            return true\n        },\n\n        // Converts a given UTF16 character string to the HEX representation.\n        // Each character of the input string is represented by\n        // `bytesPerChar` bytes in the output string which defaults to 2.\n        str2hex: function(str, bytesPerChar) {\n            var hexChars,\n                max,\n                out = \"\",\n                neededBytes,\n                num,\n                i,\n                len\n\n            if (typeof str !== \"string\") {\n                throw new Error(\"Input must be a character string.\")\n            }\n\n            if (!bytesPerChar) {\n                bytesPerChar = defaults.bytesPerChar\n            }\n\n            if (\n                typeof bytesPerChar !== \"number\" ||\n                bytesPerChar < 1 ||\n                bytesPerChar > defaults.maxBytesPerChar ||\n                bytesPerChar % 1 !== 0\n            ) {\n                throw new Error(\n                    \"Bytes per character must be an integer between 1 and \" +\n                        defaults.maxBytesPerChar +\n                        \", inclusive.\"\n                )\n            }\n\n            hexChars = 2 * bytesPerChar\n            max = Math.pow(16, hexChars) - 1\n\n            for (i = 0, len = str.length; i < len; i++) {\n                num = str[i].charCodeAt()\n\n                if (isNaN(num)) {\n                    throw new Error(\"Invalid character: \" + str[i])\n                }\n\n                if (num > max) {\n                    neededBytes = Math.ceil(Math.log(num + 1) / Math.log(256))\n                    throw new Error(\n                        \"Invalid character code (\" +\n                            num +\n                            \"). Maximum allowable is 256^bytes-1 (\" +\n                            max +\n                            \"). To convert this character, use at least \" +\n                            neededBytes +\n                            \" bytes.\"\n                    )\n                }\n\n                out = padLeft(num.toString(16), hexChars) + out\n            }\n            return out\n        },\n\n        // Converts a given HEX number string to a UTF16 character string.\n        hex2str: function(str, bytesPerChar) {\n            var hexChars,\n                out = \"\",\n                i,\n                len\n\n            if (typeof str !== \"string\") {\n                throw new Error(\"Input must be a hexadecimal string.\")\n            }\n            bytesPerChar = bytesPerChar || defaults.bytesPerChar\n\n            if (\n                typeof bytesPerChar !== \"number\" ||\n                bytesPerChar % 1 !== 0 ||\n                bytesPerChar < 1 ||\n                bytesPerChar > defaults.maxBytesPerChar\n            ) {\n                throw new Error(\n                    \"Bytes per character must be an integer between 1 and \" +\n                        defaults.maxBytesPerChar +\n                        \", inclusive.\"\n                )\n            }\n\n            hexChars = 2 * bytesPerChar\n\n            str = padLeft(str, hexChars)\n\n            for (i = 0, len = str.length; i < len; i += hexChars) {\n                out =\n                    String.fromCharCode(\n                        parseInt(str.slice(i, i + hexChars), 16)\n                    ) + out\n            }\n\n            return out\n        },\n\n        // Generates a random bits-length number string using the PRNG\n        random: function(bits) {\n            if (\n                typeof bits !== \"number\" ||\n                bits % 1 !== 0 ||\n                bits < 2 ||\n                bits > 65536\n            ) {\n                throw new Error(\n                    \"Number of bits must be an Integer between 1 and 65536.\"\n                )\n            }\n\n            return bin2hex(config.rng(bits))\n        },\n\n        // Divides a `secret` number String str expressed in radix `inputRadix` (optional, default 16)\n        // into `numShares` shares, each expressed in radix `outputRadix` (optional, default to `inputRadix`),\n        // requiring `threshold` number of shares to reconstruct the secret.\n        // Optionally, zero-pads the secret to a length that is a multiple of padLength before sharing.\n        share: function(secret, numShares, threshold, padLength) {\n            var neededBits,\n                subShares,\n                x = new Array(numShares),\n                y = new Array(numShares),\n                i,\n                j,\n                len\n\n            // Security:\n            // For additional security, pad in multiples of 128 bits by default.\n            // A small trade-off in larger share size to help prevent leakage of information\n            // about small-ish secrets and increase the difficulty of attacking them.\n            padLength = padLength || 128\n\n            if (typeof secret !== \"string\") {\n                throw new Error(\"Secret must be a string.\")\n            }\n\n            if (\n                typeof numShares !== \"number\" ||\n                numShares % 1 !== 0 ||\n                numShares < 2\n            ) {\n                throw new Error(\n                    \"Number of shares must be an integer between 2 and 2^bits-1 (\" +\n                        config.maxShares +\n                        \"), inclusive.\"\n                )\n            }\n\n            if (numShares > config.maxShares) {\n                neededBits = Math.ceil(Math.log(numShares + 1) / Math.LN2)\n                throw new Error(\n                    \"Number of shares must be an integer between 2 and 2^bits-1 (\" +\n                        config.maxShares +\n                        \"), inclusive. To create \" +\n                        numShares +\n                        \" shares, use at least \" +\n                        neededBits +\n                        \" bits.\"\n                )\n            }\n\n            if (\n                typeof threshold !== \"number\" ||\n                threshold % 1 !== 0 ||\n                threshold < 2\n            ) {\n                throw new Error(\n                    \"Threshold number of shares must be an integer between 2 and 2^bits-1 (\" +\n                        config.maxShares +\n                        \"), inclusive.\"\n                )\n            }\n\n            if (threshold > config.maxShares) {\n                neededBits = Math.ceil(Math.log(threshold + 1) / Math.LN2)\n                throw new Error(\n                    \"Threshold number of shares must be an integer between 2 and 2^bits-1 (\" +\n                        config.maxShares +\n                        \"), inclusive.  To use a threshold of \" +\n                        threshold +\n                        \", use at least \" +\n                        neededBits +\n                        \" bits.\"\n                )\n            }\n\n            if (threshold > numShares) {\n                throw new Error(\n                    \"Threshold number of shares was \" +\n                        threshold +\n                        \" but must be less than or equal to the \" +\n                        numShares +\n                        \" shares specified as the total to generate.\"\n                )\n            }\n\n            if (\n                typeof padLength !== \"number\" ||\n                padLength % 1 !== 0 ||\n                padLength < 0 ||\n                padLength > 1024\n            ) {\n                throw new Error(\n                    \"Zero-pad length must be an integer between 0 and 1024 inclusive.\"\n                )\n            }\n\n            secret = \"1\" + hex2bin(secret) // prepend a 1 as a marker so that we can preserve the correct number of leading zeros in our secret\n            secret = splitNumStringToIntArray(secret, padLength)\n\n            for (i = 0, len = secret.length; i < len; i++) {\n                subShares = getShares(secret[i], numShares, threshold)\n                for (j = 0; j < numShares; j++) {\n                    x[j] = x[j] || subShares[j].x.toString(config.radix)\n                    y[j] = padLeft(subShares[j].y.toString(2)) + (y[j] || \"\")\n                }\n            }\n\n            for (i = 0; i < numShares; i++) {\n                x[i] = constructPublicShareString(\n                    config.bits,\n                    x[i],\n                    bin2hex(y[i])\n                )\n            }\n\n            return x\n        },\n\n        // Generate a new share with id `id` (a number between 1 and 2^bits-1)\n        // `id` can be a Number or a String in the default radix (16)\n        newShare: function(id, shares) {\n            var share, radid\n\n            if (id && typeof id === \"string\") {\n                id = parseInt(id, config.radix)\n            }\n\n            radid = id.toString(config.radix)\n\n            if (id && radid && shares && shares[0]) {\n                share = this.extractShareComponents(shares[0])\n                return constructPublicShareString(\n                    share.bits,\n                    radid,\n                    this.combine(shares, id)\n                )\n            }\n\n            throw new Error(\n                \"Invalid 'id' or 'shares' Array argument to newShare().\"\n            )\n        },\n\n        /* test-code */\n        // export private functions so they can be unit tested directly.\n        _reset: reset,\n        _padLeft: padLeft,\n        _hex2bin: hex2bin,\n        _bin2hex: bin2hex,\n        _hasCryptoGetRandomValues: hasCryptoGetRandomValues,\n        _hasCryptoRandomBytes: hasCryptoRandomBytes,\n        _getRNG: getRNG,\n        _isSetRNG: isSetRNG,\n        _splitNumStringToIntArray: splitNumStringToIntArray,\n        _horner: horner,\n        _lagrange: lagrange,\n        _getShares: getShares,\n        _constructPublicShareString: constructPublicShareString\n        /* end-test-code */\n    }\n\n    // Always initialize secrets with default settings.\n    secrets.init()\n\n    return secrets\n})\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n, title = '') {\n    if (!Number.isSafeInteger(n) || n < 0) {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(`${prefix}expected integer >= 0, got ${n}`);\n    }\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(value, length, title = '') {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash must wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out, undefined, 'digestInto() output');\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('\"digestInto() output\" expected to be of length >=' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * Built-in doesn't validate input to be string: we do the check.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data, errorTitle = '') {\n    if (typeof data === 'string')\n        return utf8ToBytes(data);\n    return abytes(data, undefined, errorTitle);\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/** Merges default options and passed options. */\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options must be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Creates function with outputLen, blockLen, create properties from a class constructor. */\nexport function createHasher(hashCons, info = {}) {\n    const hashC = (msg, opts) => hashCons(opts).update(msg).digest();\n    const tmp = hashCons(undefined);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    Object.assign(hashC, info);\n    return Object.freeze(hashC);\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    const cr = typeof globalThis === 'object' ? globalThis.crypto : null;\n    if (typeof cr?.getRandomValues !== 'function')\n        throw new Error('crypto.getRandomValues must be defined');\n    return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n/** Creates OID opts for NIST hashes, with prefix 06 09 60 86 48 01 65 03 04 02. */\nexport const oidNist = (suffix) => ({\n    oid: Uint8Array.from([0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, suffix]),\n});\n//# sourceMappingURL=utils.js.map","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { abytes, aexists, aoutput, clean, createView } from \"./utils.js\";\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD {\n    blockLen;\n    outputLen;\n    padOffset;\n    isLE;\n    // For partial updates less than block size\n    buffer;\n    view;\n    finished = false;\n    length = 0;\n    pos = 0;\n    destroyed = false;\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which must be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen must be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to ||= new this.constructor();\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\nimport { clean, createHasher, oidNist, rotr } from \"./utils.js\";\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n/** Internal 32-byte base SHA2 hash class. */\nclass SHA2_32B extends HashMD {\n    constructor(outputLen) {\n        super(64, outputLen, 8, false);\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        clean(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/** Internal SHA2-256 hash class. */\nexport class _SHA256 extends SHA2_32B {\n    // We cannot use array here since array allows indexing by variable\n    // which means optimizer/compiler cannot use registers.\n    A = SHA256_IV[0] | 0;\n    B = SHA256_IV[1] | 0;\n    C = SHA256_IV[2] | 0;\n    D = SHA256_IV[3] | 0;\n    E = SHA256_IV[4] | 0;\n    F = SHA256_IV[5] | 0;\n    G = SHA256_IV[6] | 0;\n    H = SHA256_IV[7] | 0;\n    constructor() {\n        super(32);\n    }\n}\n/** Internal SHA2-224 hash class. */\nexport class _SHA224 extends SHA2_32B {\n    A = SHA224_IV[0] | 0;\n    B = SHA224_IV[1] | 0;\n    C = SHA224_IV[2] | 0;\n    D = SHA224_IV[3] | 0;\n    E = SHA224_IV[4] | 0;\n    F = SHA224_IV[5] | 0;\n    G = SHA224_IV[6] | 0;\n    H = SHA224_IV[7] | 0;\n    constructor() {\n        super(28);\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n/** Internal 64-byte base SHA2 hash class. */\nclass SHA2_64B extends HashMD {\n    constructor(outputLen) {\n        super(128, outputLen, 16, false);\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/** Internal SHA2-512 hash class. */\nexport class _SHA512 extends SHA2_64B {\n    Ah = SHA512_IV[0] | 0;\n    Al = SHA512_IV[1] | 0;\n    Bh = SHA512_IV[2] | 0;\n    Bl = SHA512_IV[3] | 0;\n    Ch = SHA512_IV[4] | 0;\n    Cl = SHA512_IV[5] | 0;\n    Dh = SHA512_IV[6] | 0;\n    Dl = SHA512_IV[7] | 0;\n    Eh = SHA512_IV[8] | 0;\n    El = SHA512_IV[9] | 0;\n    Fh = SHA512_IV[10] | 0;\n    Fl = SHA512_IV[11] | 0;\n    Gh = SHA512_IV[12] | 0;\n    Gl = SHA512_IV[13] | 0;\n    Hh = SHA512_IV[14] | 0;\n    Hl = SHA512_IV[15] | 0;\n    constructor() {\n        super(64);\n    }\n}\n/** Internal SHA2-384 hash class. */\nexport class _SHA384 extends SHA2_64B {\n    Ah = SHA384_IV[0] | 0;\n    Al = SHA384_IV[1] | 0;\n    Bh = SHA384_IV[2] | 0;\n    Bl = SHA384_IV[3] | 0;\n    Ch = SHA384_IV[4] | 0;\n    Cl = SHA384_IV[5] | 0;\n    Dh = SHA384_IV[6] | 0;\n    Dl = SHA384_IV[7] | 0;\n    Eh = SHA384_IV[8] | 0;\n    El = SHA384_IV[9] | 0;\n    Fh = SHA384_IV[10] | 0;\n    Fl = SHA384_IV[11] | 0;\n    Gh = SHA384_IV[12] | 0;\n    Gl = SHA384_IV[13] | 0;\n    Hh = SHA384_IV[14] | 0;\n    Hl = SHA384_IV[15] | 0;\n    constructor() {\n        super(48);\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n/** Internal SHA2-512/224 hash class. */\nexport class _SHA512_224 extends SHA2_64B {\n    Ah = T224_IV[0] | 0;\n    Al = T224_IV[1] | 0;\n    Bh = T224_IV[2] | 0;\n    Bl = T224_IV[3] | 0;\n    Ch = T224_IV[4] | 0;\n    Cl = T224_IV[5] | 0;\n    Dh = T224_IV[6] | 0;\n    Dl = T224_IV[7] | 0;\n    Eh = T224_IV[8] | 0;\n    El = T224_IV[9] | 0;\n    Fh = T224_IV[10] | 0;\n    Fl = T224_IV[11] | 0;\n    Gh = T224_IV[12] | 0;\n    Gl = T224_IV[13] | 0;\n    Hh = T224_IV[14] | 0;\n    Hl = T224_IV[15] | 0;\n    constructor() {\n        super(28);\n    }\n}\n/** Internal SHA2-512/256 hash class. */\nexport class _SHA512_256 extends SHA2_64B {\n    Ah = T256_IV[0] | 0;\n    Al = T256_IV[1] | 0;\n    Bh = T256_IV[2] | 0;\n    Bl = T256_IV[3] | 0;\n    Ch = T256_IV[4] | 0;\n    Cl = T256_IV[5] | 0;\n    Dh = T256_IV[6] | 0;\n    Dl = T256_IV[7] | 0;\n    Eh = T256_IV[8] | 0;\n    El = T256_IV[9] | 0;\n    Fh = T256_IV[10] | 0;\n    Fl = T256_IV[11] | 0;\n    Gh = T256_IV[12] | 0;\n    Gl = T256_IV[13] | 0;\n    Hh = T256_IV[14] | 0;\n    Hl = T256_IV[15] | 0;\n    constructor() {\n        super(32);\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634. In JS it's the fastest: even faster than Blake3. Some info:\n *\n * - Trying 2^128 hashes would get 50% chance of collision, using birthday attack.\n * - BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n * - Each sha256 hash is executing 2^18 bit operations.\n * - Good 2024 ASICs can do 200Th/sec with 3500 watts of power, corresponding to 2^36 hashes/joule.\n */\nexport const sha256 = /* @__PURE__ */ createHasher(() => new _SHA256(), \n/* @__PURE__ */ oidNist(0x01));\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224 = /* @__PURE__ */ createHasher(() => new _SHA224(), \n/* @__PURE__ */ oidNist(0x04));\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512 = /* @__PURE__ */ createHasher(() => new _SHA512(), \n/* @__PURE__ */ oidNist(0x03));\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384 = /* @__PURE__ */ createHasher(() => new _SHA384(), \n/* @__PURE__ */ oidNist(0x02));\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256 = /* @__PURE__ */ createHasher(() => new _SHA512_256(), \n/* @__PURE__ */ oidNist(0x06));\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224 = /* @__PURE__ */ createHasher(() => new _SHA512_224(), \n/* @__PURE__ */ oidNist(0x05));\n//# sourceMappingURL=sha2.js.map","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes as abytes_, anumber, bytesToHex as bytesToHex_, concatBytes as concatBytes_, hexToBytes as hexToBytes_, } from '@noble/hashes/utils.js';\nexport { abytes, anumber, bytesToHex, concatBytes, hexToBytes, isBytes, randomBytes, } from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function abool(value, title = '') {\n    if (typeof value !== 'boolean') {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n    }\n    return value;\n}\n// Used in weierstrass, der\nfunction abignumber(n) {\n    if (typeof n === 'bigint') {\n        if (!isPosBig(n))\n            throw new Error('positive bigint expected, got ' + n);\n    }\n    else\n        anumber(n);\n    return n;\n}\nexport function asafenumber(value, title = '') {\n    if (!Number.isSafeInteger(value)) {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(prefix + 'expected safe integer, got type=' + typeof value);\n    }\n}\nexport function numberToHexUnpadded(num) {\n    const hex = abignumber(num).toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    return hexToNumber(bytesToHex_(copyBytes(abytes_(bytes)).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    anumber(len);\n    n = abignumber(n);\n    const res = hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n    if (res.length !== len)\n        throw new Error('number too large');\n    return res;\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes_(numberToHexUnpadded(abignumber(n)));\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as `TextEncoder` for ASCII or throws.\n */\nexport function asciiToBytes(ascii) {\n    return Uint8Array.from(ascii, (c, i) => {\n        const charCode = c.charCodeAt(0);\n        if (c.length !== 1 || charCode > 127) {\n            throw new Error(`string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`);\n        }\n        return charCode;\n    });\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    anumber(hashLen, 'hashLen');\n    anumber(qByteLen, 'qByteLen');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const NULL = Uint8Array.of();\n    const byte0 = Uint8Array.of(0x00);\n    const byte1 = Uint8Array.of(0x01);\n    const _maxDrbgIters = 1000;\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...msgs) => hmacFn(k, concatBytes_(v, ...msgs)); // hmac(k)(v, ...values)\n    const reseed = (seed = NULL) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(byte0, seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(byte1, seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= _maxDrbgIters)\n            throw new Error('drbg: tried max amount of iterations');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes_(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nexport function validateObject(object, fields = {}, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    const iter = (f, isOpt) => Object.entries(f).forEach(([k, v]) => checkField(k, v, isOpt));\n    iter(fields, false);\n    iter(optFields, true);\n}\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes, anumber, bytesToNumberBE, bytesToNumberLE, numberToBytesBE, numberToBytesLE, validateObject, } from \"../utils.js\";\n// Numbers aren't used in x25519 / x448 builds\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = /* @__PURE__ */ BigInt(1), _2n = /* @__PURE__ */ BigInt(2);\n// prettier-ignore\nconst _3n = /* @__PURE__ */ BigInt(3), _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);\n// prettier-ignore\nconst _7n = /* @__PURE__ */ BigInt(7), _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9);\nconst _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n) => {\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n)\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. P  9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P  3 (mod 4) => n = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P  9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n)\n        return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        BYTES: 'number',\n        BITS: 'number',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    validateObject(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nexport function FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nexport function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        anumber(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\nclass _Field {\n    ORDER;\n    BITS;\n    BYTES;\n    isLE;\n    ZERO = _0n;\n    ONE = _1n;\n    _lengths;\n    _sqrt; // cached sqrt\n    _mod;\n    constructor(ORDER, opts = {}) {\n        if (ORDER <= _0n)\n            throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n        let _nbitLength = undefined;\n        this.isLE = false;\n        if (opts != null && typeof opts === 'object') {\n            if (typeof opts.BITS === 'number')\n                _nbitLength = opts.BITS;\n            if (typeof opts.sqrt === 'function')\n                this.sqrt = opts.sqrt;\n            if (typeof opts.isLE === 'boolean')\n                this.isLE = opts.isLE;\n            if (opts.allowedLengths)\n                this._lengths = opts.allowedLengths?.slice();\n            if (typeof opts.modFromBytes === 'boolean')\n                this._mod = opts.modFromBytes;\n        }\n        const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);\n        if (nByteLength > 2048)\n            throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n        this.ORDER = ORDER;\n        this.BITS = nBitLength;\n        this.BYTES = nByteLength;\n        this._sqrt = undefined;\n        Object.preventExtensions(this);\n    }\n    create(num) {\n        return mod(num, this.ORDER);\n    }\n    isValid(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('invalid field element: expected bigint, got ' + typeof num);\n        return _0n <= num && num < this.ORDER; // 0 is valid element, but it's not invertible\n    }\n    is0(num) {\n        return num === _0n;\n    }\n    // is valid and invertible\n    isValidNot0(num) {\n        return !this.is0(num) && this.isValid(num);\n    }\n    isOdd(num) {\n        return (num & _1n) === _1n;\n    }\n    neg(num) {\n        return mod(-num, this.ORDER);\n    }\n    eql(lhs, rhs) {\n        return lhs === rhs;\n    }\n    sqr(num) {\n        return mod(num * num, this.ORDER);\n    }\n    add(lhs, rhs) {\n        return mod(lhs + rhs, this.ORDER);\n    }\n    sub(lhs, rhs) {\n        return mod(lhs - rhs, this.ORDER);\n    }\n    mul(lhs, rhs) {\n        return mod(lhs * rhs, this.ORDER);\n    }\n    pow(num, power) {\n        return FpPow(this, num, power);\n    }\n    div(lhs, rhs) {\n        return mod(lhs * invert(rhs, this.ORDER), this.ORDER);\n    }\n    // Same as above, but doesn't normalize\n    sqrN(num) {\n        return num * num;\n    }\n    addN(lhs, rhs) {\n        return lhs + rhs;\n    }\n    subN(lhs, rhs) {\n        return lhs - rhs;\n    }\n    mulN(lhs, rhs) {\n        return lhs * rhs;\n    }\n    inv(num) {\n        return invert(num, this.ORDER);\n    }\n    sqrt(num) {\n        // Caching _sqrt speeds up sqrt9mod16 by 5x and tonneli-shanks by 10%\n        if (!this._sqrt)\n            this._sqrt = FpSqrt(this.ORDER);\n        return this._sqrt(this, num);\n    }\n    toBytes(num) {\n        return this.isLE ? numberToBytesLE(num, this.BYTES) : numberToBytesBE(num, this.BYTES);\n    }\n    fromBytes(bytes, skipValidation = false) {\n        abytes(bytes);\n        const { _lengths: allowedLengths, BYTES, isLE, ORDER, _mod: modFromBytes } = this;\n        if (allowedLengths) {\n            if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);\n            }\n            const padded = new Uint8Array(BYTES);\n            // isLE add 0 to right, !isLE to the left.\n            padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n            bytes = padded;\n        }\n        if (bytes.length !== BYTES)\n            throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n        let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        if (modFromBytes)\n            scalar = mod(scalar, ORDER);\n        if (!skipValidation)\n            if (!this.isValid(scalar))\n                throw new Error('invalid field element: outside of range 0..ORDER');\n        // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n        // protocol may allow non-reduced scalar that reduced later or changed some other way.\n        return scalar;\n    }\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch(lst) {\n        return FpInvertBatch(this, lst);\n    }\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov(a, b, condition) {\n        return condition ? b : a;\n    }\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, opts = {}) {\n    return new _Field(ORDER, opts);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.Point.Fn.ORDER)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    abytes(key);\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask } from \"../utils.js\";\nimport { Field, FpInvertBatch, validateField } from \"./modular.js\";\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ(c, points) {\n    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));\n    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = bitMask(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n)\n        throw new Error('invalid wNAF');\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF {\n    BASE;\n    ZERO;\n    Fn;\n    bits;\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits) {\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(1) * (Math.ceil( / ) + 1), where:\n     * -  is the window size\n     * -  is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for (let i = 1; i < windowSize; i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n))\n            throw new Error('invalid scalar');\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            }\n            else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return { p, f };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            if (n === _0n)\n                break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // Window bits are 0: skip processing.\n                // Move to next window.\n                continue;\n            }\n            else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === 'function')\n                    comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1)\n            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n)\n            p1 = p1.add(acc);\n        if (k2 & _1n)\n            p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return { p1, p2 };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger(c, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    const fieldN = c.Fn;\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = bitMask(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar  256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255  32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16  255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    const fieldN = c.Fn;\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = bitMask(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction createField(order, field, isLE) {\n    if (field) {\n        if (field.ORDER !== order)\n            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n        validateField(field);\n        return field;\n    }\n    else {\n        return Field(order, { isLE });\n    }\n}\n/** Validates CURVE opts and creates fields */\nexport function createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === undefined)\n        FpFnLE = type === 'edwards';\n    if (!CURVE || typeof CURVE !== 'object')\n        throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of ['p', 'n', 'h']) {\n        const val = CURVE[p];\n        if (!(typeof val === 'bigint' && val > _0n))\n            throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type === 'weierstrass' ? 'b' : 'd';\n    const params = ['Gx', 'Gy', 'a', _b];\n    for (const p of params) {\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p]))\n            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return { CURVE, Fp, Fn };\n}\nexport function createKeygen(randomSecretKey, getPublicKey) {\n    return function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: getPublicKey(secretKey) };\n    };\n}\n//# sourceMappingURL=curve.js.map","/**\n * Twisted Edwards curve. The formula is: ax + y = 1 + dxy.\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abool, abytes, aInRange, bytesToHex, bytesToNumberLE, concatBytes, copyBytes, hexToBytes, isBytes, memoized, notImplemented, validateObject, randomBytes as wcRandomBytes, } from \"../utils.js\";\nimport { createCurveFields, createKeygen, normalizeZ, wNAF, } from \"./curve.js\";\nimport {} from \"./modular.js\";\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\nfunction isEdValidXY(Fp, CURVE, x, y) {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n}\nexport function edwards(params, extraOpts = {}) {\n    const validated = createCurveFields('edwards', params, extraOpts, extraOpts.FpFnLE);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor } = CURVE;\n    validateObject(extraOpts, {}, { uvRatio: 'function' });\n    // Important:\n    // There are some places where Fp.BYTES is used instead of nByteLength.\n    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n    // TODO: test and find curves which behave otherwise.\n    const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);\n    const modP = (n) => Fp.create(n); // Function overrides\n    // sqrt(u/v)\n    const uvRatio = extraOpts.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    // Validate whether the passed curve params are valid.\n    // equation ax + y = 1 + dxy should work for generator point.\n    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    /**\n     * Asserts coordinate is valid: 0 <= n < MASK.\n     * Coordinates >= Fp.ORDER are allowed for zip215.\n     */\n    function acoord(title, n, banZero = false) {\n        const min = banZero ? _1n : _0n;\n        aInRange('coordinate ' + title, n, min, MASK);\n        return n;\n    }\n    function aedpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('EdwardsPoint expected');\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = memoized((p, iz) => {\n        const { X, Y, Z } = p;\n        const is0 = p.is0();\n        if (iz == null)\n            iz = is0 ? _8n : Fp.inv(Z); // 8 was chosen arbitrarily\n        const x = modP(X * iz);\n        const y = modP(Y * iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0)\n            return { x: _0n, y: _1n };\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return { x, y };\n    });\n    const assertValidMemo = memoized((p) => {\n        const { a, d } = CURVE;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax + y = 1 + dxy\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n        const { X, Y, Z, T } = p;\n        const X2 = modP(X * X); // X\n        const Y2 = modP(Y * Y); // Y\n        const Z2 = modP(Z * Z); // Z\n        const Z4 = modP(Z2 * Z2); // Z\n        const aX2 = modP(X2 * a); // aX\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return true;\n    });\n    // Extended Point works in extended coordinates: (X, Y, Z, T)  (x=X/Z, y=Y/Z, T=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        // base / generator point\n        static BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n        // zero / infinity / identity point\n        static ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n        // math field\n        static Fp = Fp;\n        // scalar field\n        static Fn = Fn;\n        X;\n        Y;\n        Z;\n        T;\n        constructor(X, Y, Z, T) {\n            this.X = acoord('x', X);\n            this.Y = acoord('y', Y);\n            this.Z = acoord('z', Z, true);\n            this.T = acoord('t', T);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            acoord('x', x);\n            acoord('y', y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        // Uses algo from RFC8032 5.1.3.\n        static fromBytes(bytes, zip215 = false) {\n            const len = Fp.BYTES;\n            const { a, d } = CURVE;\n            bytes = copyBytes(abytes(bytes, len, 'point'));\n            abool(zip215, 'zip215');\n            const normed = copyBytes(bytes); // copy again, we'll manipulate it\n            const lastByte = bytes[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = bytesToNumberLE(normed);\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            aInRange('point.y', y, _0n, max);\n            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y - 1\n            const v = modP(d * y2 - a); // v = d y + 1.\n            let { isValid, value: x } = uvRatio(u, v); // (u/v)\n            if (!isValid)\n                throw new Error('bad point: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('bad point: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromHex(hex, zip215 = false) {\n            return Point.fromBytes(hexToBytes(hex), zip215);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy)\n                this.multiply(_2n); // random number\n            return this;\n        }\n        // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            aedpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            aedpoint(other);\n            const { a, d } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n            const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            // 1 <= scalar < L\n            if (!Fn.isValidNot0(scalar))\n                throw new Error('invalid scalar: expected 1 <= sc < curve.n');\n            const { p, f } = wnaf.cached(this, scalar, (p) => normalizeZ(Point, p));\n            return normalizeZ(Point, [p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n        multiplyUnsafe(scalar, acc = Point.ZERO) {\n            // 0 <= scalar < L\n            if (!Fn.isValid(scalar))\n                throw new Error('invalid scalar: expected 0 <= sc < curve.n');\n            if (scalar === _0n)\n                return Point.ZERO;\n            if (this.is0() || scalar === _1n)\n                return this;\n            return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafe(this, CURVE.n).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        clearCofactor() {\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        toBytes() {\n            const { x, y } = this.toAffine();\n            // Fp.toBytes() allows non-canonical encoding of y (>= p).\n            const bytes = Fp.toBytes(y);\n            // Each y has 2 valid points: (x, y), (x,-y).\n            // When compressing, it's enough to store y and use the last byte to encode sign of x\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;\n            return bytes;\n        }\n        toHex() {\n            return bytesToHex(this.toBytes());\n        }\n        toString() {\n            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n        }\n    }\n    const wnaf = new wNAF(Point, Fn.BITS);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */\nexport class PrimeEdwardsPoint {\n    static BASE;\n    static ZERO;\n    static Fp;\n    static Fn;\n    ep;\n    constructor(ep) {\n        this.ep = ep;\n    }\n    // Static methods that must be implemented by subclasses\n    static fromBytes(_bytes) {\n        notImplemented();\n    }\n    static fromHex(_hex) {\n        notImplemented();\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    // Common implementations\n    clearCofactor() {\n        // no-op for prime-order groups\n        return this;\n    }\n    assertValidity() {\n        this.ep.assertValidity();\n    }\n    toAffine(invertedZ) {\n        return this.ep.toAffine(invertedZ);\n    }\n    toHex() {\n        return bytesToHex(this.toBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    isTorsionFree() {\n        return true;\n    }\n    isSmallOrder() {\n        return false;\n    }\n    add(other) {\n        this.assertSame(other);\n        return this.init(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        this.assertSame(other);\n        return this.init(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return this.init(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return this.init(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return this.init(this.ep.double());\n    }\n    negate() {\n        return this.init(this.ep.negate());\n    }\n    precompute(windowSize, isLazy) {\n        return this.init(this.ep.precompute(windowSize, isLazy));\n    }\n}\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nexport function eddsa(Point, cHash, eddsaOpts = {}) {\n    if (typeof cHash !== 'function')\n        throw new Error('\"hash\" function param is required');\n    validateObject(eddsaOpts, {}, {\n        adjustScalarBytes: 'function',\n        randomBytes: 'function',\n        domain: 'function',\n        prehash: 'function',\n        mapToCurve: 'function',\n    });\n    const { prehash } = eddsaOpts;\n    const { BASE, Fp, Fn } = Point;\n    const randomBytes = eddsaOpts.randomBytes || wcRandomBytes;\n    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);\n    const domain = eddsaOpts.domain ||\n        ((data, ctx, phflag) => {\n            abool(phflag, 'phflag');\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return Fn.create(bytesToNumberLE(hash)); // Not Fn.fromBytes: it has length limit\n    }\n    // Get the hashed private scalar per RFC8032 5.1.5\n    function getPrivateScalar(key) {\n        const len = lengths.secretKey;\n        abytes(key, lengths.secretKey, 'secretKey');\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = abytes(cHash(key), 2 * len, 'hashedSecretKey');\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        return { head, prefix, scalar };\n    }\n    /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */\n    function getExtendedPublicKey(secretKey) {\n        const { head, prefix, scalar } = getPrivateScalar(secretKey);\n        const point = BASE.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toBytes();\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    /** Calculates EdDSA pub key. RFC8032 5.1.5. */\n    function getPublicKey(secretKey) {\n        return getExtendedPublicKey(secretKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n        const msg = concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, abytes(context, undefined, 'context'), !!prehash)));\n    }\n    /** Signs message with secret key. RFC8032 5.1.6 */\n    function sign(msg, secretKey, options = {}) {\n        msg = abytes(msg, undefined, 'message');\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = BASE.multiply(r).toBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L\n        if (!Fn.isValid(s))\n            throw new Error('sign failed: invalid s'); // 0 <= s < L\n        const rs = concatBytes(R, Fn.toBytes(s));\n        return abytes(rs, lengths.signature, 'result');\n    }\n    // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n    const verifyOpts = { zip215: true };\n    /**\n     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n     * An extended group equation is checked.\n     */\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = lengths.signature;\n        sig = abytes(sig, len, 'signature');\n        msg = abytes(msg, undefined, 'message');\n        publicKey = abytes(publicKey, lengths.publicKey, 'publicKey');\n        if (zip215 !== undefined)\n            abool(zip215, 'zip215');\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const mid = len / 2;\n        const r = sig.subarray(0, mid);\n        const s = bytesToNumberLE(sig.subarray(mid, len));\n        let A, R, SB;\n        try {\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            A = Point.fromBytes(publicKey, zip215);\n            R = Point.fromBytes(r, zip215);\n            SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false; // zip215 allows public keys of small order\n        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // Extended group equation\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().is0();\n    }\n    const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448\n    const lengths = {\n        secretKey: _size,\n        publicKey: _size,\n        signature: 2 * _size,\n        seed: _size,\n    };\n    function randomSecretKey(seed = randomBytes(lengths.seed)) {\n        return abytes(seed, lengths.seed, 'seed');\n    }\n    function isValidSecretKey(key) {\n        return isBytes(key) && key.length === Fn.BYTES;\n    }\n    function isValidPublicKey(key, zip215) {\n        try {\n            return !!Point.fromBytes(key, zip215);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    const utils = {\n        getExtendedPublicKey,\n        randomSecretKey,\n        isValidSecretKey,\n        isValidPublicKey,\n        /**\n         * Converts ed public key to x public key. Uses formula:\n         * - ed25519:\n         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n         * - ed448:\n         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n         */\n        toMontgomery(publicKey) {\n            const { y } = Point.fromBytes(publicKey);\n            const size = lengths.publicKey;\n            const is25519 = size === 32;\n            if (!is25519 && size !== 57)\n                throw new Error('only defined for 25519 and 448');\n            const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n            return Fp.toBytes(u);\n        },\n        toMontgomerySecret(secretKey) {\n            const size = lengths.secretKey;\n            abytes(secretKey, size);\n            const hashed = cHash(secretKey.subarray(0, size));\n            return adjustScalarBytes(hashed).subarray(0, size);\n        },\n    };\n    return Object.freeze({\n        keygen: createKeygen(randomSecretKey, getPublicKey),\n        getPublicKey,\n        sign,\n        verify,\n        utils,\n        Point,\n        lengths,\n    });\n}\n//# sourceMappingURL=edwards.js.map","/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, concatBytes, hexToBytes } from '@noble/hashes/utils.js';\nimport {} from \"./abstract/curve.js\";\nimport { eddsa, edwards, PrimeEdwardsPoint, } from \"./abstract/edwards.js\";\nimport { _DST_scalar, createHasher, expand_message_xmd, } from \"./abstract/hash-to-curve.js\";\nimport { FpInvertBatch, FpSqrtEven, isNegativeLE, mod, pow2, } from \"./abstract/modular.js\";\nimport { montgomery } from \"./abstract/montgomery.js\";\nimport { createORPF } from \"./abstract/oprf.js\";\nimport { asciiToBytes, bytesToNumberLE, equalBytes } from \"./utils.js\";\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n// P = 2n**255n - 19n\nconst ed25519_CURVE_p = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed');\n// N = 2n**252n + 27742317777372353535851937790883648493n\n// a = Fp.create(BigInt(-1))\n// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\nconst ed25519_CURVE = /* @__PURE__ */ (() => ({\n    p: ed25519_CURVE_p,\n    n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),\n    h: _8n,\n    a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),\n    d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),\n    Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),\n    Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),\n}))();\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ed25519_CURVE_p;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n    const b10 = (pow2(b5, _5n, P) * b5) % P;\n    const b20 = (pow2(b10, _10n, P) * b10) % P;\n    const b40 = (pow2(b20, _20n, P) * b20) % P;\n    const b80 = (pow2(b40, _40n, P) * b40) % P;\n    const b160 = (pow2(b80, _80n, P) * b80) % P;\n    const b240 = (pow2(b160, _80n, P) * b80) % P;\n    const b250 = (pow2(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// (-1) aka (a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ed25519_CURVE_p;\n    const v3 = mod(v * v * v, P); // v\n    const v7 = mod(v3 * v3 * v, P); // v\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n    const vx2 = mod(v * x * x, P); // vx\n    const root1 = x; // First root candidate\n    const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if (isNegativeLE(x, P))\n        x = mod(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nconst ed25519_Point = /* @__PURE__ */ edwards(ed25519_CURVE, { uvRatio });\nconst Fp = /* @__PURE__ */ (() => ed25519_Point.Fp)();\nconst Fn = /* @__PURE__ */ (() => ed25519_Point.Fn)();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return concatBytes(asciiToBytes('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nfunction ed(opts) {\n    return eddsa(ed25519_Point, sha512, Object.assign({ adjustScalarBytes }, opts));\n}\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * ```js\n * import { ed25519 } from '@noble/curves/ed25519.js';\n * const { secretKey, publicKey } = ed25519.keygen();\n * // const publicKey = ed25519.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello noble');\n * const sig = ed25519.sign(msg, secretKey);\n * const isValid = ed25519.verify(sig, msg, pub); // ZIP215\n * // RFC8032 / FIPS 186-5\n * const isValid2 = ed25519.verify(sig, msg, pub, { zip215: false });\n * ```\n */\nexport const ed25519 = /* @__PURE__ */ ed({});\n/** Context version of ed25519 (ctx for domain separation). See {@link ed25519} */\nexport const ed25519ctx = /* @__PURE__ */ ed({ domain: ed25519_domain });\n/** Prehashed version of ed25519. See {@link ed25519} */\nexport const ed25519ph = /* @__PURE__ */ ed({ domain: ed25519_domain, prehash: sha512 });\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * ```js\n * import { x25519 } from '@noble/curves/ed25519.js';\n * const alice = x25519.keygen();\n * const bob = x25519.keygen();\n * const shared = x25519.getSharedSecret(alice.secretKey, bob.publicKey);\n * ```\n */\nexport const x25519 = /* @__PURE__ */ (() => {\n    const P = ed25519_CURVE_p;\n    return montgomery({\n        P,\n        type: 'x25519',\n        powPminus2: (x) => {\n            // x^(p-2) aka x^(2^255-21)\n            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n            return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n        },\n        adjustScalarBytes,\n    });\n})();\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n/**\n * RFC 9380 method `map_to_curve_elligator2_curve25519`. Experimental name: may be renamed later.\n * @private\n */\n// prettier-ignore\nexport function _map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = _map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true); // batch division\n    return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\n/** Hashing to ed25519 points / field. RFC 9380 methods. */\nexport const ed25519_hasher = /* @__PURE__ */ (() => createHasher(ed25519_Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: ed25519_CURVE_p,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha512,\n}))();\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519_CURVE;\n    const P = ed25519_CURVE_p;\n    const mod = (n) => Fp.create(n);\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!isNegativeLE(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519_Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Wrapper over Edwards Point for ristretto255.\n *\n * Each ed25519/EdwardsPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like EdwardsPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass _RistrettoPoint extends PrimeEdwardsPoint {\n    // Do NOT change syntax: the following gymnastics is done,\n    // because typescript strips comments, which makes bundlers disable tree-shaking.\n    // prettier-ignore\n    static BASE = \n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519_Point.BASE))();\n    // prettier-ignore\n    static ZERO = \n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519_Point.ZERO))();\n    // prettier-ignore\n    static Fp = \n    /* @__PURE__ */ (() => Fp)();\n    // prettier-ignore\n    static Fn = \n    /* @__PURE__ */ (() => Fn)();\n    constructor(ep) {\n        super(ep);\n    }\n    static fromAffine(ap) {\n        return new _RistrettoPoint(ed25519_Point.fromAffine(ap));\n    }\n    assertSame(other) {\n        if (!(other instanceof _RistrettoPoint))\n            throw new Error('RistrettoPoint expected');\n    }\n    init(ep) {\n        return new _RistrettoPoint(ep);\n    }\n    static fromBytes(bytes) {\n        abytes(bytes, 32);\n        const { a, d } = ed25519_CURVE;\n        const P = ed25519_CURVE_p;\n        const mod = (n) => Fp.create(n);\n        const s = bytes255ToNumberLE(bytes);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!equalBytes(Fp.toBytes(s), bytes) || isNegativeLE(s, P))\n            throw new Error('invalid ristretto255 encoding 1');\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if (isNegativeLE(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || isNegativeLE(t, P) || y === _0n)\n            throw new Error('invalid ristretto255 encoding 2');\n        return new _RistrettoPoint(new ed25519_Point(x, y, _1n, t));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        return _RistrettoPoint.fromBytes(hexToBytes(hex));\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n     */\n    toBytes() {\n        let { X, Y, Z, T } = this.ep;\n        const P = ed25519_CURVE_p;\n        const mod = (n) => Fp.create(n);\n        const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1\n        const u2 = mod(X * Y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * T); // 6\n        let D; // 7\n        if (isNegativeLE(T * zInv, P)) {\n            let _x = mod(Y * SQRT_M1);\n            let _y = mod(X * SQRT_M1);\n            X = _x;\n            Y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if (isNegativeLE(X * zInv, P))\n            Y = mod(-Y); // 9\n        let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))\n        if (isNegativeLE(s, P))\n            s = mod(-s);\n        return Fp.toBytes(s); // 11\n    }\n    /**\n     * Compares two Ristretto points.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n     */\n    equals(other) {\n        this.assertSame(other);\n        const { X: X1, Y: Y1 } = this.ep;\n        const { X: X2, Y: Y2 } = other.ep;\n        const mod = (n) => Fp.create(n);\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    is0() {\n        return this.equals(_RistrettoPoint.ZERO);\n    }\n}\nexport const ristretto255 = { Point: _RistrettoPoint };\n/** Hashing to ristretto255 points / field. RFC 9380 methods. */\nexport const ristretto255_hasher = {\n    Point: _RistrettoPoint,\n    /**\n    * Spec: https://www.rfc-editor.org/rfc/rfc9380.html#name-hashing-to-ristretto255. Caveats:\n    * * There are no test vectors\n    * * encodeToCurve / mapToCurve is undefined\n    * * mapToCurve would be `calcElligatorRistrettoMap(scalars[0])`, not ristretto255_map!\n    * * hashToScalar is undefined too, so we just use OPRF implementation\n    * * We cannot re-use 'createHasher', because ristretto255_map is different algorithm/RFC\n      (os2ip -> bytes255ToNumberLE)\n    * * mapToCurve == calcElligatorRistrettoMap, hashToCurve == ristretto255_map\n    * * hashToScalar is undefined in RFC9380 for ristretto, we are using version from OPRF here, using bytes255ToNumblerLE will create different result if we use bytes255ToNumberLE as os2ip\n    * * current version is closest to spec.\n    */\n    hashToCurve(msg, options) {\n        // == 'hash_to_ristretto255'\n        const DST = options?.DST || 'ristretto255_XMD:SHA-512_R255MAP_RO_';\n        const xmd = expand_message_xmd(msg, DST, 64, sha512);\n        // NOTE: RFC 9380 incorrectly calls this function 'ristretto255_map', in RFC 9496 map was function inside (per point)\n        // That also lead to confustion that ristretto255_map is mapToCurve (it is not! it is old hashToCurve)\n        return ristretto255_hasher.deriveToCurve(xmd);\n    },\n    hashToScalar(msg, options = { DST: _DST_scalar }) {\n        const xmd = expand_message_xmd(msg, options.DST, 64, sha512);\n        return Fn.create(bytesToNumberLE(xmd));\n    },\n    /**\n     * HashToCurve-like construction based on RFC 9496 (Element Derivation).\n     * Converts 64 uniform random bytes into a curve point.\n     *\n     * WARNING: This represents an older hash-to-curve construction, preceding the finalization of RFC 9380.\n     * It was later reused as a component in the newer `hash_to_ristretto255` function defined in RFC 9380.\n     */\n    deriveToCurve(bytes) {\n        // https://www.rfc-editor.org/rfc/rfc9496.html#name-element-derivation\n        abytes(bytes, 64);\n        const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new _RistrettoPoint(R1.add(R2));\n    },\n};\n/** ristretto255 OPRF, defined in RFC 9497. */\nexport const ristretto255_oprf = /* @__PURE__ */ (() => createORPF({\n    name: 'ristretto255-SHA512',\n    Point: _RistrettoPoint,\n    hash: sha512,\n    hashToGroup: ristretto255_hasher.hashToCurve,\n    hashToScalar: ristretto255_hasher.hashToScalar,\n}))();\n/**\n * Weird / bogus points, useful for debugging.\n * All 8 ed25519 points of 8-torsion subgroup can be generated from the point\n * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.\n * T = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }\n */\nexport const ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n//# sourceMappingURL=ed25519.js.map","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexport const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport const wrapConstructor = createHasher;\nexport const wrapConstructorWithOpts = createOptHasher;\nexport const wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { Hash, abytes, aexists, aoutput, clean, createView, toBytes } from \"./utils.js\";\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\nimport { clean, createHasher, rotr } from \"./utils.js\";\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        clean(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\nexport class SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = SHA224_IV[0] | 0;\n        this.B = SHA224_IV[1] | 0;\n        this.C = SHA224_IV[2] | 0;\n        this.D = SHA224_IV[3] | 0;\n        this.E = SHA224_IV[4] | 0;\n        this.F = SHA224_IV[5] | 0;\n        this.G = SHA224_IV[6] | 0;\n        this.H = SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = SHA512_IV[0] | 0;\n        this.Al = SHA512_IV[1] | 0;\n        this.Bh = SHA512_IV[2] | 0;\n        this.Bl = SHA512_IV[3] | 0;\n        this.Ch = SHA512_IV[4] | 0;\n        this.Cl = SHA512_IV[5] | 0;\n        this.Dh = SHA512_IV[6] | 0;\n        this.Dl = SHA512_IV[7] | 0;\n        this.Eh = SHA512_IV[8] | 0;\n        this.El = SHA512_IV[9] | 0;\n        this.Fh = SHA512_IV[10] | 0;\n        this.Fl = SHA512_IV[11] | 0;\n        this.Gh = SHA512_IV[12] | 0;\n        this.Gl = SHA512_IV[13] | 0;\n        this.Hh = SHA512_IV[14] | 0;\n        this.Hl = SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexport class SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = SHA384_IV[0] | 0;\n        this.Al = SHA384_IV[1] | 0;\n        this.Bh = SHA384_IV[2] | 0;\n        this.Bl = SHA384_IV[3] | 0;\n        this.Ch = SHA384_IV[4] | 0;\n        this.Cl = SHA384_IV[5] | 0;\n        this.Dh = SHA384_IV[6] | 0;\n        this.Dl = SHA384_IV[7] | 0;\n        this.Eh = SHA384_IV[8] | 0;\n        this.El = SHA384_IV[9] | 0;\n        this.Fh = SHA384_IV[10] | 0;\n        this.Fl = SHA384_IV[11] | 0;\n        this.Gh = SHA384_IV[12] | 0;\n        this.Gl = SHA384_IV[13] | 0;\n        this.Hh = SHA384_IV[14] | 0;\n        this.Hl = SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nexport class SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexport class SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256 = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224 = /* @__PURE__ */ createHasher(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512 = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384 = /* @__PURE__ */ createHasher(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256 = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224 = /* @__PURE__ */ createHasher(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map","/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nimport { SHA224 as SHA224n, sha224 as sha224n, SHA256 as SHA256n, sha256 as sha256n, } from \"./sha2.js\";\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA256 = SHA256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha256 = sha256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA224 = SHA224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha224 = sha224n;\n//# sourceMappingURL=sha256.js.map","/**\n * Solana Ed25519 keypair derivation from seed\n *\n * Derives a Solana-compatible Ed25519 keypair from the 16-byte wallet seed.\n * The 16-byte seed is expanded to 32 bytes using SHA-256 for Ed25519 compatibility.\n *\n * ## S-4: Non-Standard Derivation Warning\n *\n * This derivation is **NOT BIP-44/BIP-39 compatible**. A 12-word recovery phrase\n * generated by this system will NOT produce the same Solana address when imported\n * into standard wallets (Phantom, Solflare, Backpack, etc.) because:\n *\n * 1. Standard wallets use BIP-44 path `m/44'/501'/0'/0'` with HMAC-SHA512\n * 2. This system uses SHA-256 expansion of a 16-byte seed (no derivation path)\n *\n * This is an intentional design decision: the wallet is app-locked and recovery\n * is handled within the cedros-login system. Users should NOT attempt to import\n * their recovery phrase into external wallets.\n *\n * Security:\n * - Uses @noble/curves for audited Ed25519 implementation (CRYPTO-1 fix)\n * - Uses SHA-256 to deterministically expand 16-byte seed to 32 bytes\n * - Produces deterministic keypairs from the same seed\n * - Private key material is wiped after derivation when requested\n */\n\nimport { ed25519 } from '@noble/curves/ed25519.js';\nimport { hkdf } from '@noble/hashes/hkdf';\nimport { sha256 } from '@noble/hashes/sha256';\nimport type { Seed } from './types';\nimport { wipeBytes } from './secureWipe';\n\n/** Solana keypair with public and secret key */\nexport interface SolanaKeypair {\n  /** 32-byte Ed25519 public key */\n  publicKey: Uint8Array;\n  /** 64-byte Ed25519 secret key (32-byte expanded seed + 32-byte public key) */\n  secretKey: Uint8Array;\n}\n\n/** Base58 alphabet used by Solana */\nconst BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/** UI-20: Pre-computed character-to-index lookup table for O(1) base58 decoding */\nconst BASE58_CHAR_TO_INDEX: Record<string, number> = {};\nfor (let i = 0; i < BASE58_ALPHABET.length; i++) {\n  BASE58_CHAR_TO_INDEX[BASE58_ALPHABET[i]] = i;\n}\n\n/**\n * Derive an Ed25519 keypair from a 16-byte seed\n *\n * The 16-byte seed is expanded to 32 bytes using SHA-256, then used for\n * Ed25519 derivation which internally:\n * - Hashes expanded seed with SHA-512\n * - Clamps lower 32 bytes to form scalar\n * - Multiplies by Ed25519 base point\n *\n * @param seed - 16-byte seed (128-bit entropy)\n * @returns Keypair with 32-byte public key and 64-byte secret key\n *\n * @security **CALLER MUST WIPE secretKey AFTER USE**\n * The returned `secretKey` contains sensitive cryptographic material.\n * Callers are responsible for wiping it when no longer needed:\n * ```ts\n * const keypair = deriveKeypairFromSeed(seed);\n * try {\n *   // use keypair.secretKey for signing\n * } finally {\n *   wipeBytes(keypair.secretKey);\n * }\n * ```\n * Failure to wipe may leave key material in memory, vulnerable to memory\n * dump attacks. The internal `expandedSeed` is automatically wiped.\n */\nexport function deriveKeypairFromSeed(seed: Seed): SolanaKeypair {\n  if (seed.length !== 16) {\n    throw new Error(`Invalid seed length: expected 16, got ${seed.length}`);\n  }\n\n  // Expand 16-byte seed to 32 bytes using SHA-256\n  // This is deterministic and provides the 32 bytes needed for Ed25519\n  const expandedSeed = sha256(seed);\n\n  // Use @noble/curves audited Ed25519 implementation (CRYPTO-1)\n  const publicKey = ed25519.getPublicKey(expandedSeed);\n\n  // Create the 64-byte secret key (expandedSeed || publicKey)\n  // Solana uses this format for compatibility with nacl\n  const secretKey = new Uint8Array(64);\n  secretKey.set(expandedSeed, 0);\n  secretKey.set(publicKey, 32);\n\n  // S-3: Wipe the intermediate expandedSeed buffer. Note: this data is already\n  // copied into secretKey (which the CALLER must wipe), so this wipe only reduces\n  // the number of in-memory copies  it does not eliminate the key material entirely.\n  wipeBytes(expandedSeed);\n\n  return { publicKey, secretKey };\n}\n\n/**\n * Get the public key from a seed without returning the secret key\n *\n * @param seed - 32-byte seed\n * @returns 32-byte Ed25519 public key\n */\nexport function getPublicKeyFromSeed(seed: Seed): Uint8Array {\n  const keypair = deriveKeypairFromSeed(seed);\n  const publicKey = keypair.publicKey;\n\n  // Wipe the secret key\n  wipeBytes(keypair.secretKey);\n\n  return publicKey;\n}\n\n/**\n * Encode a public key as a Base58 Solana address\n *\n * @param publicKey - 32-byte public key\n * @returns Base58-encoded address string\n */\nexport function publicKeyToBase58(publicKey: Uint8Array): string {\n  if (publicKey.length !== 32) {\n    throw new Error(`Invalid public key length: expected 32, got ${publicKey.length}`);\n  }\n\n  return base58Encode(publicKey);\n}\n\n/**\n * Decode a Base58 Solana address to public key bytes\n *\n * @param address - Base58-encoded address\n * @returns 32-byte public key\n */\nexport function base58ToPublicKey(address: string): Uint8Array {\n  const decoded = base58Decode(address);\n\n  if (decoded.length !== 32) {\n    throw new Error(`Invalid address: decoded to ${decoded.length} bytes`);\n  }\n\n  return decoded;\n}\n\n/**\n * Derive a child seed from a master seed at a given derivation index.\n *\n * - Index 0: Returns the master seed directly (backward compatible with existing wallets).\n * - Index > 0: HKDF-SHA256(ikm=masterSeed, salt=\"cedros-derived-wallet\", info=u32_be(index)).\n *\n * Uses a custom derivation (NOT BIP-44) to keep wallets app-locked.\n * Must match the server-side `derive_child_seed_from_bytes()`.\n *\n * @param masterSeed - 32-byte master seed (SHA-256 expanded from 16-byte seed)\n * @param index - Derivation index (0 = default wallet)\n * @returns 32-byte derived child seed\n */\nexport function deriveChildSeed(masterSeed: Uint8Array, index: number): Uint8Array {\n  if (masterSeed.length !== 32) {\n    throw new Error(`Invalid master seed length: expected 32, got ${masterSeed.length}`);\n  }\n  if (index === 0) {\n    // Return a copy to avoid mutation\n    return new Uint8Array(masterSeed);\n  }\n  // Encode index as big-endian u32\n  const info = new Uint8Array(4);\n  new DataView(info.buffer).setUint32(0, index, false);\n  return hkdf(sha256, masterSeed, 'cedros-derived-wallet', info, 32);\n}\n\n/**\n * Get the public key for a derived wallet at a given index.\n *\n * @param seed - 16-byte original seed\n * @param index - Derivation index (0 = default, >0 = derived)\n * @returns Base58-encoded Solana public key\n */\nexport function getPublicKeyAtIndex(seed: Seed, index: number): string {\n  // Expand 16-byte seed to 32-byte master seed\n  const masterSeed = sha256(seed);\n  const childSeed = deriveChildSeed(masterSeed, index);\n  wipeBytes(masterSeed);\n\n  const publicKey = ed25519.getPublicKey(childSeed);\n  wipeBytes(childSeed);\n\n  return publicKeyToBase58(publicKey);\n}\n\n/**\n * Validate a Solana address format\n *\n * @param address - Address string to validate\n * @returns true if valid Base58 and correct length\n */\nexport function isValidSolanaAddress(address: string): boolean {\n  if (typeof address !== 'string') return false;\n  if (address.length < 32 || address.length > 44) return false;\n\n  try {\n    const decoded = base58Decode(address);\n    return decoded.length === 32;\n  } catch {\n    return false;\n  }\n}\n\n// --- Base58 implementation ---\n\nfunction base58Encode(bytes: Uint8Array): string {\n  // Count leading zeros\n  let zeros = 0;\n  for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {\n    zeros++;\n  }\n\n  // Convert to big integer\n  let num = 0n;\n  for (let i = 0; i < bytes.length; i++) {\n    num = num * 256n + BigInt(bytes[i]);\n  }\n\n  // Convert to base58\n  let str = '';\n  while (num > 0n) {\n    const remainder = Number(num % 58n);\n    str = BASE58_ALPHABET[remainder] + str;\n    num = num / 58n;\n  }\n\n  // Add leading '1's for each leading zero byte\n  return '1'.repeat(zeros) + str;\n}\n\nfunction base58Decode(str: string): Uint8Array {\n  // Count leading '1's\n  let zeros = 0;\n  for (let i = 0; i < str.length && str[i] === '1'; i++) {\n    zeros++;\n  }\n\n  // Convert from base58 using pre-computed lookup table (UI-20)\n  let num = 0n;\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    const index = BASE58_CHAR_TO_INDEX[char];\n    if (index === undefined) {\n      throw new Error(`Invalid base58 character: ${char}`);\n    }\n    num = num * 58n + BigInt(index);\n  }\n\n  // Convert to bytes\n  const bytes: number[] = [];\n  while (num > 0n) {\n    bytes.unshift(Number(num % 256n));\n    num = num / 256n;\n  }\n\n  // Add leading zeros\n  const result = new Uint8Array(zeros + bytes.length);\n  result.set(bytes, zeros);\n\n  return result;\n}\n","/**\n * Shamir Secret Sharing using secrets.js-grempe\n *\n * Implements 2-of-3 threshold secret sharing:\n * - Share A: Encrypted with user credential (password/PIN/passkey PRF), stored on server\n * - Share B: Plaintext stored on server (SSS math protects it - 1 share reveals nothing)\n * - Share C: Encoded as BIP-39 mnemonic for recovery (never sent to server)\n *\n * Security:\n * - Any 2 shares can reconstruct the secret\n * - Any 1 share reveals nothing about the secret\n * - Uses GF(2^8) arithmetic for information-theoretic security\n */\n\nimport secrets from 'secrets.js-grempe';\nimport type { Seed, ShamirShare } from './types';\nimport { toSeed, toShamirShare } from './types';\nimport { wipeAll } from './secureWipe';\nimport { getPublicKeyFromSeed } from './solanaKeypair';\n\n/** Shamir threshold (minimum shares to reconstruct) */\nexport const SHAMIR_THRESHOLD = 2;\n\n/** Total number of shares */\nexport const SHAMIR_TOTAL = 3;\n\n/** Share identifiers */\nexport type ShareId = 'A' | 'B' | 'C';\n\n/** Result of splitting a secret into shares */\nexport interface ShamirSplitResult {\n  /** Share A (for password encryption) */\n  shareA: ShamirShare;\n  /** Share B (for device PRF encryption) */\n  shareB: ShamirShare;\n  /** Share C (for recovery phrase) */\n  shareC: ShamirShare;\n}\n\n/**\n * Split a 16-byte seed into 3 shares using Shamir's Secret Sharing\n *\n * @param seed - 16-byte seed to split\n * @returns Three shares (any 2 can reconstruct the seed)\n */\nexport function splitSecret(seed: Seed): ShamirSplitResult {\n  if (seed.length !== 16) {\n    throw new Error(`Invalid seed length: expected 16, got ${seed.length}`);\n  }\n\n  // Convert seed to hex string for secrets.js\n  const seedHex = uint8ArrayToHex(seed);\n\n  // Split into 3 shares with threshold 2\n  const shares = secrets.share(seedHex, SHAMIR_TOTAL, SHAMIR_THRESHOLD);\n\n  if (shares.length !== 3) {\n    throw new Error(`Unexpected share count: ${shares.length}`);\n  }\n\n  // Convert hex shares back to Uint8Array\n  // secrets.js adds a prefix with share index, we keep the full share format\n  const shareA = hexShareToBytes(shares[0]);\n  const shareB = hexShareToBytes(shares[1]);\n  const shareC = hexShareToBytes(shares[2]);\n\n  return {\n    shareA: toShamirShare(shareA),\n    shareB: toShamirShare(shareB),\n    shareC: toShamirShare(shareC),\n  };\n}\n\n/**\n * Combine 2 shares to reconstruct the original seed\n *\n * @param share1 - First share\n * @param share2 - Second share (must be different from first)\n * @param expectedPublicKey - Optional 32-byte Ed25519 public key. When provided,\n *   the reconstructed seed is used to derive the corresponding public key and the\n *   two are compared byte-for-byte. Throws if they do not match, preventing\n *   silent use of a corrupted or wrong-share combination (UI-03).\n * @returns Reconstructed 16-byte seed (MAINT-03: fixed from incorrect \"32-byte\")\n * @throws Error if shares are invalid, cannot reconstruct, or public key mismatch\n */\nexport function combineShares(\n  share1: ShamirShare,\n  share2: ShamirShare,\n  expectedPublicKey?: Uint8Array\n): Seed {\n  // Convert shares back to hex format for secrets.js\n  const hexShare1 = bytesToHexShare(share1);\n  const hexShare2 = bytesToHexShare(share2);\n\n  try {\n    // Combine shares\n    const seedHex = secrets.combine([hexShare1, hexShare2]);\n\n    // Convert back to bytes\n    const seed = hexToUint8Array(seedHex);\n\n    if (seed.length !== 16) {\n      throw new Error(`Reconstructed seed has wrong length: ${seed.length}`);\n    }\n\n    const typedSeed = toSeed(seed);\n\n    // UI-03: Verify reconstructed seed produces the expected public key.\n    if (expectedPublicKey !== undefined) {\n      if (expectedPublicKey.length !== 32) {\n        throw new Error(\n          `Invalid expectedPublicKey length: expected 32, got ${expectedPublicKey.length}`\n        );\n      }\n      const derivedPublicKey = getPublicKeyFromSeed(typedSeed);\n      let mismatch = 0;\n      for (let i = 0; i < 32; i++) {\n        mismatch |= derivedPublicKey[i] ^ expectedPublicKey[i];\n      }\n      if (mismatch !== 0) {\n        wipeAll(typedSeed);\n        throw new Error(\n          'Reconstructed seed does not match expected public key. ' +\n            'The shares may be corrupt or belong to a different wallet.'\n        );\n      }\n    }\n\n    return typedSeed;\n  } catch (err) {\n    if (err instanceof Error && err.message.startsWith('Reconstructed seed')) {\n      throw err;\n    }\n    if (err instanceof Error && err.message.startsWith('Invalid expectedPublicKey')) {\n      throw err;\n    }\n    if (err instanceof Error && err.message.startsWith('Reconstructed seed does not match')) {\n      throw err;\n    }\n    throw new Error('Failed to reconstruct seed from shares');\n  }\n}\n\n/**\n * Verify that shares can successfully reconstruct a seed\n *\n * @param share1 - First share\n * @param share2 - Second share\n * @param expectedSeed - Expected seed after reconstruction\n * @returns true if shares reconstruct to expected seed\n */\nexport function verifyShares(\n  share1: ShamirShare,\n  share2: ShamirShare,\n  expectedSeed: Seed\n): boolean {\n  let reconstructed: Seed | undefined;\n  try {\n    reconstructed = combineShares(share1, share2);\n\n    // Constant-time comparison\n    if (reconstructed.length !== expectedSeed.length) {\n      return false;\n    }\n\n    let result = 0;\n    for (let i = 0; i < reconstructed.length; i++) {\n      result |= reconstructed[i] ^ expectedSeed[i];\n    }\n\n    return result === 0;\n  } catch {\n    return false;\n  } finally {\n    if (reconstructed) {\n      wipeAll(reconstructed);\n    }\n  }\n}\n\n/**\n * Extract share index from a share (useful for debugging)\n *\n * @param share - Share to inspect\n * @returns Share index (1-based)\n */\nexport function getShareIndex(share: ShamirShare): number {\n  // secrets.js encodes the index in the first byte(s)\n  // The hex format is: {bits}{id}{data}\n  const hexShare = bytesToHexShare(share);\n  return secrets.extractShareComponents(hexShare).id;\n}\n\n// --- Internal utilities ---\n\n/**\n * Convert Uint8Array to hex string\n */\nfunction uint8ArrayToHex(bytes: Uint8Array): string {\n  return Array.from(bytes)\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\n/**\n * Convert hex string to Uint8Array\n * CRYPTO-01: Validates hex characters and length before parsing\n */\nfunction hexToUint8Array(hex: string): Uint8Array {\n  // CRYPTO-01: Validate hex characters before parsing\n  if (!/^[0-9a-fA-F]*$/.test(hex)) {\n    throw new Error('Invalid hex string: contains non-hex characters');\n  }\n  // CRYPTO-01: Validate even length (each byte is 2 hex chars)\n  if (hex.length % 2 !== 0) {\n    throw new Error(`Invalid hex string: length ${hex.length} is odd (must be even)`);\n  }\n  const bytes = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * Convert hex share from secrets.js to bytes\n *\n * S-1 FIX: Explicit padding tracking via flag byte.\n *\n * secrets.js shares have format: {bits}{id}{data} where:\n * - bits: 1-2 hex chars indicating bit mode (e.g., \"8\" for 8-bit)\n * - id: 1-2 hex chars for share ID (1-255)\n * - data: the actual share data\n *\n * The hex string can have odd length (e.g., \"801...\" for 8-bit mode).\n * We pad odd-length strings to even by prepending \"0\", and store a flag\n * byte at position 0 to track whether padding was applied:\n * - 0x01 = odd-length hex, padding was added\n * - 0x00 = even-length hex, no padding\n */\nfunction hexShareToBytes(hexShare: string): Uint8Array {\n  const isOdd = hexShare.length % 2 !== 0;\n  const paddedHex = isOdd ? '0' + hexShare : hexShare;\n  const dataBytes = hexToUint8Array(paddedHex);\n  // S-1: Prepend flag byte to explicitly track padding\n  const result = new Uint8Array(1 + dataBytes.length);\n  result[0] = isOdd ? 1 : 0;\n  result.set(dataBytes, 1);\n  return result;\n}\n\n/**\n * Convert bytes back to hex share format for secrets.js\n *\n * S-1 FIX: Uses explicit flag byte instead of heuristic padding detection.\n *\n * New format (flag byte at position 0):\n * - 0x00: even-length hex, return as-is\n * - 0x01: odd-length hex, strip the leading \"0\" that was added as padding\n *\n * UI-23: Ambiguity note  0x01 is used as both the new-format odd-padding\n * marker and could be the first data byte of a legacy share. To distinguish,\n * we validate that the decoded hex looks like a valid secrets.js share\n * (must start with a known bits prefix such as \"8\"). If it does not, fall\n * through to the legacy path.\n *\n * Legacy format (backward compat for shares stored before S-1 fix):\n * - Shares without known version markers: use heuristic stripping\n */\nfunction bytesToHexShare(bytes: Uint8Array): string {\n  const firstByte = bytes[0];\n\n  // S-1: New format  explicit flag byte (0x00 = even, 0x01 = odd with padding)\n  if (firstByte === 0x00 || firstByte === 0x01) {\n    const wasOdd = firstByte === 0x01;\n    const dataBytes = bytes.subarray(1);\n    const candidateHex = uint8ArrayToHex(dataBytes);\n    const resultHex = wasOdd ? candidateHex.substring(1) : candidateHex;\n    // UI-23: Validate the decoded hex is a plausible secrets.js share (starts with\n    // a known bits value). If not, treat this share as legacy format.\n    if (/^[0-9a-f]/.test(resultHex)) {\n      return resultHex;\n    }\n  }\n\n  // Legacy format (pre-S-1): heuristic-based for backward compatibility.\n  // Treat shares without known version markers as legacy.\n  const hex = uint8ArrayToHex(bytes);\n  if (hex.startsWith('0') && !hex.startsWith('00')) {\n    return hex.substring(1);\n  }\n  return hex;\n}\n\n/**\n * Exported for testing only  do not use outside of tests.\n */\nexport const _internal = {\n  hexShareToBytes,\n  bytesToHexShare,\n  uint8ArrayToHex,\n  hexToUint8Array,\n};\n\n/**\n * Pad a Uint8Array to a specific length\n */\nexport function padToLength(data: Uint8Array, targetLength: number): Uint8Array {\n  if (data.length >= targetLength) {\n    return data;\n  }\n  const padded = new Uint8Array(targetLength);\n  padded.set(data);\n  return padded;\n}\n"],"names":["worker","nextId","pending","getWorker","event","id","key","error","handlers","argon2DeriveInWorker","password","salt","params","DEFAULT_KDF_PARAMS","validateKdfParams","argonWorker","resolve","reject","payload","argon2Derive","cryptoShim","webcrypto","subtle","getRandomValues","randomUUID","root","factory","module","require$$0","this","crypto","defaults","config","preGenPadding","runCSPRNGTest","CSPRNGTypes","reset","isSetRNG","padLeft","str","multipleOfBits","missing","hex2bin","bin","num","i","bin2hex","hex","hasCryptoGetRandomValues","hasCryptoRandomBytes","getRNG","type","construct","bits","arr","radix","size","len","parsedInt","nodeCryptoRandomBytes","buf","bytes","browserCryptoGetRandomValues","elems","testRandom","int","splitNumStringToIntArray","padLength","parts","horner","x","coeffs","logx","fx","lagrange","at","y","sum","product","j","getShares","secret","numShares","threshold","shares","constructPublicShareString","data","bitsBase36","idHex","idMax","idPaddingLen","newShareString","secrets","rngType","logs","exps","primitive","len2","result","setBits","share","splitShare","obj","idLen","max","regexStr","shareComponents","rng","errPrefix","errSuffix","bytesPerChar","hexChars","out","neededBytes","neededBits","subShares","radid","isBytes","a","anumber","n","title","prefix","abytes","value","length","needsLen","ofLen","got","aexists","instance","checkFinished","aoutput","min","clean","arrays","createView","hasHexBuiltin","hexes","_","bytesToHex","asciis","asciiToBase16","ch","hexToBytes","hl","al","array","ai","hi","n1","n2","char","concatBytes","res","pad","createHasher","hashCons","info","hashC","msg","opts","tmp","randomBytes","bytesLength","cr","oidNist","suffix","HashMD$1","blockLen","outputLen","padOffset","isLE","view","buffer","pos","take","dataView","oview","outLen","state","to","finished","destroyed","SHA512_IV","U32_MASK64","_32n","fromBig","le","split","lst","Ah","Al","h","l","shrSH","_l","s","shrSL","rotrSH","rotrSL","rotrBH","rotrBL","add","Bh","Bl","add3L","Cl","add3H","low","Ch","add4L","Dl","add4H","Dh","add5L","El","add5H","Eh","K512","u64.split","SHA512_Kh","SHA512_Kl","SHA512_W_H","SHA512_W_L","SHA2_64B","HashMD","Fh","Fl","Gh","Gl","Hh","Hl","offset","W15h","W15l","s0h","u64.rotrSH","u64.shrSH","s0l","u64.rotrSL","u64.shrSL","W2h","W2l","s1h","u64.rotrBH","s1l","u64.rotrBL","SUMl","u64.add4L","SUMh","u64.add4H","sigma1h","sigma1l","CHIh","CHIl","T1ll","u64.add5L","T1h","u64.add5H","T1l","sigma0h","sigma0l","MAJh","MAJl","u64.add","All","u64.add3L","u64.add3H","_SHA512","sha512","_0n","_1n","abool","abignumber","isPosBig","hexToNumber","bytesToNumberBE","bytesToHex_","bytesToNumberLE","copyBytes","abytes_","numberToBytesBE","hexToBytes_","numberToBytesLE","inRange","aInRange","bitMask","validateObject","object","fields","optFields","checkField","fieldName","expectedType","isOpt","val","current","iter","f","k","v","memoized","fn","map","arg","args","computed","_2n","_3n","_4n","_5n","_7n","_8n","_9n","_16n","mod","b","pow2","power","modulo","invert","number","u","q","r","m","assertIsSquare","Fp","sqrt3mod4","p1div4","sqrt5mod8","p5div8","nv","sqrt9mod16","P","Fp_","Field","tn","tonelliShanks","c1","c2","c3","c4","tv1","tv2","tv3","tv4","e1","e2","e3","Q","S","Z","_Fp","FpLegendre","cc","Q1div2","M","c","t","R","t_tmp","exponent","FpSqrt","isNegativeLE","FIELD_FIELDS","validateField","field","initial","FpPow","p","d","FpInvertBatch","nums","passZero","inverted","multipliedAcc","acc","invertedAcc","p1mod2","powered","yes","zero","no","nLength","nBitLength","_nBitLength","nByteLength","_Field","ORDER","_nbitLength","lhs","rhs","skipValidation","allowedLengths","BYTES","modFromBytes","padded","scalar","condition","negateCt","item","neg","normalizeZ","points","invertedZs","validateW","W","calcWOpts","scalarBits","windows","windowSize","maxNumber","mask","shiftBy","calcOffsets","window","wOpts","wbits","nextN","offsetStart","isZero","isNeg","isNegF","pointPrecomputes","pointWindowSizes","getW","assert0","wNAF","Point","elm","point","base","precomputes","wo","offsetF","transform","comp","prev","createField","order","createCurveFields","CURVE","curveOpts","FpFnLE","Fn","createKeygen","randomSecretKey","getPublicKey","seed","secretKey","isEdValidXY","x2","y2","left","right","edwards","extraOpts","validated","cofactor","MASK","modP","uvRatio","acoord","banZero","aedpoint","other","toAffineMemo","iz","X","Y","is0","zz","assertValidMemo","T","X2","Y2","Z2","Z4","aX2","XY","ZT","zip215","normed","lastByte","isValid","isXOdd","isLastByteOdd","isLazy","wnaf","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","T1","T2","invertedZ","eddsa","cHash","eddsaOpts","prehash","BASE","wcRandomBytes","adjustScalarBytes","domain","ctx","phflag","modN_LE","hash","getPrivateScalar","lengths","hashed","head","getExtendedPublicKey","pointBytes","hashDomainToScalar","context","msgs","sign","options","rs","verifyOpts","verify","sig","publicKey","mid","SB","_size","isValidSecretKey","isValidPublicKey","utils","is25519","ed25519_CURVE_p","ed25519_CURVE","ed25519_pow_2_252_3","_10n","_20n","_40n","_80n","b2","b4","b5","b10","b20","b40","b80","b160","b240","b250","ED25519_SQRT_M1","v3","v7","pow","vx2","root1","root2","useRoot1","useRoot2","noRoot","ed25519_Point","ed","ed25519","rotr","word","shift","utf8ToBytes","toBytes","Hash","setBigUint64","byteOffset","_u32_max","wh","wl","Chi","Maj","SHA256_IV","SHA256_K","SHA256_W","SHA256","W15","W2","s0","s1","sigma1","sha256","sha256n","BASE58_ALPHABET","deriveKeypairFromSeed","expandedSeed","wipeBytes","getPublicKeyFromSeed","keypair","publicKeyToBase58","base58Encode","zeros","remainder","SHAMIR_THRESHOLD","SHAMIR_TOTAL","splitSecret","seedHex","uint8ArrayToHex","shareA","hexShareToBytes","shareB","shareC","toShamirShare","combineShares","share1","share2","expectedPublicKey","hexShare1","bytesToHexShare","hexShare2","hexToUint8Array","toSeed","err","hexShare","isOdd","paddedHex","dataBytes","firstByte","wasOdd","candidateHex","resultHex"],"mappings":";AAsBA,IAAIA,IAAwB,MACxBC,KAAS;AACb,MAAMC,yBAAc,IAAA;AAEpB,SAASC,KAA2B;AAClC,SAAI,OAAO,SAAW,MACb,QAGJH,MACHA,IAAS,IAAI,OAAO,IAAA;AAAA;AAAA,IAAA,KAAA,IAAA,IAAA,mCAAA,YAAA,GAAA,EAAA;AAAA,IAAA,YAAA;AAAA,EAAA,GAA+C;AAAA,IACjE,MAAM;AAAA,EAAA,CACP,GAEDA,EAAO,YAAY,CAACI,MAAwC;AAC1D,UAAM,EAAE,IAAAC,GAAI,KAAAC,GAAK,OAAAC,EAAA,IAAUH,EAAM,MAC3BI,IAAWN,GAAQ,IAAIG,CAAE;AAC/B,QAAKG,GAGL;AAAA,UAFAN,GAAQ,OAAOG,CAAE,GAEbE,GAAO;AACT,QAAAC,EAAS,OAAO,IAAI,MAAMD,CAAK,CAAC;AAChC;AAAA,MACF;AAEA,UAAI,CAACD,GAAK;AACR,QAAAE,EAAS,OAAO,IAAI,MAAM,+BAA+B,CAAC;AAC1D;AAAA,MACF;AAEA,MAAAA,EAAS,QAAQF,CAAoB;AAAA;AAAA,EACvC,GAEAN,EAAO,UAAU,CAACI,MAAU;AAC1B,UAAMG,IAAQH,aAAiB,aAAaA,EAAM,QAAQ,IAAI,MAAM,qBAAqB;AACzF,eAAWI,KAAYN,GAAQ;AAC7B,MAAAM,EAAS,OAAOD,aAAiB,QAAQA,IAAQ,IAAI,MAAM,OAAOA,CAAK,CAAC,CAAC;AAE3E,IAAAL,GAAQ,MAAA,GACRF,GAAQ,UAAA,GACRA,IAAS;AAAA,EACX,IAGKA;AACT;AA4BA,eAAsBS,GACpBC,GACAC,GACAC,IAAoBC,IACI;AAGxB,EAAAC,GAAkBF,CAAM;AAExB,QAAMG,IAAcZ,GAAA;AACpB,SAAKY,IAIE,IAAI,QAAQ,CAACC,GAASC,MAAW;AACtC,UAAMZ,IAAKJ;AACX,IAAAC,GAAQ,IAAIG,GAAI,EAAE,SAAAW,GAAS,QAAAC,GAAQ;AAEnC,UAAMC,IAAyB;AAAA,MAC7B,IAAAb;AAAA,MACA,UAAAK;AAAA,MACA,MAAAC;AAAA,MACA,QAAAC;AAAA,IAAA;AAGF,IAAAG,EAAY,YAAYG,CAAO;AAAA,EACjC,CAAC,IAfQC,GAAaT,GAAUC,GAAMC,CAAM;AAgB9C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnHA,MAAAQ,KAAe,WAAW,QACbC,KAAY,WAAW,QACvBC,KAAS,WAAW,OAAO,QAC3BC,KAAkB,WAAW,OAAO,gBAAgB,KAAK,WAAW,MAAM,GAC1EC,KAAa,WAAW,OAAO,WAAW,KAAK,WAAW,MAAM;;;;;;;;;;;ACO5E,KAAC,SAASC,GAAMC,GAAS;AAclB,MAAAC,EAAA,UAAiBD,EAAQE,EAAiB;AAAA,IAKlD,GAAGC,IAAM,SAASC,GAAQ;AAGtB,UAAIC,GAAUC,GAAQC,GAAeC,GAAeC;AAEpD,eAASC,IAAQ;AACb,QAAAL,IAAW;AAAA,UACP,MAAM;AAAA;AAAA,UACN,OAAO;AAAA;AAAA,UACP,SAAS;AAAA,UACT,SAAS;AAAA;AAAA,UACT,cAAc;AAAA,UACd,iBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA,UAKjB,sBAAsB;AAAA,YAClB;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UAChB;AAAA,QACA,GACQC,IAAS,CAAA,GACTC,IAAgB,IAAI,MAAM,IAAI,EAAE,KAAK,GAAG,GACxCC,IAAgB,IAGhBC,IAAc;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,QACZ;AAAA,MACA;AAEI,eAASE,IAAW;AAChB,eAAI,GAAAL,KAAUA,EAAO,OAAO,OAAOA,EAAO,OAAQ;AAAA,MAK1D;AAGI,eAASM,EAAQC,GAAKC,GAAgB;AAClC,YAAIC;AAEJ,YAAID,MAAmB,KAAKA,MAAmB;AAC3C,iBAAOD;AAGX,YAAIC,KAAkBA,IAAiB;AACnC,gBAAM,IAAI;AAAA,YACN;AAAA,UAChB;AASQ,eANAA,IAAiBA,KAAkBR,EAAO,MAEtCO,MACAE,IAAUF,EAAI,SAASC,IAGvBC,KACQR,IAAgBM,GAAK;AAAA,UACzB,EAAEC,IAAiBC,IAAUF,EAAI;AAAA,QACjD,IAGeA;AAAA,MACf;AAEI,eAASG,EAAQH,GAAK;AAClB,YAAII,IAAM,IACNC,GACAC;AAEJ,aAAKA,IAAIN,EAAI,SAAS,GAAGM,KAAK,GAAGA,KAAK;AAGlC,cAFAD,IAAM,SAASL,EAAIM,CAAC,GAAG,EAAE,GAErB,MAAMD,CAAG;AACT,kBAAM,IAAI,MAAM,wBAAwB;AAG5C,UAAAD,IAAML,EAAQM,EAAI,SAAS,CAAC,GAAG,CAAC,IAAID;AAAA,QAChD;AACQ,eAAOA;AAAA,MACf;AAEI,eAASG,EAAQP,GAAK;AAClB,YAAIQ,IAAM,IACNH,GACAC;AAIJ,aAFAN,IAAMD,EAAQC,GAAK,CAAC,GAEfM,IAAIN,EAAI,QAAQM,KAAK,GAAGA,KAAK,GAAG;AAEjC,cADAD,IAAM,SAASL,EAAI,MAAMM,IAAI,GAAGA,CAAC,GAAG,CAAC,GACjC,MAAMD,CAAG;AACT,kBAAM,IAAI,MAAM,2BAA2B;AAE/C,UAAAG,IAAMH,EAAI,SAAS,EAAE,IAAIG;AAAA,QACrC;AAEQ,eAAOA;AAAA,MACf;AAGI,eAASC,IAA2B;AAChC,eACI,GAAAlB,KACA,OAAOA,KAAW,aACjB,OAAOA,EAAO,mBAAoB,cAC/B,OAAOA,EAAO,mBAAoB,cACrC,OAAO,eAAgB,cACpB,OAAO,eAAgB;AAAA,MAMvC;AAGI,eAASmB,IAAuB;AAC5B,eACI,OAAOnB,KAAW,YAClB,OAAOA,EAAO,eAAgB;AAAA,MAM1C;AASI,eAASoB,EAAOC,GAAM;AAClB,iBAASC,EAAUC,GAAMC,GAAKC,GAAOC,GAAM;AACvC,cAAIX,IAAI,GACJY,GACAlB,IAAM,IACNmB;AAMJ,eAJIJ,MACAG,IAAMH,EAAI,SAAS,IAGhBT,IAAIY,KAAOlB,EAAI,SAASc;AAE3B,YAAAK,IAAY,KAAK,IAAI,SAASJ,EAAIT,CAAC,GAAGU,CAAK,CAAC,GAC5ChB,IAAMA,IAAMD,EAAQoB,EAAU,SAAS,CAAC,GAAGF,CAAI,GAC/CX;AAMJ,iBAHAN,IAAMA,EAAI,OAAO,CAACc,CAAI,IAGjBd,EAAI,MAAM,IAAI,KAAK,CAAA,GAAI,WAAWA,EAAI,SAChC,OAGJA;AAAA,QACnB;AAOQ,iBAASoB,EAAsBN,GAAM;AACjC,cAAIO,GACAC,GACAN,GACAC,GACAjB,IAAM;AAMV,eAJAgB,IAAQ,IACRC,IAAO,GACPK,IAAQ,KAAK,KAAKR,IAAO,CAAC,GAEnBd,MAAQ;AACX,YAAAqB,IAAM9B,EAAO,YAAY+B,CAAK,GAC9BtB,IAAMa,EAAUC,GAAMO,EAAI,SAAS,KAAK,GAAGL,GAAOC,CAAI;AAG1D,iBAAOjB;AAAA,QACnB;AAMQ,iBAASuB,EAA6BT,GAAM;AACxC,cAAIU,GACAR,GACAC,GACAjB,IAAM;AAKV,eAHAgB,IAAQ,IACRC,IAAO,IACPO,IAAQ,KAAK,KAAKV,IAAO,EAAE,GACpBd,MAAQ;AACX,YAAAA,IAAMa;AAAA,cACFC;AAAA,cACAvB,EAAO,gBAAgB,IAAI,YAAYiC,CAAK,CAAC;AAAA,cAC7CR;AAAA,cACAC;AAAA,YACpB;AAGY,iBAAOjB;AAAA,QACnB;AAQQ,iBAASyB,EAAWX,GAAM;AACtB,cAAIC,GACAS,GACAE,GACAV,GACAC,GACAjB,IAAM;AAEV,UAAAgB,IAAQ,IACRC,IAAO,IACPO,IAAQ,KAAK,KAAKV,IAAO,EAAE,GAC3BY,IAAM,WACNX,IAAM,IAAI,YAAYS,CAAK;AAG3B,mBAASlB,IAAI,GAAGA,IAAIS,EAAI,QAAQT;AAC5B,YAAAS,EAAIT,CAAC,IAAIoB;AAGb,iBAAO1B,MAAQ;AACX,YAAAA,IAAMa,EAAUC,GAAMC,GAAKC,GAAOC,CAAI;AAG1C,iBAAOjB;AAAA,QACnB;AAKQ,YAAIY,KAAQA,MAAS;AACjB,iBAAAnB,EAAO,aAAamB,GACba;AACJ,YAAIb,KAAQA,MAAS;AACxB,iBAAAnB,EAAO,aAAamB,GACbQ;AACJ,YAAIR,KAAQA,MAAS;AACxB,iBAAAnB,EAAO,aAAamB,GACbW;AACJ,YAAIb;AACP,iBAAAjB,EAAO,aAAa,yBACb2B;AACJ,YAAIX;AACP,iBAAAhB,EAAO,aAAa,gCACb8B;AAAA,MAEnB;AAOI,eAASI,EAAyB3B,GAAK4B,GAAW;AAC9C,YAAIC,IAAQ,CAAA,GACRvB;AAMJ,aAJIsB,MACA5B,IAAMD,EAAQC,GAAK4B,CAAS,IAG3BtB,IAAIN,EAAI,QAAQM,IAAIb,EAAO,MAAMa,KAAKb,EAAO;AAC9C,UAAAoC,EAAM,KAAK,SAAS7B,EAAI,MAAMM,IAAIb,EAAO,MAAMa,CAAC,GAAG,CAAC,CAAC;AAGzD,eAAAuB,EAAM,KAAK,SAAS7B,EAAI,MAAM,GAAGM,CAAC,GAAG,CAAC,CAAC,GAEhCuB;AAAA,MACf;AAMI,eAASC,EAAOC,GAAGC,GAAQ;AACvB,YAAIC,IAAOxC,EAAO,KAAKsC,CAAC,GACpBG,IAAK,GACL5B;AAEJ,aAAKA,IAAI0B,EAAO,SAAS,GAAG1B,KAAK,GAAGA;AAChC,UAAI4B,MAAO,IACPA,IACIzC,EAAO,MAAMwC,IAAOxC,EAAO,KAAKyC,CAAE,KAAKzC,EAAO,SAAS,IACvDuC,EAAO1B,CAAC,IAEZ4B,IAAKF,EAAO1B,CAAC;AAIrB,eAAO4B;AAAA,MACf;AAKI,eAASC,EAASC,GAAIL,GAAGM,GAAG;AACxB,YAAIC,IAAM,GACNpB,GACAqB,GACAjC,GACAkC;AAEJ,aAAKlC,IAAI,GAAGY,IAAMa,EAAE,QAAQzB,IAAIY,GAAKZ;AACjC,cAAI+B,EAAE/B,CAAC,GAAG;AAGN,iBAFAiC,IAAU9C,EAAO,KAAK4C,EAAE/B,CAAC,CAAC,GAErBkC,IAAI,GAAGA,IAAItB,GAAKsB;AACjB,kBAAIlC,MAAMkC,GAAG;AACT,oBAAIJ,MAAOL,EAAES,CAAC,GAAG;AAEb,kBAAAD,IAAU;AACV;AAAA,gBAC5B;AACwB,gBAAAA,KACKA,IACG9C,EAAO,KAAK2C,IAAKL,EAAES,CAAC,CAAC,IACrB/C,EAAO,KAAKsC,EAAEzB,CAAC,IAAIyB,EAAES,CAAC,CAAC,IACvB/C,EAAO,aACXA,EAAO;AAAA,cACnC;AAKgB,YAAA6C,IAAMC,MAAY,KAAKD,IAAMA,IAAM7C,EAAO,KAAK8C,CAAO;AAAA,UACtE;AAGQ,eAAOD;AAAA,MACf;AAMI,eAASG,EAAUC,GAAQC,GAAWC,GAAW;AAC7C,YAAIC,IAAS,CAAA,GACTb,IAAS,CAACU,CAAM,GAChBpC,GACAY;AAEJ,aAAKZ,IAAI,GAAGA,IAAIsC,GAAWtC;AACvB,UAAA0B,EAAO1B,CAAC,IAAI,SAASb,EAAO,IAAIA,EAAO,IAAI,GAAG,CAAC;AAGnD,aAAKa,IAAI,GAAGY,IAAMyB,IAAY,GAAGrC,IAAIY,GAAKZ;AACtC,UAAAuC,EAAOvC,IAAI,CAAC,IAAI;AAAA,YACZ,GAAGA;AAAA,YACH,GAAGwB,EAAOxB,GAAG0B,CAAM;AAAA,UACnC;AAGQ,eAAOa;AAAA,MACf;AAEI,eAASC,EAA2BhC,GAAMhD,GAAIiF,GAAM;AAChD,YAAIC,GAAYC,GAAOC,GAAOC,GAAcC;AAS5C,YAPAtF,IAAK,SAASA,GAAI2B,EAAO,KAAK,GAC9BqB,IAAO,SAASA,GAAM,EAAE,KAAKrB,EAAO,MACpCuD,IAAalC,EAAK,SAAS,EAAE,EAAE,YAAW,GAC1CoC,IAAQ,KAAK,IAAI,GAAGpC,CAAI,IAAI,GAC5BqC,IAAeD,EAAM,SAASzD,EAAO,KAAK,EAAE,QAC5CwD,IAAQlD,EAAQjC,EAAG,SAAS2B,EAAO,KAAK,GAAG0D,CAAY,GAEnD,OAAOrF,KAAO,YAAYA,IAAK,MAAM,KAAKA,IAAK,KAAKA,IAAKoF;AACzD,gBAAM,IAAI;AAAA,YACN,+CACIA,IACA;AAAA,UACpB;AAGQ,eAAAE,IAAiBJ,IAAaC,IAAQF,GAE/BK;AAAA,MACf;AAKI,UAAIC,IAAU;AAAA,QACV,MAAM,SAASvC,GAAMwC,GAAS;AAC1B,cAAIC,IAAO,CAAA,GACPC,IAAO,CAAA,GACPzB,IAAI,GACJ0B,GACAnD;AAKJ,cAFAT,EAAK,GAGDiB,MACC,OAAOA,KAAS,YACbA,IAAO,MAAM,KACbA,IAAOtB,EAAS,WAChBsB,IAAOtB,EAAS;AAEpB,kBAAM,IAAI;AAAA,cACN,+CACIA,EAAS,UACT,UACAA,EAAS,UACT;AAAA,YACxB;AAGY,cAAI8D,KAAW1D,EAAY,QAAQ0D,CAAO,MAAM;AAC5C,kBAAM,IAAI,MAAM,kCAAkCA,IAAU,GAAG;AAWnE,eARA7D,EAAO,QAAQD,EAAS,OACxBC,EAAO,OAAOqB,KAAQtB,EAAS,MAC/BC,EAAO,OAAO,KAAK,IAAI,GAAGA,EAAO,IAAI,GACrCA,EAAO,YAAYA,EAAO,OAAO,GAGjCgE,IAAYjE,EAAS,qBAAqBC,EAAO,IAAI,GAEhDa,IAAI,GAAGA,IAAIb,EAAO,MAAMa;AACzB,YAAAkD,EAAKlD,CAAC,IAAIyB,GACVwB,EAAKxB,CAAC,IAAIzB,GACVyB,IAAIA,KAAK,GACLA,KAAKtC,EAAO,SACZsC,IAAIA,IAAI0B,GACR1B,IAAIA,IAAItC,EAAO;AAevB,cAXAA,EAAO,OAAO8D,GACd9D,EAAO,OAAO+D,GAEVF,KACA,KAAK,OAAOA,CAAO,GAGlBxD,EAAQ,KACT,KAAK,OAAM,GAIX,CAACA,EAAQ,KACT,CAACL,EAAO,QACR,CAACA,EAAO,QACR,CAACA,EAAO,aACR,CAACA,EAAO,QACR,CAACA,EAAO,QACRA,EAAO,KAAK,WAAWA,EAAO,QAC9BA,EAAO,KAAK,WAAWA,EAAO;AAE9B,kBAAM,IAAI,MAAM,wBAAwB;AAAA,QAExD;AAAA;AAAA;AAAA;AAAA;AAAA,QAMQ,SAAS,SAASoD,GAAQT,GAAI;AAC1B,cAAI9B,GACAkC,GACAtB,GACAwC,GACAC,IAAS,IACTC,GACAC,GACAC,GACA/B,IAAI,CAAA,GACJM,IAAI,CAAA;AAIR,eAFAD,IAAKA,KAAM,GAEN9B,IAAI,GAAGY,IAAM2B,EAAO,QAAQvC,IAAIY,GAAKZ,KAAK;AAI3C,gBAHAuD,IAAQ,KAAK,uBAAuBhB,EAAOvC,CAAC,CAAC,GAGzCsD,MAAY;AACZ,cAAAA,IAAUC,EAAM;AAAA,qBACTA,EAAM,SAASD;AACtB,oBAAM,IAAI;AAAA,gBACN;AAAA,cACxB;AAsCgB,gBAlCInE,EAAO,SAASmE,KAChB,KAAK,KAAKA,CAAO,GAiCjB7B,EAAE,QAAQ8B,EAAM,EAAE,MAAM;AAGxB,mBAFA9B,EAAE,KAAK8B,EAAM,EAAE,GACfC,IAAanC,EAAyBxB,EAAQ0D,EAAM,IAAI,CAAC,GACpDrB,IAAI,GAAGkB,IAAOI,EAAW,QAAQtB,IAAIkB,GAAMlB;AAC5C,gBAAAH,EAAEG,CAAC,IAAIH,EAAEG,CAAC,KAAK,CAAA,GACfH,EAAEG,CAAC,EAAET,EAAE,SAAS,CAAC,IAAI+B,EAAWtB,CAAC;AAAA,UAGzD;AAMY,eAAKlC,IAAI,GAAGY,IAAMmB,EAAE,QAAQ/B,IAAIY,GAAKZ;AACjC,YAAAqD,IAAS5D,EAAQoC,EAASC,GAAIL,GAAGM,EAAE/B,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,IAAIqD;AAU1D,iBAAOpD;AAAA,YACH6B,KAAM,IAAIuB,IAASA,EAAO,MAAMA,EAAO,QAAQ,GAAG,IAAI,CAAC;AAAA,UACvE;AAAA,QACA;AAAA,QAEQ,WAAW,WAAW;AAClB,cAAII,IAAM,CAAA;AACV,iBAAAA,EAAI,QAAQtE,EAAO,OACnBsE,EAAI,OAAOtE,EAAO,MAClBsE,EAAI,YAAYtE,EAAO,WACvBsE,EAAI,YAAYjE,EAAQ,GACxBiE,EAAI,aAAatE,EAAO,YACjBsE;AAAA,QACnB;AAAA;AAAA;AAAA,QAIQ,wBAAwB,SAASF,GAAO;AACpC,cAAI/C,GACAhD,GACAkG,GACAC,GACAF,IAAM,CAAA,GACNG,GACAC;AAKJ,cAFArD,IAAO,SAAS+C,EAAM,OAAO,GAAG,CAAC,GAAG,EAAE,GAGlC/C,MACC,OAAOA,KAAS,YACbA,IAAO,MAAM,KACbA,IAAOtB,EAAS,WAChBsB,IAAOtB,EAAS;AAEpB,kBAAM,IAAI;AAAA,cACN,+DACIA,EAAS,UACT,UACAA,EAAS,UACT;AAAA,YACxB;AAmBY,cAfAyE,IAAM,KAAK,IAAI,GAAGnD,CAAI,IAAI,GAG1BkD,KAAS,KAAK,IAAI,GAAGlD,CAAI,IAAI,GAAG,SAASrB,EAAO,KAAK,EAAE,QAGvDyE,IACI,mCAAmCF,IAAQ,qBAC/CG,IAAkB,IAAI,OAAOD,CAAQ,EAAE,KAAKL,CAAK,GAG7CM,MACArG,IAAK,SAASqG,EAAgB,CAAC,GAAG1E,EAAO,KAAK,IAG9C,OAAO3B,KAAO,YAAYA,IAAK,MAAM,KAAKA,IAAK,KAAKA,IAAKmG;AACzD,kBAAM,IAAI;AAAA,cACN,+DACIxE,EAAO,YACP;AAAA,YACxB;AAGY,cAAI0E,KAAmBA,EAAgB,CAAC;AACpC,mBAAAJ,EAAI,OAAOjD,GACXiD,EAAI,KAAKjG,GACTiG,EAAI,OAAOI,EAAgB,CAAC,GACrBJ;AAGX,gBAAM,IAAI,MAAM,0CAA0CF,CAAK;AAAA,QAC3E;AAAA;AAAA,QAGQ,QAAQ,SAASO,GAAK;AAClB,cAAIC,IAAY,uCACZC,IACI;AAER,cACIF,KACA,OAAOA,KAAQ,YACfxE,EAAY,QAAQwE,CAAG,MAAM;AAE7B,kBAAM,IAAI,MAAM,kCAAkCA,IAAM,GAAG;AAe/D,cAVKA,MACDA,IAAMzD,EAAM,IAKZyD,KAAO,OAAOA,KAAQ,aACtBA,IAAMzD,EAAOyD,CAAG,IAGhBzE,GAAe;AACf,gBAAIyE,KAAO,OAAOA,KAAQ;AACtB,oBAAM,IAAI,MAAMC,IAAY,sBAAsBC,CAAS;AAG/D,gBAAIF,KAAO,OAAOA,EAAI3E,EAAO,IAAI,KAAM;AACnC,oBAAM,IAAI;AAAA,gBACN4E,IAAY,8BAA8BC;AAAA,cAClE;AAGgB,gBAAIF,KAAO,CAAC,SAASA,EAAI3E,EAAO,IAAI,GAAG,CAAC;AACpC,oBAAM,IAAI;AAAA,gBACN4E,IACI,wDACAC;AAAA,cAC5B;AAGgB,gBAAIF,KAAOA,EAAI3E,EAAO,IAAI,EAAE,SAASA,EAAO;AACxC,oBAAM,IAAI;AAAA,gBACN4E,IACI,iDACAC;AAAA,cAC5B;AAGgB,gBAAIF,KAAOA,EAAI3E,EAAO,IAAI,EAAE,SAASA,EAAO;AACxC,oBAAM,IAAI;AAAA,gBACN4E,IACI,8CACAC;AAAA,cAC5B;AAAA,UAEA;AAEY,iBAAA7E,EAAO,MAAM2E,GAEN;AAAA,QACnB;AAAA;AAAA;AAAA;AAAA,QAKQ,SAAS,SAASpE,GAAKuE,GAAc;AACjC,cAAIC,GACAP,GACAQ,IAAM,IACNC,GACArE,GACAC,GACAY;AAEJ,cAAI,OAAOlB,KAAQ;AACf,kBAAM,IAAI,MAAM,mCAAmC;AAOvD,cAJKuE,MACDA,IAAe/E,EAAS,eAIxB,OAAO+E,KAAiB,YACxBA,IAAe,KACfA,IAAe/E,EAAS,mBACxB+E,IAAe,MAAM;AAErB,kBAAM,IAAI;AAAA,cACN,0DACI/E,EAAS,kBACT;AAAA,YACxB;AAMY,eAHAgF,IAAW,IAAID,GACfN,IAAM,KAAK,IAAI,IAAIO,CAAQ,IAAI,GAE1BlE,IAAI,GAAGY,IAAMlB,EAAI,QAAQM,IAAIY,GAAKZ,KAAK;AAGxC,gBAFAD,IAAML,EAAIM,CAAC,EAAE,WAAU,GAEnB,MAAMD,CAAG;AACT,oBAAM,IAAI,MAAM,wBAAwBL,EAAIM,CAAC,CAAC;AAGlD,gBAAID,IAAM4D;AACN,oBAAAS,IAAc,KAAK,KAAK,KAAK,IAAIrE,IAAM,CAAC,IAAI,KAAK,IAAI,GAAG,CAAC,GACnD,IAAI;AAAA,gBACN,6BACIA,IACA,0CACA4D,IACA,gDACAS,IACA;AAAA,cAC5B;AAGgB,YAAAD,IAAM1E,EAAQM,EAAI,SAAS,EAAE,GAAGmE,CAAQ,IAAIC;AAAA,UAC5D;AACY,iBAAOA;AAAA,QACnB;AAAA;AAAA,QAGQ,SAAS,SAASzE,GAAKuE,GAAc;AACjC,cAAIC,GACAC,IAAM,IACNnE,GACAY;AAEJ,cAAI,OAAOlB,KAAQ;AACf,kBAAM,IAAI,MAAM,qCAAqC;AAIzD,cAFAuE,IAAeA,KAAgB/E,EAAS,cAGpC,OAAO+E,KAAiB,YACxBA,IAAe,MAAM,KACrBA,IAAe,KACfA,IAAe/E,EAAS;AAExB,kBAAM,IAAI;AAAA,cACN,0DACIA,EAAS,kBACT;AAAA,YACxB;AAOY,eAJAgF,IAAW,IAAID,GAEfvE,IAAMD,EAAQC,GAAKwE,CAAQ,GAEtBlE,IAAI,GAAGY,IAAMlB,EAAI,QAAQM,IAAIY,GAAKZ,KAAKkE;AACxC,YAAAC,IACI,OAAO;AAAA,cACH,SAASzE,EAAI,MAAMM,GAAGA,IAAIkE,CAAQ,GAAG,EAAE;AAAA,YAC/D,IAAwBC;AAGZ,iBAAOA;AAAA,QACnB;AAAA;AAAA,QAGQ,QAAQ,SAAS3D,GAAM;AACnB,cACI,OAAOA,KAAS,YAChBA,IAAO,MAAM,KACbA,IAAO,KACPA,IAAO;AAEP,kBAAM,IAAI;AAAA,cACN;AAAA,YACpB;AAGY,iBAAOP,EAAQd,EAAO,IAAIqB,CAAI,CAAC;AAAA,QAC3C;AAAA;AAAA;AAAA;AAAA;AAAA,QAMQ,OAAO,SAAS4B,GAAQC,GAAWC,GAAWhB,GAAW;AACrD,cAAI+C,GACAC,GACA7C,IAAI,IAAI,MAAMY,CAAS,GACvB,IAAI,IAAI,MAAMA,CAAS,GACvBrC,GACAkC,GACAtB;AAQJ,cAFAU,IAAYA,KAAa,KAErB,OAAOc,KAAW;AAClB,kBAAM,IAAI,MAAM,0BAA0B;AAG9C,cACI,OAAOC,KAAc,YACrBA,IAAY,MAAM,KAClBA,IAAY;AAEZ,kBAAM,IAAI;AAAA,cACN,iEACIlD,EAAO,YACP;AAAA,YACxB;AAGY,cAAIkD,IAAYlD,EAAO;AACnB,kBAAAkF,IAAa,KAAK,KAAK,KAAK,IAAIhC,IAAY,CAAC,IAAI,KAAK,GAAG,GACnD,IAAI;AAAA,cACN,iEACIlD,EAAO,YACP,6BACAkD,IACA,2BACAgC,IACA;AAAA,YACxB;AAGY,cACI,OAAO/B,KAAc,YACrBA,IAAY,MAAM,KAClBA,IAAY;AAEZ,kBAAM,IAAI;AAAA,cACN,2EACInD,EAAO,YACP;AAAA,YACxB;AAGY,cAAImD,IAAYnD,EAAO;AACnB,kBAAAkF,IAAa,KAAK,KAAK,KAAK,IAAI/B,IAAY,CAAC,IAAI,KAAK,GAAG,GACnD,IAAI;AAAA,cACN,2EACInD,EAAO,YACP,0CACAmD,IACA,oBACA+B,IACA;AAAA,YACxB;AAGY,cAAI/B,IAAYD;AACZ,kBAAM,IAAI;AAAA,cACN,oCACIC,IACA,4CACAD,IACA;AAAA,YACxB;AAGY,cACI,OAAOf,KAAc,YACrBA,IAAY,MAAM,KAClBA,IAAY,KACZA,IAAY;AAEZ,kBAAM,IAAI;AAAA,cACN;AAAA,YACpB;AAMY,eAHAc,IAAS,MAAMvC,EAAQuC,CAAM,GAC7BA,IAASf,EAAyBe,GAAQd,CAAS,GAE9CtB,IAAI,GAAGY,IAAMwB,EAAO,QAAQpC,IAAIY,GAAKZ;AAEtC,iBADAsE,IAAYnC,EAAUC,EAAOpC,CAAC,GAAGqC,GAAWC,CAAS,GAChDJ,IAAI,GAAGA,IAAIG,GAAWH;AACvB,cAAAT,EAAES,CAAC,IAAIT,EAAES,CAAC,KAAKoC,EAAUpC,CAAC,EAAE,EAAE,SAAS/C,EAAO,KAAK,GACnD,EAAE+C,CAAC,IAAIzC,EAAQ6E,EAAUpC,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC,KAAK,EAAEA,CAAC,KAAK;AAI9D,eAAKlC,IAAI,GAAGA,IAAIqC,GAAWrC;AACvB,YAAAyB,EAAEzB,CAAC,IAAIwC;AAAA,cACHrD,EAAO;AAAA,cACPsC,EAAEzB,CAAC;AAAA,cACHC,EAAQ,EAAED,CAAC,CAAC;AAAA,YAChC;AAGY,iBAAOyB;AAAA,QACnB;AAAA;AAAA;AAAA,QAIQ,UAAU,SAASjE,GAAI+E,GAAQ;AAC3B,cAAIgB,GAAOgB;AAQX,cANI/G,KAAM,OAAOA,KAAO,aACpBA,IAAK,SAASA,GAAI2B,EAAO,KAAK,IAGlCoF,IAAQ/G,EAAG,SAAS2B,EAAO,KAAK,GAE5B3B,KAAM+G,KAAShC,KAAUA,EAAO,CAAC;AACjC,mBAAAgB,IAAQ,KAAK,uBAAuBhB,EAAO,CAAC,CAAC,GACtCC;AAAA,cACHe,EAAM;AAAA,cACNgB;AAAA,cACA,KAAK,QAAQhC,GAAQ/E,CAAE;AAAA,YAC3C;AAGY,gBAAM,IAAI;AAAA,YACN;AAAA,UAChB;AAAA,QACA;AAAA;AAAA;AAAA,QAIQ,QAAQ+B;AAAA,QACR,UAAUE;AAAA,QACV,UAAUI;AAAA,QACV,UAAUI;AAAA,QACV,2BAA2BE;AAAA,QAC3B,uBAAuBC;AAAA,QACvB,SAASC;AAAA,QACT,WAAWb;AAAA,QACX,2BAA2B6B;AAAA,QAC3B,SAASG;AAAA,QACT,WAAWK;AAAA,QACX,YAAYM;AAAA,QACZ,6BAA6BK;AAAA;AAAA,MAErC;AAGI,aAAAO,EAAQ,KAAI,GAELA;AAAA,IACX,CAAC;AAAA;;;;AC7hCM,SAASyB,GAAQC,GAAG;AACvB,SAAOA,aAAa,cAAe,YAAY,OAAOA,CAAC,KAAKA,EAAE,YAAY,SAAS;AACvF;AAEO,SAASC,GAAQC,GAAGC,IAAQ,IAAI;AACnC,MAAI,CAAC,OAAO,cAAcD,CAAC,KAAKA,IAAI,GAAG;AACnC,UAAME,IAASD,KAAS,IAAIA,CAAK;AACjC,UAAM,IAAI,MAAM,GAAGC,CAAM,8BAA8BF,CAAC,EAAE;AAAA,EAC9D;AACJ;AAEO,SAASG,EAAOC,GAAOC,GAAQJ,IAAQ,IAAI;AAC9C,QAAM5D,IAAQwD,GAAQO,CAAK,GACrBnE,IAAMmE,GAAO,QACbE,IAAWD,MAAW;AAC5B,MAAI,CAAChE,KAAUiE,KAAYrE,MAAQoE,GAAS;AACxC,UAAMH,IAASD,KAAS,IAAIA,CAAK,MAC3BM,IAAQD,IAAW,cAAcD,CAAM,KAAK,IAC5CG,IAAMnE,IAAQ,UAAUJ,CAAG,KAAK,QAAQ,OAAOmE,CAAK;AAC1D,UAAM,IAAI,MAAMF,IAAS,wBAAwBK,IAAQ,WAAWC,CAAG;AAAA,EAC3E;AACA,SAAOJ;AACX;AASO,SAASK,GAAQC,GAAUC,IAAgB,IAAM;AACpD,MAAID,EAAS;AACT,UAAM,IAAI,MAAM,kCAAkC;AACtD,MAAIC,KAAiBD,EAAS;AAC1B,UAAM,IAAI,MAAM,uCAAuC;AAC/D;AAEO,SAASE,GAAQpB,GAAKkB,GAAU;AACnCP,EAAAA,EAAOX,GAAK,QAAW,qBAAqB;AAC5C,QAAMqB,IAAMH,EAAS;AACrB,MAAIlB,EAAI,SAASqB;AACb,UAAM,IAAI,MAAM,sDAAsDA,CAAG;AAEjF;AAUO,SAASC,MAASC,GAAQ;AAC7B,WAAS1F,IAAI,GAAGA,IAAI0F,EAAO,QAAQ1F;AAC/B,IAAA0F,EAAO1F,CAAC,EAAE,KAAK,CAAC;AAExB;AAEO,SAAS2F,GAAWlF,GAAK;AAC5B,SAAO,IAAI,SAASA,EAAI,QAAQA,EAAI,YAAYA,EAAI,UAAU;AAClE;AAiCA,MAAMmF,sBAEN,OAAO,WAAW,KAAK,CAAA,CAAE,EAAE,SAAU,cAAc,OAAO,WAAW,WAAY,YAE3EC,KAAwB,sBAAM,KAAK,EAAE,QAAQ,IAAG,GAAI,CAACC,GAAG9F,MAAMA,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC;AAK5F,SAAS+F,GAAW/E,GAAO;AAG9B,MAFA8D,EAAO9D,CAAK,GAER4E;AACA,WAAO5E,EAAM,MAAK;AAEtB,MAAId,IAAM;AACV,WAASF,IAAI,GAAGA,IAAIgB,EAAM,QAAQhB;AAC9B,IAAAE,KAAO2F,GAAM7E,EAAMhB,CAAC,CAAC;AAEzB,SAAOE;AACX;AAEA,MAAM8F,IAAS,EAAE,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAG;AAC5D,SAASC,GAAcC,GAAI;AACvB,MAAIA,KAAMF,EAAO,MAAME,KAAMF,EAAO;AAChC,WAAOE,IAAKF,EAAO;AACvB,MAAIE,KAAMF,EAAO,KAAKE,KAAMF,EAAO;AAC/B,WAAOE,KAAMF,EAAO,IAAI;AAC5B,MAAIE,KAAMF,EAAO,KAAKE,KAAMF,EAAO;AAC/B,WAAOE,KAAMF,EAAO,IAAI;AAEhC;AAKO,SAASG,GAAWjG,GAAK;AAC5B,MAAI,OAAOA,KAAQ;AACf,UAAM,IAAI,MAAM,8BAA8B,OAAOA,CAAG;AAE5D,MAAI0F;AACA,WAAO,WAAW,QAAQ1F,CAAG;AACjC,QAAMkG,IAAKlG,EAAI,QACTmG,IAAKD,IAAK;AAChB,MAAIA,IAAK;AACL,UAAM,IAAI,MAAM,qDAAqDA,CAAE;AAC3E,QAAME,IAAQ,IAAI,WAAWD,CAAE;AAC/B,WAASE,IAAK,GAAGC,IAAK,GAAGD,IAAKF,GAAIE,KAAMC,KAAM,GAAG;AAC7C,UAAMC,IAAKR,GAAc/F,EAAI,WAAWsG,CAAE,CAAC,GACrCE,IAAKT,GAAc/F,EAAI,WAAWsG,IAAK,CAAC,CAAC;AAC/C,QAAIC,MAAO,UAAaC,MAAO,QAAW;AACtC,YAAMC,IAAOzG,EAAIsG,CAAE,IAAItG,EAAIsG,IAAK,CAAC;AACjC,YAAM,IAAI,MAAM,iDAAiDG,IAAO,gBAAgBH,CAAE;AAAA,IAC9F;AACA,IAAAF,EAAMC,CAAE,IAAIE,IAAK,KAAKC;AAAA,EAC1B;AACA,SAAOJ;AACX;AAwCO,SAASM,MAAelB,GAAQ;AACnC,MAAI1D,IAAM;AACV,WAAShC,IAAI,GAAGA,IAAI0F,EAAO,QAAQ1F,KAAK;AACpC,UAAMyE,IAAIiB,EAAO1F,CAAC;AAClB8E,IAAAA,EAAOL,CAAC,GACRzC,KAAOyC,EAAE;AAAA,EACb;AACA,QAAMoC,IAAM,IAAI,WAAW7E,CAAG;AAC9B,WAAShC,IAAI,GAAG8G,IAAM,GAAG9G,IAAI0F,EAAO,QAAQ1F,KAAK;AAC7C,UAAMyE,IAAIiB,EAAO1F,CAAC;AAClB,IAAA6G,EAAI,IAAIpC,GAAGqC,CAAG,GACdA,KAAOrC,EAAE;AAAA,EACb;AACA,SAAOoC;AACX;AASO,SAASE,GAAaC,GAAUC,IAAO,IAAI;AAC9C,QAAMC,IAAQ,CAACC,GAAKC,MAASJ,EAASI,CAAI,EAAE,OAAOD,CAAG,EAAE,OAAM,GACxDE,IAAML,EAAS,MAAS;AAC9B,SAAAE,EAAM,YAAYG,EAAI,WACtBH,EAAM,WAAWG,EAAI,UACrBH,EAAM,SAAS,CAACE,MAASJ,EAASI,CAAI,GACtC,OAAO,OAAOF,GAAOD,CAAI,GAClB,OAAO,OAAOC,CAAK;AAC9B;AAEO,SAASI,GAAYC,IAAc,IAAI;AAC1C,QAAMC,IAAK,OAAO,cAAe,WAAW,WAAW,SAAS;AAChE,MAAI,OAAOA,GAAI,mBAAoB;AAC/B,UAAM,IAAI,MAAM,wCAAwC;AAC5D,SAAOA,EAAG,gBAAgB,IAAI,WAAWD,CAAW,CAAC;AACzD;AAEO,MAAME,KAAU,CAACC,OAAY;AAAA,EAChC,KAAK,WAAW,KAAK,CAAC,GAAM,GAAM,IAAM,KAAM,IAAM,GAAM,KAAM,GAAM,GAAM,GAAMA,CAAM,CAAC;AAC7F;AC/NO,IAAAC,KAAA,MAAa;AAAA,EAChB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA,WAAW;AAAA,EACX,SAAS;AAAA,EACT,MAAM;AAAA,EACN,YAAY;AAAA,EACZ,YAAYC,GAAUC,GAAWC,GAAWC,GAAM;AAC9C,SAAK,WAAWH,GAChB,KAAK,YAAYC,GACjB,KAAK,YAAYC,GACjB,KAAK,OAAOC,GACZ,KAAK,SAAS,IAAI,WAAWH,CAAQ,GACrC,KAAK,OAAOjC,GAAW,KAAK,MAAM;AAAA,EACtC;AAAA,EACA,OAAOlD,GAAM;AACT2C,IAAAA,GAAQ,IAAI,GACZN,EAAOrC,CAAI;AACX,UAAM,EAAE,MAAAuF,GAAM,QAAAC,GAAQ,UAAAL,EAAQ,IAAK,MAC7BhH,IAAM6B,EAAK;AACjB,aAASyF,IAAM,GAAGA,IAAMtH,KAAM;AAC1B,YAAMuH,IAAO,KAAK,IAAIP,IAAW,KAAK,KAAKhH,IAAMsH,CAAG;AAEpD,UAAIC,MAASP,GAAU;AACnB,cAAMQ,IAAWzC,GAAWlD,CAAI;AAChC,eAAOmF,KAAYhH,IAAMsH,GAAKA,KAAON;AACjC,eAAK,QAAQQ,GAAUF,CAAG;AAC9B;AAAA,MACJ;AACA,MAAAD,EAAO,IAAIxF,EAAK,SAASyF,GAAKA,IAAMC,CAAI,GAAG,KAAK,GAAG,GACnD,KAAK,OAAOA,GACZD,KAAOC,GACH,KAAK,QAAQP,MACb,KAAK,QAAQI,GAAM,CAAC,GACpB,KAAK,MAAM;AAAA,IAEnB;AACA,gBAAK,UAAUvF,EAAK,QACpB,KAAK,WAAU,GACR;AAAA,EACX;AAAA,EACA,WAAW0B,GAAK;AACZiB,IAAAA,GAAQ,IAAI,GACZG,GAAQpB,GAAK,IAAI,GACjB,KAAK,WAAW;AAIhB,UAAM,EAAE,QAAA8D,GAAQ,MAAAD,GAAM,UAAAJ,GAAU,MAAAG,EAAI,IAAK;AACzC,QAAI,EAAE,KAAAG,EAAG,IAAK;AAEd,IAAAD,EAAOC,GAAK,IAAI,KAChBzC,GAAM,KAAK,OAAO,SAASyC,CAAG,CAAC,GAG3B,KAAK,YAAYN,IAAWM,MAC5B,KAAK,QAAQF,GAAM,CAAC,GACpBE,IAAM;AAGV,aAASlI,IAAIkI,GAAKlI,IAAI4H,GAAU5H;AAC5B,MAAAiI,EAAOjI,CAAC,IAAI;AAIhB,IAAAgI,EAAK,aAAaJ,IAAW,GAAG,OAAO,KAAK,SAAS,CAAC,GAAGG,CAAI,GAC7D,KAAK,QAAQC,GAAM,CAAC;AACpB,UAAMK,IAAQ1C,GAAWxB,CAAG,GACtBvD,IAAM,KAAK;AAEjB,QAAIA,IAAM;AACN,YAAM,IAAI,MAAM,2CAA2C;AAC/D,UAAM0H,IAAS1H,IAAM,GACf2H,IAAQ,KAAK,IAAG;AACtB,QAAID,IAASC,EAAM;AACf,YAAM,IAAI,MAAM,oCAAoC;AACxD,aAASvI,IAAI,GAAGA,IAAIsI,GAAQtI;AACxB,MAAAqI,EAAM,UAAU,IAAIrI,GAAGuI,EAAMvI,CAAC,GAAG+H,CAAI;AAAA,EAC7C;AAAA,EACA,SAAS;AACL,UAAM,EAAE,QAAAE,GAAQ,WAAAJ,EAAS,IAAK;AAC9B,SAAK,WAAWI,CAAM;AACtB,UAAMpB,IAAMoB,EAAO,MAAM,GAAGJ,CAAS;AACrC,gBAAK,QAAO,GACLhB;AAAA,EACX;AAAA,EACA,WAAW2B,GAAI;AACX,IAAAA,MAAO,IAAI,KAAK,YAAW,GAC3BA,EAAG,IAAI,GAAG,KAAK,IAAG,CAAE;AACpB,UAAM,EAAE,UAAAZ,GAAU,QAAAK,GAAQ,QAAAjD,GAAQ,UAAAyD,GAAU,WAAAC,GAAW,KAAAR,EAAG,IAAK;AAC/D,WAAAM,EAAG,YAAYE,GACfF,EAAG,WAAWC,GACdD,EAAG,SAASxD,GACZwD,EAAG,MAAMN,GACLlD,IAAS4C,KACTY,EAAG,OAAO,IAAIP,CAAM,GACjBO;AAAA,EACX;AAAA,EACA,QAAQ;AACJ,WAAO,KAAK,WAAU;AAAA,EAC1B;AACJ;AAmBO,MAAMG,IAA4B,4BAAY,KAAK;AAAA,EACtD;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EACpF;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AACxF,CAAC,GC5IKC,KAA6B,uBAAO,KAAK,KAAK,CAAC,GAC/CC,KAAuB,uBAAO,EAAE;AACtC,SAASC,GAAQnE,GAAGoE,IAAK,IAAO;AAC5B,SAAIA,IACO,EAAE,GAAG,OAAOpE,IAAIiE,EAAU,GAAG,GAAG,OAAQjE,KAAKkE,KAAQD,EAAU,EAAC,IACpE,EAAE,GAAG,OAAQjE,KAAKkE,KAAQD,EAAU,IAAI,GAAG,GAAG,OAAOjE,IAAIiE,EAAU,IAAI,EAAC;AACnF;AACA,SAASI,GAAMC,GAAKF,IAAK,IAAO;AAC5B,QAAMnI,IAAMqI,EAAI;AAChB,MAAIC,IAAK,IAAI,YAAYtI,CAAG,GACxBuI,IAAK,IAAI,YAAYvI,CAAG;AAC5B,WAASZ,IAAI,GAAGA,IAAIY,GAAKZ,KAAK;AAC1B,UAAM,EAAE,GAAAoJ,GAAG,GAAAC,EAAC,IAAKP,GAAQG,EAAIjJ,CAAC,GAAG+I,CAAE;AACnC,KAACG,EAAGlJ,CAAC,GAAGmJ,EAAGnJ,CAAC,CAAC,IAAI,CAACoJ,GAAGC,CAAC;AAAA,EAC1B;AACA,SAAO,CAACH,GAAIC,CAAE;AAClB;AAGA,MAAMG,KAAQ,CAACF,GAAGG,GAAIC,MAAMJ,MAAMI,GAC5BC,KAAQ,CAACL,GAAGC,GAAGG,MAAOJ,KAAM,KAAKI,IAAOH,MAAMG,GAE9CE,IAAS,CAACN,GAAGC,GAAGG,MAAOJ,MAAMI,IAAMH,KAAM,KAAKG,GAC9CG,KAAS,CAACP,GAAGC,GAAGG,MAAOJ,KAAM,KAAKI,IAAOH,MAAMG,GAE/CI,KAAS,CAACR,GAAGC,GAAGG,MAAOJ,KAAM,KAAKI,IAAOH,MAAOG,IAAI,IACpDK,KAAS,CAACT,GAAGC,GAAGG,MAAOJ,MAAOI,IAAI,KAAQH,KAAM,KAAKG;AAY3D,SAASM,EAAIZ,GAAIC,GAAIY,GAAIC,GAAI;AACzB,QAAMX,KAAKF,MAAO,MAAMa,MAAO;AAC/B,SAAO,EAAE,GAAId,IAAKa,KAAOV,IAAI,KAAK,KAAM,KAAM,GAAG,GAAGA,IAAI,EAAC;AAC7D;AAEA,MAAMY,KAAQ,CAACd,GAAIa,GAAIE,OAAQf,MAAO,MAAMa,MAAO,MAAME,MAAO,IAC1DC,KAAQ,CAACC,GAAKlB,GAAIa,GAAIM,MAAQnB,IAAKa,IAAKM,KAAOD,IAAM,KAAK,KAAM,KAAM,GACtEE,KAAQ,CAACnB,GAAIa,GAAIE,GAAIK,OAAQpB,MAAO,MAAMa,MAAO,MAAME,MAAO,MAAMK,MAAO,IAC3EC,KAAQ,CAACJ,GAAKlB,GAAIa,GAAIM,GAAII,MAAQvB,IAAKa,IAAKM,IAAKI,KAAOL,IAAM,KAAK,KAAM,KAAM,GAC/EM,KAAQ,CAACvB,GAAIa,GAAIE,GAAIK,GAAII,OAAQxB,MAAO,MAAMa,MAAO,MAAME,MAAO,MAAMK,MAAO,MAAMI,MAAO,IAC5FC,KAAQ,CAACR,GAAKlB,GAAIa,GAAIM,GAAII,GAAII,MAAQ3B,IAAKa,IAAKM,IAAKI,IAAKI,KAAOT,IAAM,KAAK,KAAM,KAAM,GC0ExFU,KAA8BC,GAAU;AAAA,EAC1C;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAClE;AAAA,EAAsB;AAAA,EAAsB;AAAA,EAAsB;AACtE,EAAE,IAAI,CAAApG,MAAK,OAAOA,CAAC,CAAC,CAAC,GACfqG,KAAmCF,GAAK,CAAC,GACzCG,KAAmCH,GAAK,CAAC,GAEzCI,IAA6B,oBAAI,YAAY,EAAE,GAC/CC,IAA6B,oBAAI,YAAY,EAAE;AAErD,MAAMC,WAAiBC,GAAO;AAAA,EAC1B,YAAYxD,GAAW;AACnB,UAAM,KAAKA,GAAW,IAAI,EAAK;AAAA,EACnC;AAAA;AAAA,EAEA,MAAM;AACF,UAAM,EAAE,IAAAqB,GAAI,IAAAC,GAAI,IAAAY,GAAI,IAAAC,GAAI,IAAAK,GAAI,IAAAH,GAAI,IAAAO,GAAI,IAAAF,GAAI,IAAAM,GAAI,IAAAF,GAAI,IAAAW,GAAI,IAAAC,GAAI,IAAAC,GAAI,IAAAC,GAAI,IAAAC,GAAI,IAAAC,EAAE,IAAK;AAC3E,WAAO,CAACzC,GAAIC,GAAIY,GAAIC,GAAIK,GAAIH,GAAIO,GAAIF,GAAIM,GAAIF,GAAIW,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,CAAE;AAAA,EAC1E;AAAA;AAAA,EAEA,IAAIzC,GAAIC,GAAIY,GAAIC,GAAIK,GAAIH,GAAIO,GAAIF,GAAIM,GAAIF,GAAIW,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAI;AAChE,SAAK,KAAKzC,IAAK,GACf,KAAK,KAAKC,IAAK,GACf,KAAK,KAAKY,IAAK,GACf,KAAK,KAAKC,IAAK,GACf,KAAK,KAAKK,IAAK,GACf,KAAK,KAAKH,IAAK,GACf,KAAK,KAAKO,IAAK,GACf,KAAK,KAAKF,IAAK,GACf,KAAK,KAAKM,IAAK,GACf,KAAK,KAAKF,IAAK,GACf,KAAK,KAAKW,IAAK,GACf,KAAK,KAAKC,IAAK,GACf,KAAK,KAAKC,IAAK,GACf,KAAK,KAAKC,IAAK,GACf,KAAK,KAAKC,IAAK,GACf,KAAK,KAAKC,IAAK;AAAA,EACnB;AAAA,EACA,QAAQ3D,GAAM4D,GAAQ;AAElB,aAAS5L,IAAI,GAAGA,IAAI,IAAIA,KAAK4L,KAAU;AACnC,MAAAV,EAAWlL,CAAC,IAAIgI,EAAK,UAAU4D,CAAM,GACrCT,EAAWnL,CAAC,IAAIgI,EAAK,UAAW4D,KAAU,CAAC;AAE/C,aAAS5L,IAAI,IAAIA,IAAI,IAAIA,KAAK;AAE1B,YAAM6L,IAAOX,EAAWlL,IAAI,EAAE,IAAI,GAC5B8L,IAAOX,EAAWnL,IAAI,EAAE,IAAI,GAC5B+L,IAAMC,EAAWH,GAAMC,GAAM,CAAC,IAAIE,EAAWH,GAAMC,GAAM,CAAC,IAAIG,GAAUJ,GAAMC,GAAM,CAAC,GACrFI,IAAMC,GAAWN,GAAMC,GAAM,CAAC,IAAIK,GAAWN,GAAMC,GAAM,CAAC,IAAIM,GAAUP,GAAMC,GAAM,CAAC,GAErFO,IAAMnB,EAAWlL,IAAI,CAAC,IAAI,GAC1BsM,IAAMnB,EAAWnL,IAAI,CAAC,IAAI,GAC1BuM,IAAMP,EAAWK,GAAKC,GAAK,EAAE,IAAIE,GAAWH,GAAKC,GAAK,EAAE,IAAIL,GAAUI,GAAKC,GAAK,CAAC,GACjFG,IAAMN,GAAWE,GAAKC,GAAK,EAAE,IAAII,GAAWL,GAAKC,GAAK,EAAE,IAAIF,GAAUC,GAAKC,GAAK,CAAC,GAEjFK,IAAOC,GAAUV,GAAKO,GAAKtB,EAAWnL,IAAI,CAAC,GAAGmL,EAAWnL,IAAI,EAAE,CAAC,GAChE6M,IAAOC,GAAUH,GAAMZ,GAAKQ,GAAKrB,EAAWlL,IAAI,CAAC,GAAGkL,EAAWlL,IAAI,EAAE,CAAC;AAC5E,MAAAkL,EAAWlL,CAAC,IAAI6M,IAAO,GACvB1B,EAAWnL,CAAC,IAAI2M,IAAO;AAAA,IAC3B;AACA,QAAI,EAAE,IAAAzD,GAAI,IAAAC,GAAI,IAAAY,GAAI,IAAAC,GAAI,IAAAK,GAAI,IAAAH,GAAI,IAAAO,GAAI,IAAAF,GAAI,IAAAM,GAAI,IAAAF,GAAI,IAAAW,GAAI,IAAAC,GAAI,IAAAC,GAAI,IAAAC,GAAI,IAAAC,GAAI,IAAAC,EAAE,IAAK;AAEzE,aAAS3L,IAAI,GAAGA,IAAI,IAAIA,KAAK;AAEzB,YAAM+M,IAAUf,EAAWnB,GAAIF,GAAI,EAAE,IAAIqB,EAAWnB,GAAIF,GAAI,EAAE,IAAI6B,GAAW3B,GAAIF,GAAI,EAAE,GACjFqC,IAAUb,GAAWtB,GAAIF,GAAI,EAAE,IAAIwB,GAAWtB,GAAIF,GAAI,EAAE,IAAI+B,GAAW7B,GAAIF,GAAI,EAAE,GAEjFsC,IAAQpC,IAAKS,IAAO,CAACT,IAAKW,GAC1B0B,IAAQvC,IAAKY,IAAO,CAACZ,IAAKc,GAG1B0B,IAAOC,GAAUzB,GAAIqB,GAASE,GAAMjC,GAAUjL,CAAC,GAAGmL,EAAWnL,CAAC,CAAC,GAC/DqN,IAAMC,GAAUH,GAAMzB,GAAIqB,GAASE,GAAMjC,GAAUhL,CAAC,GAAGkL,EAAWlL,CAAC,CAAC,GACpEuN,IAAMJ,IAAO,GAEbK,IAAUxB,EAAW9C,GAAIC,GAAI,EAAE,IAAIqD,GAAWtD,GAAIC,GAAI,EAAE,IAAIqD,GAAWtD,GAAIC,GAAI,EAAE,GACjFsE,IAAUtB,GAAWjD,GAAIC,GAAI,EAAE,IAAIuD,GAAWxD,GAAIC,GAAI,EAAE,IAAIuD,GAAWxD,GAAIC,GAAI,EAAE,GACjFuE,IAAQxE,IAAKa,IAAOb,IAAKmB,IAAON,IAAKM,GACrCsD,IAAQxE,IAAKa,IAAOb,IAAKe,IAAOF,IAAKE;AAC3C,MAAAwB,IAAKF,IAAK,GACVG,IAAKF,IAAK,GACVD,IAAKF,IAAK,GACVG,IAAKF,IAAK,GACVD,IAAKT,IAAK,GACVU,IAAKZ,IAAK,GACT,EAAE,GAAGE,GAAI,GAAGF,EAAE,IAAKiD,EAAQnD,IAAK,GAAGF,IAAK,GAAG8C,IAAM,GAAGE,IAAM,CAAC,GAC5D9C,IAAKJ,IAAK,GACVE,IAAKL,IAAK,GACVG,IAAKN,IAAK,GACVG,IAAKF,IAAK,GACVD,IAAKb,IAAK,GACVc,IAAKb,IAAK;AACV,YAAM0E,IAAMC,GAAUP,GAAKE,GAASE,CAAI;AACxC,MAAAzE,IAAK6E,GAAUF,GAAKR,GAAKG,GAASE,CAAI,GACtCvE,IAAK0E,IAAM;AAAA,IACf;AAEA,KAAC,EAAE,GAAG3E,GAAI,GAAGC,EAAE,IAAKyE,EAAQ,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG1E,IAAK,GAAGC,IAAK,CAAC,IACnE,EAAE,GAAGY,GAAI,GAAGC,EAAE,IAAK4D,EAAQ,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG7D,IAAK,GAAGC,IAAK,CAAC,GACnE,EAAE,GAAGK,GAAI,GAAGH,EAAE,IAAK0D,EAAQ,KAAK,KAAK,GAAG,KAAK,KAAK,GAAGvD,IAAK,GAAGH,IAAK,CAAC,GACnE,EAAE,GAAGO,GAAI,GAAGF,EAAE,IAAKqD,EAAQ,KAAK,KAAK,GAAG,KAAK,KAAK,GAAGnD,IAAK,GAAGF,IAAK,CAAC,GACnE,EAAE,GAAGM,GAAI,GAAGF,EAAE,IAAKiD,EAAQ,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG/C,IAAK,GAAGF,IAAK,CAAC,GACnE,EAAE,GAAGW,GAAI,GAAGC,EAAE,IAAKqC,EAAQ,KAAK,KAAK,GAAG,KAAK,KAAK,GAAGtC,IAAK,GAAGC,IAAK,CAAC,GACnE,EAAE,GAAGC,GAAI,GAAGC,EAAE,IAAKmC,EAAQ,KAAK,KAAK,GAAG,KAAK,KAAK,GAAGpC,IAAK,GAAGC,IAAK,CAAC,GACnE,EAAE,GAAGC,GAAI,GAAGC,EAAE,IAAKiC,EAAQ,KAAK,KAAK,GAAG,KAAK,KAAK,GAAGlC,IAAK,GAAGC,IAAK,CAAC,GACpE,KAAK,IAAIzC,GAAIC,GAAIY,GAAIC,GAAIK,GAAIH,GAAIO,GAAIF,GAAIM,GAAIF,GAAIW,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,CAAE;AAAA,EAC3E;AAAA,EACA,aAAa;AACTlG,IAAAA,GAAMyF,GAAYC,CAAU;AAAA,EAChC;AAAA,EACA,UAAU;AACN1F,IAAAA,GAAM,KAAK,MAAM,GACjB,KAAK,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,EAC3D;AACJ;AAEO,MAAMuI,WAAgB5C,GAAS;AAAA,EAClC,KAAKzC,EAAU,CAAC,IAAI;AAAA,EACpB,KAAKA,EAAU,CAAC,IAAI;AAAA,EACpB,KAAKA,EAAU,CAAC,IAAI;AAAA,EACpB,KAAKA,EAAU,CAAC,IAAI;AAAA,EACpB,KAAKA,EAAU,CAAC,IAAI;AAAA,EACpB,KAAKA,EAAU,CAAC,IAAI;AAAA,EACpB,KAAKA,EAAU,CAAC,IAAI;AAAA,EACpB,KAAKA,EAAU,CAAC,IAAI;AAAA,EACpB,KAAKA,EAAU,CAAC,IAAI;AAAA,EACpB,KAAKA,EAAU,CAAC,IAAI;AAAA,EACpB,KAAKA,EAAU,EAAE,IAAI;AAAA,EACrB,KAAKA,EAAU,EAAE,IAAI;AAAA,EACrB,KAAKA,EAAU,EAAE,IAAI;AAAA,EACrB,KAAKA,EAAU,EAAE,IAAI;AAAA,EACrB,KAAKA,EAAU,EAAE,IAAI;AAAA,EACrB,KAAKA,EAAU,EAAE,IAAI;AAAA,EACrB,cAAc;AACV,UAAM,EAAE;AAAA,EACZ;AACJ;AAiGO,MAAMsF,KAAyBlH,gBAAAA;AAAAA,EAAa,MAAM,IAAIiH,GAAO;AAAA,EACpD,gBAAAvG,GAAQ,CAAI;AAAC;ACrX7B,MAAMyG,KAAsB,uBAAO,CAAC,GAC9BC,KAAsB,uBAAO,CAAC;AAC7B,SAASC,GAAMrJ,GAAOH,IAAQ,IAAI;AACrC,MAAI,OAAOG,KAAU,WAAW;AAC5B,UAAMF,IAASD,KAAS,IAAIA,CAAK;AACjC,UAAM,IAAI,MAAMC,IAAS,gCAAgC,OAAOE,CAAK;AAAA,EACzE;AACA,SAAOA;AACX;AAEA,SAASsJ,GAAW1J,GAAG;AACnB,MAAI,OAAOA,KAAM;AACb,QAAI,CAAC2J,GAAS3J,CAAC;AACX,YAAM,IAAI,MAAM,mCAAmCA,CAAC;AAAA;AAGxD,IAAAD,GAAQC,CAAC;AACb,SAAOA;AACX;AAWO,SAAS4J,GAAYrO,GAAK;AAC7B,MAAI,OAAOA,KAAQ;AACf,UAAM,IAAI,MAAM,8BAA8B,OAAOA,CAAG;AAC5D,SAAOA,MAAQ,KAAKgO,KAAM,OAAO,OAAOhO,CAAG;AAC/C;AAEO,SAASsO,GAAgBxN,GAAO;AACnC,SAAOuN,GAAYE,GAAYzN,CAAK,CAAC;AACzC;AACO,SAAS0N,GAAgB1N,GAAO;AACnC,SAAOuN,GAAYE,GAAYE,GAAUC,EAAQ5N,CAAK,CAAC,EAAE,QAAO,CAAE,CAAC;AACvE;AACO,SAAS6N,GAAgBlK,GAAG/D,GAAK;AACpC,EAAA8D,GAAQ9D,CAAG,GACX+D,IAAI0J,GAAW1J,CAAC;AAChB,QAAMkC,IAAMiI,GAAYnK,EAAE,SAAS,EAAE,EAAE,SAAS/D,IAAM,GAAG,GAAG,CAAC;AAC7D,MAAIiG,EAAI,WAAWjG;AACf,UAAM,IAAI,MAAM,kBAAkB;AACtC,SAAOiG;AACX;AACO,SAASkI,GAAgBpK,GAAG/D,GAAK;AACpC,SAAOiO,GAAgBlK,GAAG/D,CAAG,EAAE,QAAO;AAC1C;AAkBO,SAAS+N,GAAU3N,GAAO;AAC7B,SAAO,WAAW,KAAKA,CAAK;AAChC;AAgBA,MAAMsN,KAAW,CAAC3J,MAAM,OAAOA,KAAM,YAAYuJ,MAAOvJ;AACjD,SAASqK,GAAQrK,GAAGa,GAAK7B,GAAK;AACjC,SAAO2K,GAAS3J,CAAC,KAAK2J,GAAS9I,CAAG,KAAK8I,GAAS3K,CAAG,KAAK6B,KAAOb,KAAKA,IAAIhB;AAC5E;AAMO,SAASsL,GAASrK,GAAOD,GAAGa,GAAK7B,GAAK;AAMzC,MAAI,CAACqL,GAAQrK,GAAGa,GAAK7B,CAAG;AACpB,UAAM,IAAI,MAAM,oBAAoBiB,IAAQ,OAAOY,IAAM,aAAa7B,IAAM,WAAWgB,CAAC;AAChG;AA+BO,MAAMuK,KAAU,CAACvK,OAAOwJ,MAAO,OAAOxJ,CAAC,KAAKwJ;AA8D5C,SAASgB,GAAeC,GAAQC,IAAS,CAAA,GAAIC,IAAY,CAAA,GAAI;AAChE,MAAI,CAACF,KAAU,OAAOA,KAAW;AAC7B,UAAM,IAAI,MAAM,+BAA+B;AACnD,WAASG,EAAWC,GAAWC,GAAcC,GAAO;AAChD,UAAMC,IAAMP,EAAOI,CAAS;AAC5B,QAAIE,KAASC,MAAQ;AACjB;AACJ,UAAMC,IAAU,OAAOD;AACvB,QAAIC,MAAYH,KAAgBE,MAAQ;AACpC,YAAM,IAAI,MAAM,UAAUH,CAAS,0BAA0BC,CAAY,SAASG,CAAO,EAAE;AAAA,EACnG;AACA,QAAMC,IAAO,CAACC,GAAGJ,MAAU,OAAO,QAAQI,CAAC,EAAE,QAAQ,CAAC,CAACC,GAAGC,CAAC,MAAMT,EAAWQ,GAAGC,GAAGN,CAAK,CAAC;AACxF,EAAAG,EAAKR,GAAQ,EAAK,GAClBQ,EAAKP,GAAW,EAAI;AACxB;AAWO,SAASW,GAASC,GAAI;AACzB,QAAMC,IAAM,oBAAI,QAAO;AACvB,SAAO,CAACC,MAAQC,MAAS;AACrB,UAAMV,IAAMQ,EAAI,IAAIC,CAAG;AACvB,QAAIT,MAAQ;AACR,aAAOA;AACX,UAAMW,IAAWJ,EAAGE,GAAK,GAAGC,CAAI;AAChC,WAAAF,EAAI,IAAIC,GAAKE,CAAQ,GACdA;AAAA,EACX;AACJ;ACrOA,MAAMpC,IAAsB,uBAAO,CAAC,GAAGC,IAAsB,uBAAO,CAAC,GAAGoC,IAAsB,uBAAO,CAAC,GAEhGC,KAAsB,uBAAO,CAAC,GAAGC,KAAsB,uBAAO,CAAC,GAAGC,KAAsB,uBAAO,CAAC,GAEhGC,KAAsB,uBAAO,CAAC,GAAGC,KAAsB,uBAAO,CAAC,GAAGC,KAAsB,uBAAO,CAAC,GAChGC,KAAuB,uBAAO,EAAE;AAE/B,SAASC,EAAItM,GAAGuM,GAAG;AACtB,QAAM3N,IAASoB,IAAIuM;AACnB,SAAO3N,KAAU6K,IAAM7K,IAAS2N,IAAI3N;AACxC;AAWO,SAAS4N,EAAKxP,GAAGyP,GAAOC,GAAQ;AACnC,MAAItK,IAAMpF;AACV,SAAOyP,MAAUhD;AACb,IAAArH,KAAOA,GACPA,KAAOsK;AAEX,SAAOtK;AACX;AAKO,SAASuK,GAAOC,GAAQF,GAAQ;AACnC,MAAIE,MAAWnD;AACX,UAAM,IAAI,MAAM,kCAAkC;AACtD,MAAIiD,KAAUjD;AACV,UAAM,IAAI,MAAM,4CAA4CiD,CAAM;AAEtE,MAAI1M,IAAIsM,EAAIM,GAAQF,CAAM,GACtBH,IAAIG,GAEJ1P,IAAIyM,GAAcoD,IAAInD;AAC1B,SAAO1J,MAAMyJ,KAAK;AAEd,UAAMqD,IAAIP,IAAIvM,GACR+M,IAAIR,IAAIvM,GACRgN,IAAIhQ,IAAI6P,IAAIC;AAGlB,IAAAP,IAAIvM,GAAGA,IAAI+M,GAAG/P,IAAI6P,GAAUA,IAAIG;AAAA,EACpC;AAEA,MADYT,MACA7C;AACR,UAAM,IAAI,MAAM,wBAAwB;AAC5C,SAAO4C,EAAItP,GAAG0P,CAAM;AACxB;AACA,SAASO,GAAeC,GAAI/S,GAAM,GAAG;AACjC,MAAI,CAAC+S,EAAG,IAAIA,EAAG,IAAI/S,CAAI,GAAG,CAAC;AACvB,UAAM,IAAI,MAAM,yBAAyB;AACjD;AAKA,SAASgT,GAAUD,GAAIhN,GAAG;AACtB,QAAMkN,KAAUF,EAAG,QAAQxD,KAAOsC,IAC5B7R,IAAO+S,EAAG,IAAIhN,GAAGkN,CAAM;AAC7B,SAAAH,GAAeC,GAAI/S,GAAM+F,CAAC,GACnB/F;AACX;AACA,SAASkT,GAAUH,GAAIhN,GAAG;AACtB,QAAMoN,KAAUJ,EAAG,QAAQjB,MAAOE,IAC5BlK,IAAKiL,EAAG,IAAIhN,GAAG4L,CAAG,GAClBP,IAAI2B,EAAG,IAAIjL,GAAIqL,CAAM,GACrBC,IAAKL,EAAG,IAAIhN,GAAGqL,CAAC,GAChBhQ,IAAI2R,EAAG,IAAIA,EAAG,IAAIK,GAAIzB,CAAG,GAAGP,CAAC,GAC7BpR,IAAO+S,EAAG,IAAIK,GAAIL,EAAG,IAAI3R,GAAG2R,EAAG,GAAG,CAAC;AACzC,SAAAD,GAAeC,GAAI/S,GAAM+F,CAAC,GACnB/F;AACX;AAGA,SAASqT,GAAWC,GAAG;AACnB,QAAMC,IAAMC,GAAMF,CAAC,GACbG,IAAKC,GAAcJ,CAAC,GACpBK,IAAKF,EAAGF,GAAKA,EAAI,IAAIA,EAAI,GAAG,CAAC,GAC7BK,IAAKH,EAAGF,GAAKI,CAAE,GACfE,IAAKJ,EAAGF,GAAKA,EAAI,IAAII,CAAE,CAAC,GACxBG,KAAMR,IAAIvB,MAAOG;AACvB,SAAO,CAACa,GAAIhN,MAAM;AACd,QAAIgO,IAAMhB,EAAG,IAAIhN,GAAG+N,CAAE,GAClBE,IAAMjB,EAAG,IAAIgB,GAAKJ,CAAE;AACxB,UAAMM,IAAMlB,EAAG,IAAIgB,GAAKH,CAAE,GACpBM,IAAMnB,EAAG,IAAIgB,GAAKF,CAAE,GACpBM,IAAKpB,EAAG,IAAIA,EAAG,IAAIiB,CAAG,GAAGjO,CAAC,GAC1BqO,IAAKrB,EAAG,IAAIA,EAAG,IAAIkB,CAAG,GAAGlO,CAAC;AAChC,IAAAgO,IAAMhB,EAAG,KAAKgB,GAAKC,GAAKG,CAAE,GAC1BH,IAAMjB,EAAG,KAAKmB,GAAKD,GAAKG,CAAE;AAC1B,UAAMC,IAAKtB,EAAG,IAAIA,EAAG,IAAIiB,CAAG,GAAGjO,CAAC,GAC1B/F,IAAO+S,EAAG,KAAKgB,GAAKC,GAAKK,CAAE;AACjC,WAAAvB,GAAeC,GAAI/S,GAAM+F,CAAC,GACnB/F;AAAA,EACX;AACJ;AAQO,SAAS0T,GAAcJ,GAAG;AAG7B,MAAIA,IAAI1B;AACJ,UAAM,IAAI,MAAM,qCAAqC;AAEzD,MAAI0C,IAAIhB,IAAI/D,GACRgF,IAAI;AACR,SAAOD,IAAI3C,MAAQrC;AACf,IAAAgF,KAAK3C,GACL4C;AAGJ,MAAIC,IAAI7C;AACR,QAAM8C,IAAMjB,GAAMF,CAAC;AACnB,SAAOoB,GAAWD,GAAKD,CAAC,MAAM;AAG1B,QAAIA,MAAM;AACN,YAAM,IAAI,MAAM,+CAA+C;AAGvE,MAAID,MAAM;AACN,WAAOvB;AAGX,MAAI2B,IAAKF,EAAI,IAAID,GAAGF,CAAC;AACrB,QAAMM,KAAUN,IAAI/E,KAAOoC;AAC3B,SAAO,SAAqBoB,GAAIhN,GAAG;AAC/B,QAAIgN,EAAG,IAAIhN,CAAC;AACR,aAAOA;AAEX,QAAI2O,GAAW3B,GAAIhN,CAAC,MAAM;AACtB,YAAM,IAAI,MAAM,yBAAyB;AAE7C,QAAI8O,IAAIN,GACJO,IAAI/B,EAAG,IAAIA,EAAG,KAAK4B,CAAE,GACrBI,IAAIhC,EAAG,IAAIhN,GAAGuO,CAAC,GACfU,IAAIjC,EAAG,IAAIhN,GAAG6O,CAAM;AAGxB,WAAO,CAAC7B,EAAG,IAAIgC,GAAGhC,EAAG,GAAG,KAAG;AACvB,UAAIA,EAAG,IAAIgC,CAAC;AACR,eAAOhC,EAAG;AACd,UAAI3R,IAAI,GAEJ6T,IAAQlC,EAAG,IAAIgC,CAAC;AACpB,aAAO,CAAChC,EAAG,IAAIkC,GAAOlC,EAAG,GAAG;AAGxB,YAFA3R,KACA6T,IAAQlC,EAAG,IAAIkC,CAAK,GAChB7T,MAAMyT;AACN,gBAAM,IAAI,MAAM,yBAAyB;AAGjD,YAAMK,IAAW3F,KAAO,OAAOsF,IAAIzT,IAAI,CAAC,GAClCgR,IAAIW,EAAG,IAAI+B,GAAGI,CAAQ;AAE5B,MAAAL,IAAIzT,GACJ0T,IAAI/B,EAAG,IAAIX,CAAC,GACZ2C,IAAIhC,EAAG,IAAIgC,GAAGD,CAAC,GACfE,IAAIjC,EAAG,IAAIiC,GAAG5C,CAAC;AAAA,IACnB;AACA,WAAO4C;AAAA,EACX;AACJ;AAYO,SAASG,GAAO7B,GAAG;AAEtB,SAAIA,IAAIzB,OAAQD,KACLoB,KAEPM,IAAItB,OAAQF,KACLoB,KAEPI,IAAIpB,OAASD,KACNoB,GAAWC,CAAC,IAEhBI,GAAcJ,CAAC;AAC1B;AAEO,MAAM8B,KAAe,CAACjU,GAAKoR,OAAYJ,EAAIhR,GAAKoR,CAAM,IAAIhD,OAASA,GAEpE8F,KAAe;AAAA,EACjB;AAAA,EAAU;AAAA,EAAW;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAQ;AAAA,EAClD;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACnC;AAAA,EAAQ;AAAA,EAAQ;AAAA,EAAQ;AAC5B;AACO,SAASC,GAAcC,GAAO;AACjC,QAAMC,IAAU;AAAA,IACZ,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM;AAAA,EACd,GACUhN,IAAO6M,GAAa,OAAO,CAAC9D,GAAKR,OACnCQ,EAAIR,CAAG,IAAI,YACJQ,IACRiE,CAAO;AACV,SAAAjF,GAAegF,GAAO/M,CAAI,GAInB+M;AACX;AAMO,SAASE,GAAM1C,GAAI5R,GAAKmR,GAAO;AAClC,MAAIA,IAAQhD;AACR,UAAM,IAAI,MAAM,yCAAyC;AAC7D,MAAIgD,MAAUhD;AACV,WAAOyD,EAAG;AACd,MAAIT,MAAU/C;AACV,WAAOpO;AACX,MAAIuU,IAAI3C,EAAG,KACP4C,IAAIxU;AACR,SAAOmR,IAAQhD;AACX,IAAIgD,IAAQ/C,MACRmG,IAAI3C,EAAG,IAAI2C,GAAGC,CAAC,IACnBA,IAAI5C,EAAG,IAAI4C,CAAC,GACZrD,MAAU/C;AAEd,SAAOmG;AACX;AAMO,SAASE,GAAc7C,GAAI8C,GAAMC,IAAW,IAAO;AACtD,QAAMC,IAAW,IAAI,MAAMF,EAAK,MAAM,EAAE,KAAKC,IAAW/C,EAAG,OAAO,MAAS,GAErEiD,IAAgBH,EAAK,OAAO,CAACI,GAAK9U,GAAK,MACrC4R,EAAG,IAAI5R,CAAG,IACH8U,KACXF,EAAS,CAAC,IAAIE,GACPlD,EAAG,IAAIkD,GAAK9U,CAAG,IACvB4R,EAAG,GAAG,GAEHmD,IAAcnD,EAAG,IAAIiD,CAAa;AAExC,SAAAH,EAAK,YAAY,CAACI,GAAK9U,GAAK,MACpB4R,EAAG,IAAI5R,CAAG,IACH8U,KACXF,EAAS,CAAC,IAAIhD,EAAG,IAAIkD,GAAKF,EAAS,CAAC,CAAC,GAC9BhD,EAAG,IAAIkD,GAAK9U,CAAG,IACvB+U,CAAW,GACPH;AACX;AAcO,SAASrB,GAAW3B,GAAIhN,GAAG;AAG9B,QAAMoQ,KAAUpD,EAAG,QAAQxD,KAAOoC,GAC5ByE,IAAUrD,EAAG,IAAIhN,GAAGoQ,CAAM,GAC1BE,IAAMtD,EAAG,IAAIqD,GAASrD,EAAG,GAAG,GAC5BuD,IAAOvD,EAAG,IAAIqD,GAASrD,EAAG,IAAI,GAC9BwD,IAAKxD,EAAG,IAAIqD,GAASrD,EAAG,IAAIA,EAAG,GAAG,CAAC;AACzC,MAAI,CAACsD,KAAO,CAACC,KAAQ,CAACC;AAClB,UAAM,IAAI,MAAM,gCAAgC;AACpD,SAAOF,IAAM,IAAIC,IAAO,IAAI;AAChC;AAOO,SAASE,GAAQzQ,GAAG0Q,GAAY;AAEnC,EAAIA,MAAe,UACf3Q,GAAQ2Q,CAAU;AACtB,QAAMC,IAAcD,MAAe,SAAYA,IAAa1Q,EAAE,SAAS,CAAC,EAAE,QACpE4Q,IAAc,KAAK,KAAKD,IAAc,CAAC;AAC7C,SAAO,EAAE,YAAYA,GAAa,aAAAC,EAAW;AACjD;AACA,MAAMC,GAAO;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,OAAOtH;AAAAA,EACP,MAAMC;AAAAA,EACN;AAAA,EACA;AAAA;AAAA,EACA;AAAA,EACA,YAAYsH,GAAOrO,IAAO,IAAI;AAC1B,QAAIqO,KAASvH;AACT,YAAM,IAAI,MAAM,4CAA4CuH,CAAK;AACrE,QAAIC;AACJ,SAAK,OAAO,IACRtO,KAAQ,QAAQ,OAAOA,KAAS,aAC5B,OAAOA,EAAK,QAAS,aACrBsO,IAActO,EAAK,OACnB,OAAOA,EAAK,QAAS,eACrB,KAAK,OAAOA,EAAK,OACjB,OAAOA,EAAK,QAAS,cACrB,KAAK,OAAOA,EAAK,OACjBA,EAAK,mBACL,KAAK,WAAWA,EAAK,gBAAgB,MAAK,IAC1C,OAAOA,EAAK,gBAAiB,cAC7B,KAAK,OAAOA,EAAK;AAEzB,UAAM,EAAE,YAAAiO,GAAY,aAAAE,EAAW,IAAKH,GAAQK,GAAOC,CAAW;AAC9D,QAAIH,IAAc;AACd,YAAM,IAAI,MAAM,gDAAgD;AACpE,SAAK,QAAQE,GACb,KAAK,OAAOJ,GACZ,KAAK,QAAQE,GACb,KAAK,QAAQ,QACb,OAAO,kBAAkB,IAAI;AAAA,EACjC;AAAA,EACA,OAAOxV,GAAK;AACR,WAAOgR,EAAIhR,GAAK,KAAK,KAAK;AAAA,EAC9B;AAAA,EACA,QAAQA,GAAK;AACT,QAAI,OAAOA,KAAQ;AACf,YAAM,IAAI,MAAM,iDAAiD,OAAOA,CAAG;AAC/E,WAAOmO,KAAOnO,KAAOA,IAAM,KAAK;AAAA,EACpC;AAAA,EACA,IAAIA,GAAK;AACL,WAAOA,MAAQmO;AAAAA,EACnB;AAAA;AAAA,EAEA,YAAYnO,GAAK;AACb,WAAO,CAAC,KAAK,IAAIA,CAAG,KAAK,KAAK,QAAQA,CAAG;AAAA,EAC7C;AAAA,EACA,MAAMA,GAAK;AACP,YAAQA,IAAMoO,OAASA;AAAAA,EAC3B;AAAA,EACA,IAAIpO,GAAK;AACL,WAAOgR,EAAI,CAAChR,GAAK,KAAK,KAAK;AAAA,EAC/B;AAAA,EACA,IAAI4V,GAAKC,GAAK;AACV,WAAOD,MAAQC;AAAA,EACnB;AAAA,EACA,IAAI7V,GAAK;AACL,WAAOgR,EAAIhR,IAAMA,GAAK,KAAK,KAAK;AAAA,EACpC;AAAA,EACA,IAAI4V,GAAKC,GAAK;AACV,WAAO7E,EAAI4E,IAAMC,GAAK,KAAK,KAAK;AAAA,EACpC;AAAA,EACA,IAAID,GAAKC,GAAK;AACV,WAAO7E,EAAI4E,IAAMC,GAAK,KAAK,KAAK;AAAA,EACpC;AAAA,EACA,IAAID,GAAKC,GAAK;AACV,WAAO7E,EAAI4E,IAAMC,GAAK,KAAK,KAAK;AAAA,EACpC;AAAA,EACA,IAAI7V,GAAKmR,GAAO;AACZ,WAAOmD,GAAM,MAAMtU,GAAKmR,CAAK;AAAA,EACjC;AAAA,EACA,IAAIyE,GAAKC,GAAK;AACV,WAAO7E,EAAI4E,IAAMvE,GAAOwE,GAAK,KAAK,KAAK,GAAG,KAAK,KAAK;AAAA,EACxD;AAAA;AAAA,EAEA,KAAK7V,GAAK;AACN,WAAOA,IAAMA;AAAA,EACjB;AAAA,EACA,KAAK4V,GAAKC,GAAK;AACX,WAAOD,IAAMC;AAAA,EACjB;AAAA,EACA,KAAKD,GAAKC,GAAK;AACX,WAAOD,IAAMC;AAAA,EACjB;AAAA,EACA,KAAKD,GAAKC,GAAK;AACX,WAAOD,IAAMC;AAAA,EACjB;AAAA,EACA,IAAI7V,GAAK;AACL,WAAOqR,GAAOrR,GAAK,KAAK,KAAK;AAAA,EACjC;AAAA,EACA,KAAKA,GAAK;AAEN,WAAK,KAAK,UACN,KAAK,QAAQgU,GAAO,KAAK,KAAK,IAC3B,KAAK,MAAM,MAAMhU,CAAG;AAAA,EAC/B;AAAA,EACA,QAAQA,GAAK;AACT,WAAO,KAAK,OAAOgP,GAAgBhP,GAAK,KAAK,KAAK,IAAI8O,GAAgB9O,GAAK,KAAK,KAAK;AAAA,EACzF;AAAA,EACA,UAAUiB,GAAO6U,IAAiB,IAAO;AACrC/Q,IAAAA,EAAO9D,CAAK;AACZ,UAAM,EAAE,UAAU8U,GAAgB,OAAAC,GAAO,MAAAhO,GAAM,OAAA0N,GAAO,MAAMO,EAAY,IAAK;AAC7E,QAAIF,GAAgB;AAChB,UAAI,CAACA,EAAe,SAAS9U,EAAM,MAAM,KAAKA,EAAM,SAAS+U;AACzD,cAAM,IAAI,MAAM,+BAA+BD,IAAiB,iBAAiB9U,EAAM,MAAM;AAEjG,YAAMiV,IAAS,IAAI,WAAWF,CAAK;AAEnC,MAAAE,EAAO,IAAIjV,GAAO+G,IAAO,IAAIkO,EAAO,SAASjV,EAAM,MAAM,GACzDA,IAAQiV;AAAA,IACZ;AACA,QAAIjV,EAAM,WAAW+U;AACjB,YAAM,IAAI,MAAM,+BAA+BA,IAAQ,iBAAiB/U,EAAM,MAAM;AACxF,QAAIkV,IAASnO,IAAO2G,GAAgB1N,CAAK,IAAIwN,GAAgBxN,CAAK;AAGlE,QAFIgV,MACAE,IAASnF,EAAImF,GAAQT,CAAK,IAC1B,CAACI,KACG,CAAC,KAAK,QAAQK,CAAM;AACpB,YAAM,IAAI,MAAM,kDAAkD;AAG1E,WAAOA;AAAA,EACX;AAAA;AAAA,EAEA,YAAYjN,GAAK;AACb,WAAOuL,GAAc,MAAMvL,CAAG;AAAA,EAClC;AAAA;AAAA;AAAA,EAGA,KAAKxE,GAAGuM,GAAGmF,GAAW;AAClB,WAAOA,IAAYnF,IAAIvM;AAAA,EAC3B;AACJ;AAoBO,SAAS2N,GAAMqD,GAAOrO,IAAO,IAAI;AACpC,SAAO,IAAIoO,GAAOC,GAAOrO,CAAI;AACjC;ACvdA,MAAM8G,KAAsB,uBAAO,CAAC,GAC9BC,KAAsB,uBAAO,CAAC;AAC7B,SAASiI,GAASD,GAAWE,GAAM;AACtC,QAAMC,IAAMD,EAAK,OAAM;AACvB,SAAOF,IAAYG,IAAMD;AAC7B;AAOO,SAASE,GAAW7C,GAAG8C,GAAQ;AAClC,QAAMC,IAAajC,GAAcd,EAAE,IAAI8C,EAAO,IAAI,CAAClC,MAAMA,EAAE,CAAC,CAAC;AAC7D,SAAOkC,EAAO,IAAI,CAAClC,GAAGtU,MAAM0T,EAAE,WAAWY,EAAE,SAASmC,EAAWzW,CAAC,CAAC,CAAC,CAAC;AACvE;AACA,SAAS0W,GAAUC,GAAGnW,GAAM;AACxB,MAAI,CAAC,OAAO,cAAcmW,CAAC,KAAKA,KAAK,KAAKA,IAAInW;AAC1C,UAAM,IAAI,MAAM,uCAAuCA,IAAO,cAAcmW,CAAC;AACrF;AACA,SAASC,GAAUD,GAAGE,GAAY;AAC9B,EAAAH,GAAUC,GAAGE,CAAU;AACvB,QAAMC,IAAU,KAAK,KAAKD,IAAaF,CAAC,IAAI,GACtCI,IAAa,MAAMJ,IAAI,IACvBK,IAAY,KAAKL,GACjBM,IAAO/H,GAAQyH,CAAC,GAChBO,IAAU,OAAOP,CAAC;AACxB,SAAO,EAAE,SAAAG,GAAS,YAAAC,GAAY,MAAAE,GAAM,WAAAD,GAAW,SAAAE,EAAO;AAC1D;AACA,SAASC,GAAYxS,GAAGyS,GAAQC,GAAO;AACnC,QAAM,EAAE,YAAAN,GAAY,MAAAE,GAAM,WAAAD,GAAW,SAAAE,EAAO,IAAKG;AACjD,MAAIC,IAAQ,OAAO3S,IAAIsS,CAAI,GACvBM,IAAQ5S,KAAKuS;AAMjB,EAAII,IAAQP,MAERO,KAASN,GACTO,KAASpJ;AAEb,QAAMqJ,IAAcJ,IAASL,GACvBnL,IAAS4L,IAAc,KAAK,IAAIF,CAAK,IAAI,GACzCG,IAASH,MAAU,GACnBI,IAAQJ,IAAQ,GAChBK,IAASP,IAAS,MAAM;AAE9B,SAAO,EAAE,OAAAG,GAAO,QAAA3L,GAAQ,QAAA6L,GAAQ,OAAAC,GAAO,QAAAC,GAAQ,SAD/BH,EACsC;AAC1D;AAoBA,MAAMI,KAAmB,oBAAI,QAAO,GAC9BC,KAAmB,oBAAI,QAAO;AACpC,SAASC,GAAK5F,GAAG;AAGb,SAAO2F,GAAiB,IAAI3F,CAAC,KAAK;AACtC;AACA,SAAS6F,GAAQpT,GAAG;AAChB,MAAIA,MAAMuJ;AACN,UAAM,IAAI,MAAM,cAAc;AACtC;AAmBO,MAAM8J,GAAK;AAAA,EACd;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA,YAAYC,GAAOzX,GAAM;AACrB,SAAK,OAAOyX,EAAM,MAClB,KAAK,OAAOA,EAAM,MAClB,KAAK,KAAKA,EAAM,IAChB,KAAK,OAAOzX;AAAA,EAChB;AAAA;AAAA,EAEA,cAAc0X,GAAK,GAAG5D,IAAI,KAAK,MAAM;AACjC,QAAIC,IAAI2D;AACR,WAAO,IAAIhK;AACP,MAAI,IAAIC,OACJmG,IAAIA,EAAE,IAAIC,CAAC,IACfA,IAAIA,EAAE,OAAM,GACZ,MAAMpG;AAEV,WAAOmG;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,iBAAiB6D,GAAOxB,GAAG;AACvB,UAAM,EAAE,SAAAG,GAAS,YAAAC,EAAU,IAAKH,GAAUD,GAAG,KAAK,IAAI,GAChDH,IAAS,CAAA;AACf,QAAIlC,IAAI6D,GACJC,IAAO9D;AACX,aAAS8C,IAAS,GAAGA,IAASN,GAASM,KAAU;AAC7C,MAAAgB,IAAO9D,GACPkC,EAAO,KAAK4B,CAAI;AAEhB,eAASpY,IAAI,GAAGA,IAAI+W,GAAY/W;AAC5B,QAAAoY,IAAOA,EAAK,IAAI9D,CAAC,GACjBkC,EAAO,KAAK4B,CAAI;AAEpB,MAAA9D,IAAI8D,EAAK,OAAM;AAAA,IACnB;AACA,WAAO5B;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,KAAKG,GAAG0B,GAAa1T,GAAG;AAEpB,QAAI,CAAC,KAAK,GAAG,QAAQA,CAAC;AAClB,YAAM,IAAI,MAAM,gBAAgB;AAEpC,QAAI2P,IAAI,KAAK,MACTxE,IAAI,KAAK;AAMb,UAAMwI,IAAK1B,GAAUD,GAAG,KAAK,IAAI;AACjC,aAASS,IAAS,GAAGA,IAASkB,EAAG,SAASlB,KAAU;AAEhD,YAAM,EAAE,OAAAG,GAAO,QAAA3L,GAAQ,QAAA6L,GAAQ,OAAAC,GAAO,QAAAC,GAAQ,SAAAY,EAAO,IAAKpB,GAAYxS,GAAGyS,GAAQkB,CAAE;AACnF,MAAA3T,IAAI4S,GACAE,IAGA3H,IAAIA,EAAE,IAAIsG,GAASuB,GAAQU,EAAYE,CAAO,CAAC,CAAC,IAIhDjE,IAAIA,EAAE,IAAI8B,GAASsB,GAAOW,EAAYzM,CAAM,CAAC,CAAC;AAAA,IAEtD;AACA,WAAAmM,GAAQpT,CAAC,GAIF,EAAE,GAAA2P,GAAG,GAAAxE,EAAC;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW6G,GAAG0B,GAAa1T,GAAGkQ,IAAM,KAAK,MAAM;AAC3C,UAAMyD,IAAK1B,GAAUD,GAAG,KAAK,IAAI;AACjC,aAASS,IAAS,GAAGA,IAASkB,EAAG,WACzB3T,MAAMuJ,IAD4BkJ,KAAU;AAGhD,YAAM,EAAE,OAAAG,GAAO,QAAA3L,GAAQ,QAAA6L,GAAQ,OAAAC,EAAK,IAAKP,GAAYxS,GAAGyS,GAAQkB,CAAE;AAElE,UADA3T,IAAI4S,GACA,CAAAE,GAKC;AACD,cAAMpB,IAAOgC,EAAYzM,CAAM;AAC/B,QAAAiJ,IAAMA,EAAI,IAAI6C,IAAQrB,EAAK,OAAM,IAAKA,CAAI;AAAA,MAC9C;AAAA,IACJ;AACA,WAAA0B,GAAQpT,CAAC,GACFkQ;AAAA,EACX;AAAA,EACA,eAAe8B,GAAGwB,GAAOK,GAAW;AAEhC,QAAIC,IAAOb,GAAiB,IAAIO,CAAK;AACrC,WAAKM,MACDA,IAAO,KAAK,iBAAiBN,GAAOxB,CAAC,GACjCA,MAAM,MAEF,OAAO6B,KAAc,eACrBC,IAAOD,EAAUC,CAAI,IACzBb,GAAiB,IAAIO,GAAOM,CAAI,KAGjCA;AAAA,EACX;AAAA,EACA,OAAON,GAAOjC,GAAQsC,GAAW;AAC7B,UAAM7B,IAAImB,GAAKK,CAAK;AACpB,WAAO,KAAK,KAAKxB,GAAG,KAAK,eAAeA,GAAGwB,GAAOK,CAAS,GAAGtC,CAAM;AAAA,EACxE;AAAA,EACA,OAAOiC,GAAOjC,GAAQsC,GAAWE,GAAM;AACnC,UAAM/B,IAAImB,GAAKK,CAAK;AACpB,WAAIxB,MAAM,IACC,KAAK,cAAcwB,GAAOjC,GAAQwC,CAAI,IAC1C,KAAK,WAAW/B,GAAG,KAAK,eAAeA,GAAGwB,GAAOK,CAAS,GAAGtC,GAAQwC,CAAI;AAAA,EACpF;AAAA;AAAA;AAAA;AAAA,EAIA,YAAYxG,GAAGyE,GAAG;AACd,IAAAD,GAAUC,GAAG,KAAK,IAAI,GACtBkB,GAAiB,IAAI3F,GAAGyE,CAAC,GACzBiB,GAAiB,OAAO1F,CAAC;AAAA,EAC7B;AAAA,EACA,SAASgG,GAAK;AACV,WAAOJ,GAAKI,CAAG,MAAM;AAAA,EACzB;AACJ;AA8JA,SAASS,GAAYC,GAAOzE,GAAOpM,GAAM;AACrC,MAAIoM,GAAO;AACP,QAAIA,EAAM,UAAUyE;AAChB,YAAM,IAAI,MAAM,gDAAgD;AACpE,WAAA1E,GAAcC,CAAK,GACZA;AAAA,EACX;AAEI,WAAO/B,GAAMwG,GAAO,EAAE,MAAA7Q,GAAM;AAEpC;AAEO,SAAS8Q,GAAkBvY,GAAMwY,GAAOC,IAAY,CAAA,GAAIC,GAAQ;AAGnE,MAFIA,MAAW,WACXA,IAAS1Y,MAAS,YAClB,CAACwY,KAAS,OAAOA,KAAU;AAC3B,UAAM,IAAI,MAAM,kBAAkBxY,CAAI,eAAe;AACzD,aAAWgU,KAAK,CAAC,KAAK,KAAK,GAAG,GAAG;AAC7B,UAAM3E,IAAMmJ,EAAMxE,CAAC;AACnB,QAAI,EAAE,OAAO3E,KAAQ,YAAYA,IAAMzB;AACnC,YAAM,IAAI,MAAM,SAASoG,CAAC,0BAA0B;AAAA,EAC5D;AACA,QAAM3C,IAAKgH,GAAYG,EAAM,GAAGC,EAAU,IAAIC,CAAM,GAC9CC,IAAKN,GAAYG,EAAM,GAAGC,EAAU,IAAIC,CAAM,GAE9Cjb,IAAS,CAAC,MAAM,MAAM,KADc,GACP;AACnC,aAAWuW,KAAKvW;AAEZ,QAAI,CAAC4T,EAAG,QAAQmH,EAAMxE,CAAC,CAAC;AACpB,YAAM,IAAI,MAAM,SAASA,CAAC,0CAA0C;AAE5E,SAAAwE,IAAQ,OAAO,OAAO,OAAO,OAAO,CAAA,GAAIA,CAAK,CAAC,GACvC,EAAE,OAAAA,GAAO,IAAAnH,GAAI,IAAAsH,EAAE;AAC1B;AACO,SAASC,GAAaC,GAAiBC,GAAc;AACxD,SAAO,SAAgBC,GAAM;AACzB,UAAMC,IAAYH,EAAgBE,CAAI;AACtC,WAAO,EAAE,WAAAC,GAAW,WAAWF,EAAaE,CAAS,EAAC;AAAA,EAC1D;AACJ;AC3bA,MAAMpL,IAAM,OAAO,CAAC,GAAGC,IAAM,OAAO,CAAC,GAAGoC,KAAM,OAAO,CAAC,GAAGK,KAAM,OAAO,CAAC;AACvE,SAAS2I,GAAY5H,GAAImH,GAAOrX,GAAGM,GAAG;AAClC,QAAMyX,IAAK7H,EAAG,IAAIlQ,CAAC,GACbgY,IAAK9H,EAAG,IAAI5P,CAAC,GACb2X,IAAO/H,EAAG,IAAIA,EAAG,IAAImH,EAAM,GAAGU,CAAE,GAAGC,CAAE,GACrCE,IAAQhI,EAAG,IAAIA,EAAG,KAAKA,EAAG,IAAImH,EAAM,GAAGnH,EAAG,IAAI6H,GAAIC,CAAE,CAAC,CAAC;AAC5D,SAAO9H,EAAG,IAAI+H,GAAMC,CAAK;AAC7B;AACO,SAASC,GAAQ7b,GAAQ8b,IAAY,IAAI;AAC5C,QAAMC,IAAYjB,GAAkB,WAAW9a,GAAQ8b,GAAWA,EAAU,MAAM,GAC5E,EAAE,IAAAlI,GAAI,IAAAsH,EAAE,IAAKa;AACnB,MAAIhB,IAAQgB,EAAU;AACtB,QAAM,EAAE,GAAGC,EAAQ,IAAKjB;AACxB,EAAA3J,GAAe0K,GAAW,CAAA,GAAI,EAAE,SAAS,WAAU,CAAE;AAKrD,QAAMG,IAAOzJ,MAAQ,OAAO0I,EAAG,QAAQ,CAAC,IAAI9K,GACtC8L,IAAO,CAACtV,MAAMgN,EAAG,OAAOhN,CAAC,GAEzBuV,IAAUL,EAAU,YACrB,CAACvI,GAAGtB,MAAM;AACP,QAAI;AACA,aAAO,EAAE,SAAS,IAAM,OAAO2B,EAAG,KAAKA,EAAG,IAAIL,GAAGtB,CAAC,CAAC,EAAC;AAAA,IACxD,QACU;AACN,aAAO,EAAE,SAAS,IAAO,OAAO9B,EAAG;AAAA,IACvC;AAAA,EACJ;AAGJ,MAAI,CAACqL,GAAY5H,GAAImH,GAAOA,EAAM,IAAIA,EAAM,EAAE;AAC1C,UAAM,IAAI,MAAM,mCAAmC;AAKvD,WAASqB,EAAOvV,GAAOD,GAAGyV,IAAU,IAAO;AACvC,UAAM5U,IAAM4U,IAAUjM,IAAMD;AAC5B,WAAAe,GAAS,gBAAgBrK,GAAOD,GAAGa,GAAKwU,CAAI,GACrCrV;AAAA,EACX;AACA,WAAS0V,EAASC,GAAO;AACrB,QAAI,EAAEA,aAAiBrC;AACnB,YAAM,IAAI,MAAM,uBAAuB;AAAA,EAC/C;AAGA,QAAMsC,IAAetK,GAAS,CAACqE,GAAGkG,MAAO;AACrC,UAAM,EAAE,GAAAC,GAAG,GAAAC,GAAG,GAAAtH,EAAC,IAAKkB,GACdqG,IAAMrG,EAAE,IAAG;AACjB,IAAIkG,KAAM,SACNA,IAAKG,IAAM/J,KAAMe,EAAG,IAAIyB,CAAC;AAC7B,UAAM3R,IAAIwY,EAAKQ,IAAID,CAAE,GACfzY,IAAIkY,EAAKS,IAAIF,CAAE,GACfI,IAAKjJ,EAAG,IAAIyB,GAAGoH,CAAE;AACvB,QAAIG;AACA,aAAO,EAAE,GAAGzM,GAAK,GAAGC,EAAG;AAC3B,QAAIyM,MAAOzM;AACP,YAAM,IAAI,MAAM,kBAAkB;AACtC,WAAO,EAAE,GAAA1M,GAAG,GAAAM,EAAC;AAAA,EACjB,CAAC,GACK8Y,IAAkB5K,GAAS,CAACqE,MAAM;AACpC,UAAM,EAAE,GAAA7P,GAAG,GAAA8P,EAAC,IAAKuE;AACjB,QAAIxE,EAAE,IAAG;AACL,YAAM,IAAI,MAAM,iBAAiB;AAGrC,UAAM,EAAE,GAAAmG,GAAG,GAAAC,GAAG,GAAAtH,GAAG,GAAA0H,EAAC,IAAKxG,GACjByG,IAAKd,EAAKQ,IAAIA,CAAC,GACfO,IAAKf,EAAKS,IAAIA,CAAC,GACfO,IAAKhB,EAAK7G,IAAIA,CAAC,GACf8H,IAAKjB,EAAKgB,IAAKA,CAAE,GACjBE,IAAMlB,EAAKc,IAAKtW,CAAC,GACjBiV,IAAOO,EAAKgB,IAAKhB,EAAKkB,IAAMH,CAAE,CAAC,GAC/BrB,IAAQM,EAAKiB,IAAKjB,EAAK1F,IAAI0F,EAAKc,IAAKC,CAAE,CAAC,CAAC;AAC/C,QAAItB,MAASC;AACT,YAAM,IAAI,MAAM,uCAAuC;AAE3D,UAAMyB,IAAKnB,EAAKQ,IAAIC,CAAC,GACfW,IAAKpB,EAAK7G,IAAI0H,CAAC;AACrB,QAAIM,MAAOC;AACP,YAAM,IAAI,MAAM,uCAAuC;AAC3D,WAAO;AAAA,EACX,CAAC;AAAA,EAGD,MAAMpD,EAAM;AAAA;AAAA,IAER,OAAO,OAAO,IAAIA,EAAMa,EAAM,IAAIA,EAAM,IAAI3K,GAAK8L,EAAKnB,EAAM,KAAKA,EAAM,EAAE,CAAC;AAAA;AAAA,IAE1E,OAAO,OAAO,IAAIb,EAAM/J,GAAKC,GAAKA,GAAKD,CAAG;AAAA;AAAA;AAAA,IAE1C,OAAO,KAAKyD;AAAA;AAAA,IAEZ,OAAO,KAAKsH;AAAA,IACZ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,YAAYwB,GAAGC,GAAGtH,GAAG0H,GAAG;AACpB,WAAK,IAAIX,EAAO,KAAKM,CAAC,GACtB,KAAK,IAAIN,EAAO,KAAKO,CAAC,GACtB,KAAK,IAAIP,EAAO,KAAK/G,GAAG,EAAI,GAC5B,KAAK,IAAI+G,EAAO,KAAKW,CAAC,GACtB,OAAO,OAAO,IAAI;AAAA,IACtB;AAAA,IACA,OAAO,QAAQ;AACX,aAAOhC;AAAA,IACX;AAAA,IACA,OAAO,WAAWxE,GAAG;AACjB,UAAIA,aAAa2D;AACb,cAAM,IAAI,MAAM,4BAA4B;AAChD,YAAM,EAAE,GAAAxW,GAAG,GAAAM,EAAC,IAAKuS,KAAK,CAAA;AACtB,aAAA6F,EAAO,KAAK1Y,CAAC,GACb0Y,EAAO,KAAKpY,CAAC,GACN,IAAIkW,EAAMxW,GAAGM,GAAGoM,GAAK8L,EAAKxY,IAAIM,CAAC,CAAC;AAAA,IAC3C;AAAA;AAAA,IAEA,OAAO,UAAUf,GAAOsa,IAAS,IAAO;AACpC,YAAM1a,IAAM+Q,EAAG,OACT,EAAE,GAAAlN,GAAG,GAAA8P,EAAC,IAAKuE;AACjB,MAAA9X,IAAQ2N,GAAU7J,EAAO9D,GAAOJ,GAAK,OAAO,CAAC,GAC7CwN,GAAMkN,GAAQ,QAAQ;AACtB,YAAMC,IAAS5M,GAAU3N,CAAK,GACxBwa,IAAWxa,EAAMJ,IAAM,CAAC;AAC9B,MAAA2a,EAAO3a,IAAM,CAAC,IAAI4a,IAAW;AAC7B,YAAMzZ,IAAI2M,GAAgB6M,CAAM,GAK1B5X,IAAM2X,IAAStB,IAAOrI,EAAG;AAC/B,MAAA1C,GAAS,WAAWlN,GAAGmM,GAAKvK,CAAG;AAG/B,YAAM8V,IAAKQ,EAAKlY,IAAIA,CAAC,GACfuP,IAAI2I,EAAKR,IAAKtL,CAAG,GACjB6B,IAAIiK,EAAK1F,IAAIkF,IAAKhV,CAAC;AACzB,UAAI,EAAE,SAAAgX,GAAS,OAAOha,EAAC,IAAKyY,EAAQ5I,GAAGtB,CAAC;AACxC,UAAI,CAACyL;AACD,cAAM,IAAI,MAAM,iCAAiC;AACrD,YAAMC,KAAUja,IAAI0M,OAASA,GACvBwN,KAAiBH,IAAW,SAAU;AAC5C,UAAI,CAACF,KAAU7Z,MAAMyM,KAAOyN;AAExB,cAAM,IAAI,MAAM,0BAA0B;AAC9C,aAAIA,MAAkBD,MAClBja,IAAIwY,EAAK,CAACxY,CAAC,IACRwW,EAAM,WAAW,EAAE,GAAAxW,GAAG,GAAAM,EAAC,CAAE;AAAA,IACpC;AAAA,IACA,OAAO,QAAQ7B,GAAKob,IAAS,IAAO;AAChC,aAAOrD,EAAM,UAAU9R,GAAWjG,CAAG,GAAGob,CAAM;AAAA,IAClD;AAAA,IACA,IAAI,IAAI;AACJ,aAAO,KAAK,SAAQ,EAAG;AAAA,IAC3B;AAAA,IACA,IAAI,IAAI;AACJ,aAAO,KAAK,SAAQ,EAAG;AAAA,IAC3B;AAAA,IACA,WAAWvE,IAAa,GAAG6E,IAAS,IAAM;AACtC,aAAAC,EAAK,YAAY,MAAM9E,CAAU,GAC5B6E,KACD,KAAK,SAASrL,EAAG,GACd;AAAA,IACX;AAAA;AAAA,IAEA,iBAAiB;AACb,MAAAsK,EAAgB,IAAI;AAAA,IACxB;AAAA;AAAA,IAEA,OAAOP,GAAO;AACV,MAAAD,EAASC,CAAK;AACd,YAAM,EAAE,GAAGwB,GAAI,GAAGC,GAAI,GAAGC,EAAE,IAAK,MAC1B,EAAE,GAAGjB,GAAI,GAAGC,GAAI,GAAGC,EAAE,IAAKX,GAC1B2B,IAAOhC,EAAK6B,IAAKb,CAAE,GACnBiB,IAAOjC,EAAKc,IAAKiB,CAAE,GACnBG,IAAOlC,EAAK8B,IAAKd,CAAE,GACnBmB,IAAOnC,EAAKe,IAAKgB,CAAE;AACzB,aAAOC,MAASC,KAAQC,MAASC;AAAA,IACrC;AAAA,IACA,MAAM;AACF,aAAO,KAAK,OAAOnE,EAAM,IAAI;AAAA,IACjC;AAAA,IACA,SAAS;AAEL,aAAO,IAAIA,EAAMgC,EAAK,CAAC,KAAK,CAAC,GAAG,KAAK,GAAG,KAAK,GAAGA,EAAK,CAAC,KAAK,CAAC,CAAC;AAAA,IACjE;AAAA;AAAA;AAAA;AAAA,IAIA,SAAS;AACL,YAAM,EAAE,GAAAxV,EAAC,IAAKqU,GACR,EAAE,GAAGgD,GAAI,GAAGC,GAAI,GAAGC,EAAE,IAAK,MAC1BK,IAAIpC,EAAK6B,IAAKA,CAAE,GAChBQ,IAAIrC,EAAK8B,IAAKA,CAAE,GAChBQ,IAAItC,EAAK1J,KAAM0J,EAAK+B,IAAKA,CAAE,CAAC,GAC5BQ,IAAIvC,EAAKxV,IAAI4X,CAAC,GACdI,IAAOX,IAAKC,GACZW,IAAIzC,EAAKA,EAAKwC,IAAOA,CAAI,IAAIJ,IAAIC,CAAC,GAClCK,IAAIH,IAAIF,GACRM,IAAID,IAAIJ,GACRM,IAAIL,IAAIF,GACRQ,IAAK7C,EAAKyC,IAAIE,CAAC,GACfG,IAAK9C,EAAK0C,IAAIE,CAAC,GACfG,IAAK/C,EAAKyC,IAAIG,CAAC,GACfI,IAAKhD,EAAK2C,IAAID,CAAC;AACrB,aAAO,IAAI1E,EAAM6E,GAAIC,GAAIE,GAAID,CAAE;AAAA,IACnC;AAAA;AAAA;AAAA;AAAA,IAIA,IAAI1C,GAAO;AACP,MAAAD,EAASC,CAAK;AACd,YAAM,EAAE,GAAA7V,GAAG,GAAA8P,EAAC,IAAKuE,GACX,EAAE,GAAGgD,GAAI,GAAGC,GAAI,GAAGC,GAAI,GAAGkB,EAAE,IAAK,MACjC,EAAE,GAAGnC,GAAI,GAAGC,GAAI,GAAGC,GAAI,GAAGkC,EAAE,IAAK7C,GACjC+B,IAAIpC,EAAK6B,IAAKf,CAAE,GAChBuB,IAAIrC,EAAK8B,IAAKf,CAAE,GAChBuB,IAAItC,EAAKiD,IAAK3I,IAAI4I,CAAE,GACpBX,IAAIvC,EAAK+B,IAAKf,CAAE,GAChByB,IAAIzC,GAAM6B,IAAKC,MAAOhB,IAAKC,KAAMqB,IAAIC,CAAC,GACtCM,IAAIJ,IAAID,GACRI,IAAIH,IAAID,GACRM,IAAI5C,EAAKqC,IAAI7X,IAAI4X,CAAC,GAClBS,KAAK7C,EAAKyC,IAAIE,CAAC,GACfG,KAAK9C,EAAK0C,IAAIE,CAAC,GACfG,KAAK/C,EAAKyC,IAAIG,CAAC,GACfI,KAAKhD,EAAK2C,IAAID,CAAC;AACrB,aAAO,IAAI1E,EAAM6E,IAAIC,IAAIE,IAAID,EAAE;AAAA,IACnC;AAAA,IACA,SAAS1C,GAAO;AACZ,aAAO,KAAK,IAAIA,EAAM,OAAM,CAAE;AAAA,IAClC;AAAA;AAAA,IAEA,SAASpE,GAAQ;AAEb,UAAI,CAAC+C,EAAG,YAAY/C,CAAM;AACtB,cAAM,IAAI,MAAM,4CAA4C;AAChE,YAAM,EAAE,GAAA5B,GAAG,GAAAxE,MAAM+L,EAAK,OAAO,MAAM3F,GAAQ,CAAC5B,MAAMiC,GAAW0B,GAAO3D,CAAC,CAAC;AACtE,aAAOiC,GAAW0B,GAAO,CAAC3D,GAAGxE,CAAC,CAAC,EAAE,CAAC;AAAA,IACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,eAAeoG,GAAQrB,IAAMoD,EAAM,MAAM;AAErC,UAAI,CAACgB,EAAG,QAAQ/C,CAAM;AAClB,cAAM,IAAI,MAAM,4CAA4C;AAChE,aAAIA,MAAWhI,IACJ+J,EAAM,OACb,KAAK,SAAS/B,MAAW/H,IAClB,OACJ0N,EAAK,OAAO,MAAM3F,GAAQ,CAAC,MAAMK,GAAW0B,GAAO,CAAC,GAAGpD,CAAG;AAAA,IACrE;AAAA;AAAA;AAAA;AAAA;AAAA,IAKA,eAAe;AACX,aAAO,KAAK,eAAekF,CAAQ,EAAE,IAAG;AAAA,IAC5C;AAAA;AAAA;AAAA,IAGA,gBAAgB;AACZ,aAAO8B,EAAK,OAAO,MAAM/C,EAAM,CAAC,EAAE,IAAG;AAAA,IACzC;AAAA;AAAA;AAAA,IAGA,SAASsE,GAAW;AAChB,aAAO7C,EAAa,MAAM6C,CAAS;AAAA,IACvC;AAAA,IACA,gBAAgB;AACZ,aAAIrD,MAAa5L,IACN,OACJ,KAAK,eAAe4L,CAAQ;AAAA,IACvC;AAAA,IACA,UAAU;AACN,YAAM,EAAE,GAAAtY,GAAG,GAAAM,MAAM,KAAK,SAAQ,GAExBf,IAAQ2Q,EAAG,QAAQ5P,CAAC;AAG1B,aAAAf,EAAMA,EAAM,SAAS,CAAC,KAAKS,IAAI0M,IAAM,MAAO,GACrCnN;AAAA,IACX;AAAA,IACA,QAAQ;AACJ,aAAO+E,GAAW,KAAK,SAAS;AAAA,IACpC;AAAA,IACA,WAAW;AACP,aAAO,UAAU,KAAK,IAAG,IAAK,SAAS,KAAK,MAAK,CAAE;AAAA,IACvD;AAAA,EACR;AACI,QAAM8V,IAAO,IAAI7D,GAAKC,GAAOgB,EAAG,IAAI;AACpC,SAAAhB,EAAM,KAAK,WAAW,CAAC,GAChBA;AACX;AA8EO,SAASoF,GAAMpF,GAAOqF,GAAOC,IAAY,CAAA,GAAI;AAChD,MAAI,OAAOD,KAAU;AACjB,UAAM,IAAI,MAAM,mCAAmC;AACvD,EAAAnO,GAAeoO,GAAW,IAAI;AAAA,IAC1B,mBAAmB;AAAA,IACnB,aAAa;AAAA,IACb,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,YAAY;AAAA,EACpB,CAAK;AACD,QAAM,EAAE,SAAAC,EAAO,IAAKD,GACd,EAAE,MAAAE,GAAM,IAAA9L,GAAI,IAAAsH,EAAE,IAAKhB,GACnB3Q,IAAciW,EAAU,eAAeG,IACvCC,IAAoBJ,EAAU,sBAAsB,CAACvc,MAAUA,IAC/D4c,IAASL,EAAU,WACpB,CAAC9a,GAAMob,GAAKC,MAAW;AAEpB,QADA1P,GAAM0P,GAAQ,QAAQ,GAClBD,EAAI,UAAUC;AACd,YAAM,IAAI,MAAM,qCAAqC;AACzD,WAAOrb;AAAA,EACX;AAEJ,WAASsb,EAAQC,GAAM;AACnB,WAAO/E,EAAG,OAAOvK,GAAgBsP,CAAI,CAAC;AAAA,EAC1C;AAEA,WAASC,EAAiBxgB,GAAK;AAC3B,UAAMmD,IAAMsd,EAAQ;AACpBpZ,IAAAA,EAAOrH,GAAKygB,EAAQ,WAAW,WAAW;AAG1C,UAAMC,IAASrZ,EAAOwY,EAAM7f,CAAG,GAAG,IAAImD,GAAK,iBAAiB,GACtDwd,IAAOT,EAAkBQ,EAAO,MAAM,GAAGvd,CAAG,CAAC,GAC7CiE,IAASsZ,EAAO,MAAMvd,GAAK,IAAIA,CAAG,GAClCsV,IAAS6H,EAAQK,CAAI;AAC3B,WAAO,EAAE,MAAAA,GAAM,QAAAvZ,GAAQ,QAAAqR,EAAM;AAAA,EACjC;AAEA,WAASmI,EAAqB/E,GAAW;AACrC,UAAM,EAAE,MAAA8E,GAAM,QAAAvZ,GAAQ,QAAAqR,EAAM,IAAK+H,EAAiB3E,CAAS,GACrDnB,IAAQsF,EAAK,SAASvH,CAAM,GAC5BoI,IAAanG,EAAM,QAAO;AAChC,WAAO,EAAE,MAAAiG,GAAM,QAAAvZ,GAAQ,QAAAqR,GAAQ,OAAAiC,GAAO,YAAAmG,EAAU;AAAA,EACpD;AAEA,WAASlF,EAAaE,GAAW;AAC7B,WAAO+E,EAAqB/E,CAAS,EAAE;AAAA,EAC3C;AAEA,WAASiF,EAAmBC,IAAU,WAAW,GAAE,MAAOC,GAAM;AAC5D,UAAMtX,IAAMP,GAAY,GAAG6X,CAAI;AAC/B,WAAOV,EAAQT,EAAMM,EAAOzW,GAAKrC,EAAO0Z,GAAS,QAAW,SAAS,GAAG,CAAC,CAAChB,CAAO,CAAC,CAAC;AAAA,EACvF;AAEA,WAASkB,EAAKvX,GAAKmS,GAAWqF,IAAU,CAAA,GAAI;AACxC,IAAAxX,IAAMrC,EAAOqC,GAAK,QAAW,SAAS,GAClCqW,MACArW,IAAMqW,EAAQrW,CAAG;AACrB,UAAM,EAAE,QAAAtC,GAAQ,QAAAqR,GAAQ,YAAAoI,EAAU,IAAKD,EAAqB/E,CAAS,GAC/D9H,IAAI+M,EAAmBI,EAAQ,SAAS9Z,GAAQsC,CAAG,GACnD,IAAIsW,EAAK,SAASjM,CAAC,EAAE,QAAO,GAC5BzB,IAAIwO,EAAmBI,EAAQ,SAAS,GAAGL,GAAYnX,CAAG,GAC1DqC,IAAIyP,EAAG,OAAOzH,IAAIzB,IAAImG,CAAM;AAClC,QAAI,CAAC+C,EAAG,QAAQzP,CAAC;AACb,YAAM,IAAI,MAAM,wBAAwB;AAC5C,UAAMoV,IAAKhY,GAAY,GAAGqS,EAAG,QAAQzP,CAAC,CAAC;AACvC,WAAO1E,EAAO8Z,GAAIV,EAAQ,WAAW,QAAQ;AAAA,EACjD;AAEA,QAAMW,IAAa,EAAE,QAAQ,GAAI;AAKjC,WAASC,EAAOC,GAAK5X,GAAK6X,GAAWL,IAAUE,GAAY;AACvD,UAAM,EAAE,SAAAL,GAAS,QAAAlD,EAAM,IAAKqD,GACtB/d,IAAMsd,EAAQ;AACpB,IAAAa,IAAMja,EAAOia,GAAKne,GAAK,WAAW,GAClCuG,IAAMrC,EAAOqC,GAAK,QAAW,SAAS,GACtC6X,IAAYla,EAAOka,GAAWd,EAAQ,WAAW,WAAW,GACxD5C,MAAW,UACXlN,GAAMkN,GAAQ,QAAQ,GACtBkC,MACArW,IAAMqW,EAAQrW,CAAG;AACrB,UAAM8X,IAAMre,IAAM,GACZ4Q,IAAIuN,EAAI,SAAS,GAAGE,CAAG,GACvBzV,IAAIkF,GAAgBqQ,EAAI,SAASE,GAAKre,CAAG,CAAC;AAChD,QAAIyb,GAAGzI,GAAGsL;AACV,QAAI;AAIA,MAAA7C,IAAIpE,EAAM,UAAU+G,GAAW1D,CAAM,GACrC1H,IAAIqE,EAAM,UAAUzG,GAAG8J,CAAM,GAC7B4D,KAAKzB,EAAK,eAAejU,CAAC;AAAA,IAC9B,QACc;AACV,aAAO;AAAA,IACX;AACA,QAAI,CAAC8R,KAAUe,EAAE,aAAY;AACzB,aAAO;AACX,UAAMtM,KAAIwO,EAAmBC,GAAS5K,EAAE,QAAO,GAAIyI,EAAE,QAAO,GAAIlV,CAAG;AAInE,WAHYyM,EAAE,IAAIyI,EAAE,eAAetM,EAAC,CAAC,EAG1B,SAASmP,EAAE,EAAE,cAAa,EAAG,IAAG;AAAA,EAC/C;AACA,QAAMC,IAAQxN,EAAG,OACXuM,IAAU;AAAA,IACZ,WAAWiB;AAAA,IACX,WAAWA;AAAA,IACX,WAAW,IAAIA;AAAA,IACf,MAAMA;AAAA,EACd;AACI,WAAShG,EAAgBE,IAAO/R,EAAY4W,EAAQ,IAAI,GAAG;AACvD,WAAOpZ,EAAOuU,GAAM6E,EAAQ,MAAM,MAAM;AAAA,EAC5C;AACA,WAASkB,EAAiB3hB,GAAK;AAC3B,WAAO+G,GAAQ/G,CAAG,KAAKA,EAAI,WAAWwb,EAAG;AAAA,EAC7C;AACA,WAASoG,EAAiB5hB,GAAK6d,GAAQ;AACnC,QAAI;AACA,aAAO,CAAC,CAACrD,EAAM,UAAUxa,GAAK6d,CAAM;AAAA,IACxC,QACc;AACV,aAAO;AAAA,IACX;AAAA,EACJ;AACA,QAAMgE,IAAQ;AAAA,IACV,sBAAAjB;AAAA,IACA,iBAAAlF;AAAA,IACA,kBAAAiG;AAAA,IACA,kBAAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,aAAaL,GAAW;AACpB,YAAM,EAAE,GAAAjd,EAAC,IAAKkW,EAAM,UAAU+G,CAAS,GACjCre,IAAOud,EAAQ,WACfqB,IAAU5e,MAAS;AACzB,UAAI,CAAC4e,KAAW5e,MAAS;AACrB,cAAM,IAAI,MAAM,gCAAgC;AACpD,YAAM2Q,IAAIiO,IAAU5N,EAAG,IAAIxD,IAAMpM,GAAGoM,IAAMpM,CAAC,IAAI4P,EAAG,IAAI5P,IAAIoM,GAAKpM,IAAIoM,CAAG;AACtE,aAAOwD,EAAG,QAAQL,CAAC;AAAA,IACvB;AAAA,IACA,mBAAmBgI,GAAW;AAC1B,YAAM3Y,IAAOud,EAAQ;AACrBpZ,MAAAA,EAAOwU,GAAW3Y,CAAI;AACtB,YAAMwd,IAASb,EAAMhE,EAAU,SAAS,GAAG3Y,CAAI,CAAC;AAChD,aAAOgd,EAAkBQ,CAAM,EAAE,SAAS,GAAGxd,CAAI;AAAA,IACrD;AAAA,EACR;AACI,SAAO,OAAO,OAAO;AAAA,IACjB,QAAQuY,GAAaC,GAAiBC,CAAY;AAAA,IAClD,cAAAA;AAAA,IACA,MAAAsF;AAAA,IACA,QAAAI;AAAA,IACA,OAAAQ;AAAA,IACA,OAAArH;AAAA,IACA,SAAAiG;AAAA,EACR,CAAK;AACL;AC1hBK,MAAkC/P,KAAM,OAAO,CAAC,GAAGoC,KAAM,OAAO,CAAC,GAEhEG,KAAM,OAAO,CAAC,GAAGE,KAAM,OAAO,CAAC,GAE/B4O,KAAkB,OAAO,oEAAoE,GAI7FC,KAAwC;AAAA,EAC1C,GAAGD;AAAA,EACH,GAAG,OAAO,oEAAoE;AAAA,EAC9E,GAAG5O;AAAA,EACH,GAAG,OAAO,oEAAoE;AAAA,EAC9E,GAAG,OAAO,oEAAoE;AAAA,EAC9E,IAAI,OAAO,oEAAoE;AAAA,EAC/E,IAAI,OAAO,oEAAoE;AACnF;AACA,SAAS8O,GAAoBje,GAAG;AAE5B,QAAMke,IAAO,OAAO,EAAE,GAAGC,IAAO,OAAO,EAAE,GAAGC,IAAO,OAAO,EAAE,GAAGC,IAAO,OAAO,EAAE,GACzE5N,IAAIsN,IAEJO,IADMte,IAAIA,IAAKyQ,IACJzQ,IAAKyQ,GAChB8N,IAAM/O,EAAK8O,GAAIxP,IAAK2B,CAAC,IAAI6N,IAAM7N,GAC/B+N,IAAMhP,EAAK+O,GAAI7R,IAAK+D,CAAC,IAAIzQ,IAAKyQ,GAC9BgO,IAAOjP,EAAKgP,GAAIvP,IAAKwB,CAAC,IAAI+N,IAAM/N,GAChCiO,IAAOlP,EAAKiP,GAAKP,GAAMzN,CAAC,IAAIgO,IAAOhO,GACnCkO,IAAOnP,EAAKkP,GAAKP,GAAM1N,CAAC,IAAIiO,IAAOjO,GACnCmO,IAAOpP,EAAKmP,GAAKP,GAAM3N,CAAC,IAAIkO,IAAOlO,GACnCoO,IAAQrP,EAAKoP,GAAKP,GAAM5N,CAAC,IAAImO,IAAOnO,GACpCqO,IAAQtP,EAAKqP,GAAMR,GAAM5N,CAAC,IAAImO,IAAOnO,GACrCsO,IAAQvP,EAAKsP,GAAMZ,GAAMzN,CAAC,IAAIgO,IAAOhO;AAG3C,SAAO,EAAE,WAFUjB,EAAKuP,GAAMjQ,IAAK2B,CAAC,IAAIzQ,IAAKyQ,GAEzB,IAAA6N,EAAE;AAC1B;AACA,SAASpC,GAAkB3c,GAAO;AAG9B,SAAAA,EAAM,CAAC,KAAK,KAEZA,EAAM,EAAE,KAAK,KAEbA,EAAM,EAAE,KAAK,IACNA;AACX;AAGA,MAAMyf,KAAkC,uBAAO,+EAA+E;AAE9H,SAASvG,GAAQ5I,GAAGtB,GAAG;AACnB,QAAMkC,IAAIsN,IACJkB,IAAK3P,EAAIf,IAAIA,IAAIA,GAAGkC,CAAC,GACrByO,IAAK5P,EAAI2P,IAAKA,IAAK1Q,GAAGkC,CAAC,GAEvB0O,IAAMlB,GAAoBpO,IAAIqP,CAAE,EAAE;AACxC,MAAIlf,IAAIsP,EAAIO,IAAIoP,IAAKE,GAAK1O,CAAC;AAC3B,QAAM2O,IAAM9P,EAAIf,IAAIvO,IAAIA,GAAGyQ,CAAC,GACtB4O,IAAQrf,GACRsf,IAAQhQ,EAAItP,IAAIgf,IAAiBvO,CAAC,GAClC8O,IAAWH,MAAQvP,GACnB2P,IAAWJ,MAAQ9P,EAAI,CAACO,GAAGY,CAAC,GAC5BgP,IAASL,MAAQ9P,EAAI,CAACO,IAAImP,IAAiBvO,CAAC;AAClD,SAAI8O,MACAvf,IAAIqf,KACJG,KAAYC,OACZzf,IAAIsf,IACJ/M,GAAavS,GAAGyQ,CAAC,MACjBzQ,IAAIsP,EAAI,CAACtP,GAAGyQ,CAAC,IACV,EAAE,SAAS8O,KAAYC,GAAU,OAAOxf,EAAC;AACpD;AACA,MAAM0f,KAAgC,gBAAAvH,GAAQ6F,IAAe,EAAE,SAAAvF,GAAO,CAAE;AAQxE,SAASkH,GAAGha,GAAM;AACd,SAAOiW,GAAM8D,IAAelT,IAAQ,OAAO,OAAO,EAAE,mBAAA0P,MAAqBvW,CAAI,CAAC;AAClF;AAeO,MAAMia,KAA0B,gBAAAD,GAAG,EAAE;ACrGrC,SAAS5c,GAAQC,GAAG;AACvB,SAAOA,aAAa,cAAe,YAAY,OAAOA,CAAC,KAAKA,EAAE,YAAY,SAAS;AACvF;AAOO,SAASK,GAAOkM,MAAMkN,GAAS;AAClC,MAAI,CAAC1Z,GAAQwM,CAAC;AACV,UAAM,IAAI,MAAM,qBAAqB;AACzC,MAAIkN,EAAQ,SAAS,KAAK,CAACA,EAAQ,SAASlN,EAAE,MAAM;AAChD,UAAM,IAAI,MAAM,mCAAmCkN,IAAU,kBAAkBlN,EAAE,MAAM;AAC/F;AASO,SAAS5L,GAAQC,GAAUC,IAAgB,IAAM;AACpD,MAAID,EAAS;AACT,UAAM,IAAI,MAAM,kCAAkC;AACtD,MAAIC,KAAiBD,EAAS;AAC1B,UAAM,IAAI,MAAM,uCAAuC;AAC/D;AAEO,SAASE,GAAQpB,GAAKkB,GAAU;AACnC,EAAAP,GAAOX,CAAG;AACV,QAAMqB,IAAMH,EAAS;AACrB,MAAIlB,EAAI,SAASqB;AACb,UAAM,IAAI,MAAM,2DAA2DA,CAAG;AAEtF;AAUO,SAASC,MAASC,GAAQ;AAC7B,WAAS1F,IAAI,GAAGA,IAAI0F,EAAO,QAAQ1F;AAC/B,IAAA0F,EAAO1F,CAAC,EAAE,KAAK,CAAC;AAExB;AAEO,SAAS2F,GAAWlF,GAAK;AAC5B,SAAO,IAAI,SAASA,EAAI,QAAQA,EAAI,YAAYA,EAAI,UAAU;AAClE;AAEO,SAAS6gB,EAAKC,GAAMC,GAAO;AAC9B,SAAQD,KAAS,KAAKC,IAAWD,MAASC;AAC9C;AAgHO,SAASC,GAAY/hB,GAAK;AAC7B,MAAI,OAAOA,KAAQ;AACf,UAAM,IAAI,MAAM,iBAAiB;AACrC,SAAO,IAAI,WAAW,IAAI,YAAW,EAAG,OAAOA,CAAG,CAAC;AACvD;AAaO,SAASgiB,GAAQjf,GAAM;AAC1B,SAAI,OAAOA,KAAS,aAChBA,IAAOgf,GAAYhf,CAAI,IAC3BqC,GAAOrC,CAAI,GACJA;AACX;AAkCO,MAAMkf,GAAK;AAClB;AAEO,SAAS5a,GAAaC,GAAU;AACnC,QAAME,IAAQ,CAACC,MAAQH,EAAQ,EAAG,OAAO0a,GAAQva,CAAG,CAAC,EAAE,OAAM,GACvDE,IAAML,EAAQ;AACpB,SAAAE,EAAM,YAAYG,EAAI,WACtBH,EAAM,WAAWG,EAAI,UACrBH,EAAM,SAAS,MAAMF,EAAQ,GACtBE;AACX;ACnPO,SAAS0a,GAAa5Z,GAAM6Z,GAAY9c,GAAOgD,GAAM;AACxD,MAAI,OAAOC,EAAK,gBAAiB;AAC7B,WAAOA,EAAK,aAAa6Z,GAAY9c,GAAOgD,CAAI;AACpD,QAAMc,IAAO,OAAO,EAAE,GAChBiZ,IAAW,OAAO,UAAU,GAC5BC,IAAK,OAAQhd,KAAS8D,IAAQiZ,CAAQ,GACtCE,IAAK,OAAOjd,IAAQ+c,CAAQ,GAC5B1Y,IAAIrB,IAAO,IAAI,GACfsB,IAAItB,IAAO,IAAI;AACrB,EAAAC,EAAK,UAAU6Z,IAAazY,GAAG2Y,GAAIha,CAAI,GACvCC,EAAK,UAAU6Z,IAAaxY,GAAG2Y,GAAIja,CAAI;AAC3C;AAEO,SAASka,GAAIxd,GAAGuM,GAAG0C,GAAG;AACzB,SAAQjP,IAAIuM,IAAM,CAACvM,IAAIiP;AAC3B;AAEO,SAASwO,GAAIzd,GAAGuM,GAAG0C,GAAG;AACzB,SAAQjP,IAAIuM,IAAMvM,IAAIiP,IAAM1C,IAAI0C;AACpC;AAKO,MAAMrI,WAAesW,GAAK;AAAA,EAC7B,YAAY/Z,GAAUC,GAAWC,GAAWC,GAAM;AAC9C,UAAK,GACL,KAAK,WAAW,IAChB,KAAK,SAAS,GACd,KAAK,MAAM,GACX,KAAK,YAAY,IACjB,KAAK,WAAWH,GAChB,KAAK,YAAYC,GACjB,KAAK,YAAYC,GACjB,KAAK,OAAOC,GACZ,KAAK,SAAS,IAAI,WAAWH,CAAQ,GACrC,KAAK,OAAOjC,GAAW,KAAK,MAAM;AAAA,EACtC;AAAA,EACA,OAAOlD,GAAM;AACT,IAAA2C,GAAQ,IAAI,GACZ3C,IAAOif,GAAQjf,CAAI,GACnBqC,GAAOrC,CAAI;AACX,UAAM,EAAE,MAAAuF,GAAM,QAAAC,GAAQ,UAAAL,EAAQ,IAAK,MAC7BhH,IAAM6B,EAAK;AACjB,aAASyF,IAAM,GAAGA,IAAMtH,KAAM;AAC1B,YAAMuH,IAAO,KAAK,IAAIP,IAAW,KAAK,KAAKhH,IAAMsH,CAAG;AAEpD,UAAIC,MAASP,GAAU;AACnB,cAAMQ,IAAWzC,GAAWlD,CAAI;AAChC,eAAOmF,KAAYhH,IAAMsH,GAAKA,KAAON;AACjC,eAAK,QAAQQ,GAAUF,CAAG;AAC9B;AAAA,MACJ;AACA,MAAAD,EAAO,IAAIxF,EAAK,SAASyF,GAAKA,IAAMC,CAAI,GAAG,KAAK,GAAG,GACnD,KAAK,OAAOA,GACZD,KAAOC,GACH,KAAK,QAAQP,MACb,KAAK,QAAQI,GAAM,CAAC,GACpB,KAAK,MAAM;AAAA,IAEnB;AACA,gBAAK,UAAUvF,EAAK,QACpB,KAAK,WAAU,GACR;AAAA,EACX;AAAA,EACA,WAAW0B,GAAK;AACZ,IAAAiB,GAAQ,IAAI,GACZG,GAAQpB,GAAK,IAAI,GACjB,KAAK,WAAW;AAIhB,UAAM,EAAE,QAAA8D,GAAQ,MAAAD,GAAM,UAAAJ,GAAU,MAAAG,EAAI,IAAK;AACzC,QAAI,EAAE,KAAAG,EAAG,IAAK;AAEd,IAAAD,EAAOC,GAAK,IAAI,KAChBzC,GAAM,KAAK,OAAO,SAASyC,CAAG,CAAC,GAG3B,KAAK,YAAYN,IAAWM,MAC5B,KAAK,QAAQF,GAAM,CAAC,GACpBE,IAAM;AAGV,aAASlI,IAAIkI,GAAKlI,IAAI4H,GAAU5H;AAC5B,MAAAiI,EAAOjI,CAAC,IAAI;AAIhB,IAAA4hB,GAAa5Z,GAAMJ,IAAW,GAAG,OAAO,KAAK,SAAS,CAAC,GAAGG,CAAI,GAC9D,KAAK,QAAQC,GAAM,CAAC;AACpB,UAAMK,IAAQ1C,GAAWxB,CAAG,GACtBvD,IAAM,KAAK;AAEjB,QAAIA,IAAM;AACN,YAAM,IAAI,MAAM,6CAA6C;AACjE,UAAM0H,IAAS1H,IAAM,GACf2H,IAAQ,KAAK,IAAG;AACtB,QAAID,IAASC,EAAM;AACf,YAAM,IAAI,MAAM,oCAAoC;AACxD,aAASvI,IAAI,GAAGA,IAAIsI,GAAQtI;AACxB,MAAAqI,EAAM,UAAU,IAAIrI,GAAGuI,EAAMvI,CAAC,GAAG+H,CAAI;AAAA,EAC7C;AAAA,EACA,SAAS;AACL,UAAM,EAAE,QAAAE,GAAQ,WAAAJ,EAAS,IAAK;AAC9B,SAAK,WAAWI,CAAM;AACtB,UAAMpB,IAAMoB,EAAO,MAAM,GAAGJ,CAAS;AACrC,gBAAK,QAAO,GACLhB;AAAA,EACX;AAAA,EACA,WAAW2B,GAAI;AACX,IAAAA,MAAOA,IAAK,IAAI,KAAK,YAAW,IAChCA,EAAG,IAAI,GAAG,KAAK,IAAG,CAAE;AACpB,UAAM,EAAE,UAAAZ,GAAU,QAAAK,GAAQ,QAAAjD,GAAQ,UAAAyD,GAAU,WAAAC,GAAW,KAAAR,EAAG,IAAK;AAC/D,WAAAM,EAAG,YAAYE,GACfF,EAAG,WAAWC,GACdD,EAAG,SAASxD,GACZwD,EAAG,MAAMN,GACLlD,IAAS4C,KACTY,EAAG,OAAO,IAAIP,CAAM,GACjBO;AAAA,EACX;AAAA,EACA,QAAQ;AACJ,WAAO,KAAK,WAAU;AAAA,EAC1B;AACJ;AAMO,MAAM2Z,IAA4B,4BAAY,KAAK;AAAA,EACtD;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AACxF,CAAC,GC5HKC,KAA2B,4BAAY,KAAK;AAAA,EAC9C;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EACpF;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EACpF;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EACpF;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EACpF;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EACpF;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EACpF;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EACpF;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AACxF,CAAC,GAEKC,IAA2B,oBAAI,YAAY,EAAE;AAC5C,MAAMC,WAAejX,GAAO;AAAA,EAC/B,YAAYxD,IAAY,IAAI;AACxB,UAAM,IAAIA,GAAW,GAAG,EAAK,GAG7B,KAAK,IAAIsa,EAAU,CAAC,IAAI,GACxB,KAAK,IAAIA,EAAU,CAAC,IAAI,GACxB,KAAK,IAAIA,EAAU,CAAC,IAAI,GACxB,KAAK,IAAIA,EAAU,CAAC,IAAI,GACxB,KAAK,IAAIA,EAAU,CAAC,IAAI,GACxB,KAAK,IAAIA,EAAU,CAAC,IAAI,GACxB,KAAK,IAAIA,EAAU,CAAC,IAAI,GACxB,KAAK,IAAIA,EAAU,CAAC,IAAI;AAAA,EAC5B;AAAA,EACA,MAAM;AACF,UAAM,EAAE,GAAA9F,GAAG,GAAAC,GAAG,GAAAC,GAAG,GAAAC,GAAG,GAAAE,GAAG,GAAAE,GAAG,GAAAD,GAAG,GAAAE,EAAC,IAAK;AACnC,WAAO,CAACR,GAAGC,GAAGC,GAAGC,GAAGE,GAAGE,GAAGD,GAAGE,CAAC;AAAA,EAClC;AAAA;AAAA,EAEA,IAAIR,GAAGC,GAAGC,GAAGC,GAAGE,GAAGE,GAAGD,GAAGE,GAAG;AACxB,SAAK,IAAIR,IAAI,GACb,KAAK,IAAIC,IAAI,GACb,KAAK,IAAIC,IAAI,GACb,KAAK,IAAIC,IAAI,GACb,KAAK,IAAIE,IAAI,GACb,KAAK,IAAIE,IAAI,GACb,KAAK,IAAID,IAAI,GACb,KAAK,IAAIE,IAAI;AAAA,EACjB;AAAA,EACA,QAAQ7U,GAAM4D,GAAQ;AAElB,aAAS5L,IAAI,GAAGA,IAAI,IAAIA,KAAK4L,KAAU;AACnC,MAAAyW,EAASriB,CAAC,IAAIgI,EAAK,UAAU4D,GAAQ,EAAK;AAC9C,aAAS5L,IAAI,IAAIA,IAAI,IAAIA,KAAK;AAC1B,YAAMuiB,IAAMF,EAASriB,IAAI,EAAE,GACrBwiB,IAAKH,EAASriB,IAAI,CAAC,GACnByiB,IAAKnB,EAAKiB,GAAK,CAAC,IAAIjB,EAAKiB,GAAK,EAAE,IAAKA,MAAQ,GAC7CG,IAAKpB,EAAKkB,GAAI,EAAE,IAAIlB,EAAKkB,GAAI,EAAE,IAAKA,MAAO;AACjD,MAAAH,EAASriB,CAAC,IAAK0iB,IAAKL,EAASriB,IAAI,CAAC,IAAIyiB,IAAKJ,EAASriB,IAAI,EAAE,IAAK;AAAA,IACnE;AAEA,QAAI,EAAE,GAAAqc,GAAG,GAAAC,GAAG,GAAAC,GAAG,GAAAC,GAAG,GAAAE,GAAG,GAAAE,GAAG,GAAAD,GAAG,GAAAE,EAAC,IAAK;AACjC,aAAS7c,IAAI,GAAGA,IAAI,IAAIA,KAAK;AACzB,YAAM2iB,IAASrB,EAAK5E,GAAG,CAAC,IAAI4E,EAAK5E,GAAG,EAAE,IAAI4E,EAAK5E,GAAG,EAAE,GAC9CQ,IAAML,IAAI8F,IAASV,GAAIvF,GAAGE,GAAGD,CAAC,IAAIyF,GAASpiB,CAAC,IAAIqiB,EAASriB,CAAC,IAAK,GAE/Dmd,KADSmE,EAAKjF,GAAG,CAAC,IAAIiF,EAAKjF,GAAG,EAAE,IAAIiF,EAAKjF,GAAG,EAAE,KAC/B6F,GAAI7F,GAAGC,GAAGC,CAAC,IAAK;AACrC,MAAAM,IAAIF,GACJA,IAAIC,GACJA,IAAIF,GACJA,IAAKF,IAAIU,IAAM,GACfV,IAAID,GACJA,IAAID,GACJA,IAAID,GACJA,IAAKa,IAAKC,IAAM;AAAA,IACpB;AAEA,IAAAd,IAAKA,IAAI,KAAK,IAAK,GACnBC,IAAKA,IAAI,KAAK,IAAK,GACnBC,IAAKA,IAAI,KAAK,IAAK,GACnBC,IAAKA,IAAI,KAAK,IAAK,GACnBE,IAAKA,IAAI,KAAK,IAAK,GACnBE,IAAKA,IAAI,KAAK,IAAK,GACnBD,IAAKA,IAAI,KAAK,IAAK,GACnBE,IAAKA,IAAI,KAAK,IAAK,GACnB,KAAK,IAAIR,GAAGC,GAAGC,GAAGC,GAAGE,GAAGE,GAAGD,GAAGE,CAAC;AAAA,EACnC;AAAA,EACA,aAAa;AACT,IAAApX,GAAM4c,CAAQ;AAAA,EAClB;AAAA,EACA,UAAU;AACN,SAAK,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,GAC/B5c,GAAM,KAAK,MAAM;AAAA,EACrB;AACJ;AAgQY,MAACmd,KAAyB,gBAAA7b,GAAa,MAAM,IAAIub,GAAM,CAAE,GCvVxDM,KAASC,IC2BhBC,KAAkB;AAkCjB,SAASC,GAAsB1J,GAA2B;AAC/D,MAAIA,EAAK,WAAW;AAClB,UAAM,IAAI,MAAM,yCAAyCA,EAAK,MAAM,EAAE;AAKxE,QAAM2J,IAAeJ,GAAOvJ,CAAI,GAG1B2F,IAAYqC,GAAQ,aAAa2B,CAAY,GAI7C1J,IAAY,IAAI,WAAW,EAAE;AACnC,SAAAA,EAAU,IAAI0J,GAAc,CAAC,GAC7B1J,EAAU,IAAI0F,GAAW,EAAE,GAK3BiE,GAAUD,CAAY,GAEf,EAAE,WAAAhE,GAAW,WAAA1F,EAAA;AACtB;AAQO,SAAS4J,GAAqB7J,GAAwB;AAC3D,QAAM8J,IAAUJ,GAAsB1J,CAAI,GACpC2F,IAAYmE,EAAQ;AAG1B,SAAAF,GAAUE,EAAQ,SAAS,GAEpBnE;AACT;AAQO,SAASoE,GAAkBpE,GAA+B;AAC/D,MAAIA,EAAU,WAAW;AACvB,UAAM,IAAI,MAAM,+CAA+CA,EAAU,MAAM,EAAE;AAGnF,SAAOqE,GAAarE,CAAS;AAC/B;AAoFA,SAASqE,GAAariB,GAA2B;AAE/C,MAAIsiB,IAAQ;AACZ,WAAStjB,IAAI,GAAGA,IAAIgB,EAAM,UAAUA,EAAMhB,CAAC,MAAM,GAAGA;AAClD,IAAAsjB;AAIF,MAAIvjB,IAAM;AACV,WAASC,IAAI,GAAGA,IAAIgB,EAAM,QAAQhB;AAChC,IAAAD,IAAMA,IAAM,OAAO,OAAOiB,EAAMhB,CAAC,CAAC;AAIpC,MAAIN,IAAM;AACV,SAAOK,IAAM,MAAI;AACf,UAAMwjB,IAAY,OAAOxjB,IAAM,GAAG;AAClC,IAAAL,IAAMojB,GAAgBS,CAAS,IAAI7jB,GACnCK,IAAMA,IAAM;AAAA,EACd;AAGA,SAAO,IAAI,OAAOujB,CAAK,IAAI5jB;AAC7B;ACvNO,MAAM8jB,KAAmB,GAGnBC,KAAe;AAqBrB,SAASC,GAAYrK,GAA+B;AACzD,MAAIA,EAAK,WAAW;AAClB,UAAM,IAAI,MAAM,yCAAyCA,EAAK,MAAM,EAAE;AAIxE,QAAMsK,IAAUC,GAAgBvK,CAAI,GAG9B9W,IAASQ,GAAQ,MAAM4gB,GAASF,IAAcD,EAAgB;AAEpE,MAAIjhB,EAAO,WAAW;AACpB,UAAM,IAAI,MAAM,2BAA2BA,EAAO,MAAM,EAAE;AAK5D,QAAMshB,IAASC,GAAgBvhB,EAAO,CAAC,CAAC,GAClCwhB,IAASD,GAAgBvhB,EAAO,CAAC,CAAC,GAClCyhB,IAASF,GAAgBvhB,EAAO,CAAC,CAAC;AAExC,SAAO;AAAA,IACL,QAAQ0hB,GAAcJ,CAAM;AAAA,IAC5B,QAAQI,GAAcF,CAAM;AAAA,IAC5B,QAAQE,GAAcD,CAAM;AAAA,EAAA;AAEhC;AAcO,SAASE,GACdC,GACAC,GACAC,GACM;AAEN,QAAMC,IAAYC,GAAgBJ,CAAM,GAClCK,IAAYD,GAAgBH,CAAM;AAExC,MAAI;AAEF,UAAMT,IAAU5gB,GAAQ,QAAQ,CAACuhB,GAAWE,CAAS,CAAC,GAGhDnL,IAAOoL,GAAgBd,CAAO;AAEpC,QAAItK,EAAK,WAAW;AAClB,YAAM,IAAI,MAAM,wCAAwCA,EAAK,MAAM,EAAE;AA0BvE,WAvBkBqL,GAAOrL,CAAI;AAAA,EAwB/B,SAASsL,GAAK;AAOZ,UANIA,aAAe,SAASA,EAAI,QAAQ,WAAW,oBAAoB,KAGnEA,aAAe,SAASA,EAAI,QAAQ,WAAW,2BAA2B,KAG1EA,aAAe,SAASA,EAAI,QAAQ,WAAW,mCAAmC,IAC9EA,IAEF,IAAI,MAAM,wCAAwC;AAAA,EAC1D;AACF;AAyDA,SAASf,GAAgB5iB,GAA2B;AAClD,SAAO,MAAM,KAAKA,CAAK,EACpB,IAAI,CAACgQ,MAAMA,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAC1C,KAAK,EAAE;AACZ;AAMA,SAASyT,GAAgBvkB,GAAyB;AAEhD,MAAI,CAAC,iBAAiB,KAAKA,CAAG;AAC5B,UAAM,IAAI,MAAM,iDAAiD;AAGnE,MAAIA,EAAI,SAAS,MAAM;AACrB,UAAM,IAAI,MAAM,8BAA8BA,EAAI,MAAM,wBAAwB;AAElF,QAAMc,IAAQ,IAAI,WAAWd,EAAI,SAAS,CAAC;AAC3C,WAASF,IAAI,GAAGA,IAAIgB,EAAM,QAAQhB;AAChC,IAAAgB,EAAMhB,CAAC,IAAI,SAASE,EAAI,OAAOF,IAAI,GAAG,CAAC,GAAG,EAAE;AAE9C,SAAOgB;AACT;AAkBA,SAAS8iB,GAAgBc,GAA8B;AACrD,QAAMC,IAAQD,EAAS,SAAS,MAAM,GAChCE,IAAYD,IAAQ,MAAMD,IAAWA,GACrCG,IAAYN,GAAgBK,CAAS,GAErCzhB,IAAS,IAAI,WAAW,IAAI0hB,EAAU,MAAM;AAClD,SAAA1hB,EAAO,CAAC,IAAIwhB,IAAQ,IAAI,GACxBxhB,EAAO,IAAI0hB,GAAW,CAAC,GAChB1hB;AACT;AAoBA,SAASkhB,GAAgBvjB,GAA2B;AAClD,QAAMgkB,IAAYhkB,EAAM,CAAC;AAGzB,MAAIgkB,MAAc,KAAQA,MAAc,GAAM;AAC5C,UAAMC,IAASD,MAAc,GACvBD,IAAY/jB,EAAM,SAAS,CAAC,GAC5BkkB,IAAetB,GAAgBmB,CAAS,GACxCI,IAAYF,IAASC,EAAa,UAAU,CAAC,IAAIA;AAGvD,QAAI,YAAY,KAAKC,CAAS;AAC5B,aAAOA;AAAA,EAEX;AAIA,QAAMjlB,IAAM0jB,GAAgB5iB,CAAK;AACjC,SAAId,EAAI,WAAW,GAAG,KAAK,CAACA,EAAI,WAAW,IAAI,IACtCA,EAAI,UAAU,CAAC,IAEjBA;AACT;","x_google_ignoreList":[2,3,4,5,6,7,8,9,10,11,12,13,14,15]}