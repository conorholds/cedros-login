{"version":3,"file":"shamir-4DyQMJCk.cjs","sources":["../src/crypto/argon2WorkerClient.ts","../src/utils/cryptoShim.ts","../node_modules/secrets.js-grempe/secrets.js","../node_modules/@noble/curves/node_modules/@noble/hashes/utils.js","../node_modules/@noble/curves/node_modules/@noble/hashes/_md.js","../node_modules/@noble/curves/node_modules/@noble/hashes/_u64.js","../node_modules/@noble/curves/node_modules/@noble/hashes/sha2.js","../node_modules/@noble/curves/utils.js","../node_modules/@noble/curves/abstract/modular.js","../node_modules/@noble/curves/abstract/curve.js","../node_modules/@noble/curves/abstract/edwards.js","../node_modules/@noble/curves/ed25519.js","../node_modules/@noble/hashes/esm/utils.js","../node_modules/@noble/hashes/esm/_md.js","../node_modules/@noble/hashes/esm/sha2.js","../node_modules/@noble/hashes/esm/sha256.js","../src/crypto/solanaKeypair.ts","../src/crypto/shamir.ts"],"sourcesContent":["import { argon2Derive, validateKdfParams } from './argon2';\nimport type { Argon2Salt, EncryptionKey, KdfParams } from './types';\nimport { DEFAULT_KDF_PARAMS } from './types';\n\ntype PendingRequest = {\n  resolve: (key: EncryptionKey) => void;\n  reject: (error: Error) => void;\n};\n\ntype WorkerRequest = {\n  id: number;\n  password: string;\n  salt: Uint8Array;\n  params: KdfParams;\n};\n\ntype WorkerResponse = {\n  id: number;\n  key?: Uint8Array;\n  error?: string;\n};\n\nlet worker: Worker | null = null;\nlet nextId = 0;\nconst pending = new Map<number, PendingRequest>();\n\nfunction getWorker(): Worker | null {\n  if (typeof Worker === 'undefined') {\n    return null;\n  }\n\n  if (!worker) {\n    worker = new Worker(new URL('./argon2Worker.ts', import.meta.url), {\n      type: 'module',\n    });\n\n    worker.onmessage = (event: MessageEvent<WorkerResponse>) => {\n      const { id, key, error } = event.data;\n      const handlers = pending.get(id);\n      if (!handlers) return;\n      pending.delete(id);\n\n      if (error) {\n        handlers.reject(new Error(error));\n        return;\n      }\n\n      if (!key) {\n        handlers.reject(new Error('Argon2 worker returned no key'));\n        return;\n      }\n\n      handlers.resolve(key as EncryptionKey);\n    };\n\n    worker.onerror = (event) => {\n      const error = event instanceof ErrorEvent ? event.error : new Error('Argon2 worker error');\n      for (const handlers of pending.values()) {\n        handlers.reject(error instanceof Error ? error : new Error(String(error)));\n      }\n      pending.clear();\n      worker?.terminate();\n      worker = null;\n    };\n  }\n\n  return worker;\n}\n\n/**\n * Derive an encryption key from password using Argon2id in a Web Worker.\n *\n * Offloads CPU-intensive Argon2id KDF to a background thread to avoid\n * blocking the main thread. Falls back to synchronous derivation if\n * Web Workers are not available.\n *\n * @param password - User's password\n * @param salt - 16-byte random salt\n * @param params - KDF parameters (memory, iterations, parallelism)\n * @returns 32-byte encryption key\n *\n * @security **CALLER MUST WIPE RETURNED KEY AFTER USE**\n * The returned key contains sensitive cryptographic material.\n * Callers are responsible for wiping it when no longer needed:\n * ```ts\n * const key = await argon2DeriveInWorker(password, salt);\n * try {\n *   // use key for encryption/decryption\n * } finally {\n *   wipeBytes(key);\n * }\n * ```\n * Failure to wipe may leave key material in memory, vulnerable to memory\n * dump attacks.\n */\nexport async function argon2DeriveInWorker(\n  password: string,\n  salt: Argon2Salt,\n  params: KdfParams = DEFAULT_KDF_PARAMS\n): Promise<EncryptionKey> {\n  // S-8: Validate params before dispatching to worker.\n  // Extreme params would block the worker thread before rejection.\n  validateKdfParams(params);\n\n  const argonWorker = getWorker();\n  if (!argonWorker) {\n    return argon2Derive(password, salt, params);\n  }\n\n  return new Promise((resolve, reject) => {\n    const id = nextId++;\n    pending.set(id, { resolve, reject });\n\n    const payload: WorkerRequest = {\n      id,\n      password,\n      salt,\n      params,\n    };\n\n    argonWorker.postMessage(payload);\n  });\n}\n","/**\n * Shim for Node's `crypto` module.\n * Maps `require('crypto')` / `import 'crypto'` to Web Crypto API in the browser.\n * Used by vite.config.ts alias to support CJS dependencies that expect Node crypto.\n */\n\n// Re-export Web Crypto API\nexport default globalThis.crypto;\nexport const webcrypto = globalThis.crypto;\nexport const subtle = globalThis.crypto.subtle;\nexport const getRandomValues = globalThis.crypto.getRandomValues.bind(globalThis.crypto);\nexport const randomUUID = globalThis.crypto.randomUUID.bind(globalThis.crypto);\n","// @preserve author Alexander Stetsyuk\n// @preserve author Glenn Rempe <glenn@rempe.us>\n// @license MIT\n\n/*jslint passfail: false, bitwise: true, nomen: true, plusplus: true, todo: false, maxerr: 1000 */\n/*global define, require, module, exports, window, Uint32Array */\n\n// eslint : http://eslint.org/docs/configuring/\n/*eslint-env node, browser, jasmine */\n/*eslint no-underscore-dangle:0 */\n\n// UMD (Universal Module Definition)\n// Uses Node, AMD or browser globals to create a module. This module creates\n// a global even when AMD is used. This is useful if you have some scripts\n// that are loaded by an AMD loader, but they still want access to globals.\n// See : https://github.com/umdjs/umd\n// See : https://github.com/umdjs/umd/blob/master/returnExportsGlobal.js\n//\n;(function(root, factory) {\n    \"use strict\"\n\n    if (typeof define === \"function\" && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], function() {\n            /*eslint-disable no-return-assign */\n            return (root.secrets = factory())\n            /*eslint-enable no-return-assign */\n        })\n    } else if (typeof exports === \"object\") {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require(\"crypto\"))\n    } else {\n        // Browser globals (root is window)\n        root.secrets = factory(root.crypto)\n    }\n})(this, function(crypto) {\n    \"use strict\"\n\n    var defaults, config, preGenPadding, runCSPRNGTest, CSPRNGTypes\n\n    function reset() {\n        defaults = {\n            bits: 8, // default number of bits\n            radix: 16, // work with HEX by default\n            minBits: 3,\n            maxBits: 20, // this permits 1,048,575 shares, though going this high is NOT recommended in JS!\n            bytesPerChar: 2,\n            maxBytesPerChar: 6, // Math.pow(256,7) > Math.pow(2,53)\n\n            // Primitive polynomials (in decimal form) for Galois Fields GF(2^n), for 2 <= n <= 30\n            // The index of each term in the array corresponds to the n for that polynomial\n            // i.e. to get the polynomial for n=16, use primitivePolynomials[16]\n            primitivePolynomials: [\n                null,\n                null,\n                1,\n                3,\n                3,\n                5,\n                3,\n                3,\n                29,\n                17,\n                9,\n                5,\n                83,\n                27,\n                43,\n                3,\n                45,\n                9,\n                39,\n                39,\n                9,\n                5,\n                3,\n                33,\n                27,\n                9,\n                71,\n                39,\n                9,\n                5,\n                83\n            ]\n        }\n        config = {}\n        preGenPadding = new Array(1024).join(\"0\") // Pre-generate a string of 1024 0's for use by padLeft().\n        runCSPRNGTest = true\n\n        // WARNING : Never use 'testRandom' except for testing.\n        CSPRNGTypes = [\n            \"nodeCryptoRandomBytes\",\n            \"browserCryptoGetRandomValues\",\n            \"testRandom\"\n        ]\n    }\n\n    function isSetRNG() {\n        if (config && config.rng && typeof config.rng === \"function\") {\n            return true\n        }\n\n        return false\n    }\n\n    // Pads a string `str` with zeros on the left so that its length is a multiple of `bits`\n    function padLeft(str, multipleOfBits) {\n        var missing\n\n        if (multipleOfBits === 0 || multipleOfBits === 1) {\n            return str\n        }\n\n        if (multipleOfBits && multipleOfBits > 1024) {\n            throw new Error(\n                \"Padding must be multiples of no larger than 1024 bits.\"\n            )\n        }\n\n        multipleOfBits = multipleOfBits || config.bits\n\n        if (str) {\n            missing = str.length % multipleOfBits\n        }\n\n        if (missing) {\n            return (preGenPadding + str).slice(\n                -(multipleOfBits - missing + str.length)\n            )\n        }\n\n        return str\n    }\n\n    function hex2bin(str) {\n        var bin = \"\",\n            num,\n            i\n\n        for (i = str.length - 1; i >= 0; i--) {\n            num = parseInt(str[i], 16)\n\n            if (isNaN(num)) {\n                throw new Error(\"Invalid hex character.\")\n            }\n\n            bin = padLeft(num.toString(2), 4) + bin\n        }\n        return bin\n    }\n\n    function bin2hex(str) {\n        var hex = \"\",\n            num,\n            i\n\n        str = padLeft(str, 4)\n\n        for (i = str.length; i >= 4; i -= 4) {\n            num = parseInt(str.slice(i - 4, i), 2)\n            if (isNaN(num)) {\n                throw new Error(\"Invalid binary character.\")\n            }\n            hex = num.toString(16) + hex\n        }\n\n        return hex\n    }\n\n    // Browser supports crypto.getRandomValues()\n    function hasCryptoGetRandomValues() {\n        if (\n            crypto &&\n            typeof crypto === \"object\" &&\n            (typeof crypto.getRandomValues === \"function\" ||\n                typeof crypto.getRandomValues === \"object\") &&\n            (typeof Uint32Array === \"function\" ||\n                typeof Uint32Array === \"object\")\n        ) {\n            return true\n        }\n\n        return false\n    }\n\n    // Node.js support for crypto.randomBytes()\n    function hasCryptoRandomBytes() {\n        if (\n            typeof crypto === \"object\" &&\n            typeof crypto.randomBytes === \"function\"\n        ) {\n            return true\n        }\n\n        return false\n    }\n\n    // Returns a pseudo-random number generator of the form function(bits){}\n    // which should output a random string of 1's and 0's of length `bits`.\n    // `type` (Optional) : A string representing the CSPRNG that you want to\n    // force to be loaded, overriding feature detection. Can be one of:\n    //    \"nodeCryptoRandomBytes\"\n    //    \"browserCryptoGetRandomValues\"\n    //\n    function getRNG(type) {\n        function construct(bits, arr, radix, size) {\n            var i = 0,\n                len,\n                str = \"\",\n                parsedInt\n\n            if (arr) {\n                len = arr.length - 1\n            }\n\n            while (i < len || str.length < bits) {\n                // convert any negative nums to positive with Math.abs()\n                parsedInt = Math.abs(parseInt(arr[i], radix))\n                str = str + padLeft(parsedInt.toString(2), size)\n                i++\n            }\n\n            str = str.substr(-bits)\n\n            // return null so this result can be re-processed if the result is all 0's.\n            if ((str.match(/0/g) || []).length === str.length) {\n                return null\n            }\n\n            return str\n        }\n\n        // Node.js : crypto.randomBytes()\n        // Note : Node.js and crypto.randomBytes() uses the OpenSSL RAND_bytes() function for its CSPRNG.\n        //        Node.js will need to have been compiled with OpenSSL for this to work.\n        // See : https://github.com/joyent/node/blob/d8baf8a2a4481940bfed0196308ae6189ca18eee/src/node_crypto.cc#L4696\n        // See : https://www.openssl.org/docs/crypto/rand.html\n        function nodeCryptoRandomBytes(bits) {\n            var buf,\n                bytes,\n                radix,\n                size,\n                str = null\n\n            radix = 16\n            size = 4\n            bytes = Math.ceil(bits / 8)\n\n            while (str === null) {\n                buf = crypto.randomBytes(bytes)\n                str = construct(bits, buf.toString(\"hex\"), radix, size)\n            }\n\n            return str\n        }\n\n        // Browser : crypto.getRandomValues()\n        // See : https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-Crypto\n        // See : https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues\n        // Supported Browsers : http://caniuse.com/#search=crypto.getRandomValues\n        function browserCryptoGetRandomValues(bits) {\n            var elems,\n                radix,\n                size,\n                str = null\n\n            radix = 10\n            size = 32\n            elems = Math.ceil(bits / 32)\n            while (str === null) {\n                str = construct(\n                    bits,\n                    crypto.getRandomValues(new Uint32Array(elems)),\n                    radix,\n                    size\n                )\n            }\n\n            return str\n        }\n\n        // /////////////////////////////////////////////////////////////\n        // WARNING : DO NOT USE. For testing purposes only.\n        // /////////////////////////////////////////////////////////////\n        // This function will return repeatable non-random test bits. Can be used\n        // for testing only. Node.js does not return proper random bytes\n        // when run within a PhantomJS container.\n        function testRandom(bits) {\n            var arr,\n                elems,\n                int,\n                radix,\n                size,\n                str = null\n\n            radix = 10\n            size = 32\n            elems = Math.ceil(bits / 32)\n            int = 123456789\n            arr = new Uint32Array(elems)\n\n            // Fill every element of the Uint32Array with the same int.\n            for (var i = 0; i < arr.length; i++) {\n                arr[i] = int\n            }\n\n            while (str === null) {\n                str = construct(bits, arr, radix, size)\n            }\n\n            return str\n        }\n\n        // Return a random generator function for browsers that support\n        // crypto.getRandomValues() or Node.js compiled with OpenSSL support.\n        // WARNING : NEVER use testRandom outside of a testing context. Totally non-random!\n        if (type && type === \"testRandom\") {\n            config.typeCSPRNG = type\n            return testRandom\n        } else if (type && type === \"nodeCryptoRandomBytes\") {\n            config.typeCSPRNG = type\n            return nodeCryptoRandomBytes\n        } else if (type && type === \"browserCryptoGetRandomValues\") {\n            config.typeCSPRNG = type\n            return browserCryptoGetRandomValues\n        } else if (hasCryptoRandomBytes()) {\n            config.typeCSPRNG = \"nodeCryptoRandomBytes\"\n            return nodeCryptoRandomBytes\n        } else if (hasCryptoGetRandomValues()) {\n            config.typeCSPRNG = \"browserCryptoGetRandomValues\"\n            return browserCryptoGetRandomValues\n        }\n    }\n\n    // Splits a number string `bits`-length segments, after first\n    // optionally zero-padding it to a length that is a multiple of `padLength.\n    // Returns array of integers (each less than 2^bits-1), with each element\n    // representing a `bits`-length segment of the input string from right to left,\n    // i.e. parts[0] represents the right-most `bits`-length segment of the input string.\n    function splitNumStringToIntArray(str, padLength) {\n        var parts = [],\n            i\n\n        if (padLength) {\n            str = padLeft(str, padLength)\n        }\n\n        for (i = str.length; i > config.bits; i -= config.bits) {\n            parts.push(parseInt(str.slice(i - config.bits, i), 2))\n        }\n\n        parts.push(parseInt(str.slice(0, i), 2))\n\n        return parts\n    }\n\n    // Polynomial evaluation at `x` using Horner's Method\n    // NOTE: fx=fx * x + coeff[i] ->  exp(log(fx) + log(x)) + coeff[i],\n    //       so if fx===0, just set fx to coeff[i] because\n    //       using the exp/log form will result in incorrect value\n    function horner(x, coeffs) {\n        var logx = config.logs[x],\n            fx = 0,\n            i\n\n        for (i = coeffs.length - 1; i >= 0; i--) {\n            if (fx !== 0) {\n                fx =\n                    config.exps[(logx + config.logs[fx]) % config.maxShares] ^\n                    coeffs[i]\n            } else {\n                fx = coeffs[i]\n            }\n        }\n\n        return fx\n    }\n\n    // Evaluate the Lagrange interpolation polynomial at x = `at`\n    // using x and y Arrays that are of the same length, with\n    // corresponding elements constituting points on the polynomial.\n    function lagrange(at, x, y) {\n        var sum = 0,\n            len,\n            product,\n            i,\n            j\n\n        for (i = 0, len = x.length; i < len; i++) {\n            if (y[i]) {\n                product = config.logs[y[i]]\n\n                for (j = 0; j < len; j++) {\n                    if (i !== j) {\n                        if (at === x[j]) {\n                            // happens when computing a share that is in the list of shares used to compute it\n                            product = -1 // fix for a zero product term, after which the sum should be sum^0 = sum, not sum^1\n                            break\n                        }\n                        product =\n                            (product +\n                                config.logs[at ^ x[j]] -\n                                config.logs[x[i] ^ x[j]] +\n                                config.maxShares) %\n                            config.maxShares // to make sure it's not negative\n                    }\n                }\n\n                // though exps[-1] === undefined and undefined ^ anything = anything in\n                // chrome, this behavior may not hold everywhere, so do the check\n                sum = product === -1 ? sum : sum ^ config.exps[product]\n            }\n        }\n\n        return sum\n    }\n\n    // This is the basic polynomial generation and evaluation function\n    // for a `config.bits`-length secret (NOT an arbitrary length)\n    // Note: no error-checking at this stage! If `secret` is NOT\n    // a NUMBER less than 2^bits-1, the output will be incorrect!\n    function getShares(secret, numShares, threshold) {\n        var shares = [],\n            coeffs = [secret],\n            i,\n            len\n\n        for (i = 1; i < threshold; i++) {\n            coeffs[i] = parseInt(config.rng(config.bits), 2)\n        }\n\n        for (i = 1, len = numShares + 1; i < len; i++) {\n            shares[i - 1] = {\n                x: i,\n                y: horner(i, coeffs)\n            }\n        }\n\n        return shares\n    }\n\n    function constructPublicShareString(bits, id, data) {\n        var bitsBase36, idHex, idMax, idPaddingLen, newShareString\n\n        id = parseInt(id, config.radix)\n        bits = parseInt(bits, 10) || config.bits\n        bitsBase36 = bits.toString(36).toUpperCase()\n        idMax = Math.pow(2, bits) - 1\n        idPaddingLen = idMax.toString(config.radix).length\n        idHex = padLeft(id.toString(config.radix), idPaddingLen)\n\n        if (typeof id !== \"number\" || id % 1 !== 0 || id < 1 || id > idMax) {\n            throw new Error(\n                \"Share id must be an integer between 1 and \" +\n                    idMax +\n                    \", inclusive.\"\n            )\n        }\n\n        newShareString = bitsBase36 + idHex + data\n\n        return newShareString\n    }\n\n    // EXPORTED FUNCTIONS\n    // //////////////////\n\n    var secrets = {\n        init: function(bits, rngType) {\n            var logs = [],\n                exps = [],\n                x = 1,\n                primitive,\n                i\n\n            // reset all config back to initial state\n            reset()\n\n            if (\n                bits &&\n                (typeof bits !== \"number\" ||\n                    bits % 1 !== 0 ||\n                    bits < defaults.minBits ||\n                    bits > defaults.maxBits)\n            ) {\n                throw new Error(\n                    \"Number of bits must be an integer between \" +\n                        defaults.minBits +\n                        \" and \" +\n                        defaults.maxBits +\n                        \", inclusive.\"\n                )\n            }\n\n            if (rngType && CSPRNGTypes.indexOf(rngType) === -1) {\n                throw new Error(\"Invalid RNG type argument : '\" + rngType + \"'\")\n            }\n\n            config.radix = defaults.radix\n            config.bits = bits || defaults.bits\n            config.size = Math.pow(2, config.bits)\n            config.maxShares = config.size - 1\n\n            // Construct the exp and log tables for multiplication.\n            primitive = defaults.primitivePolynomials[config.bits]\n\n            for (i = 0; i < config.size; i++) {\n                exps[i] = x\n                logs[x] = i\n                x = x << 1 // Left shift assignment\n                if (x >= config.size) {\n                    x = x ^ primitive // Bitwise XOR assignment\n                    x = x & config.maxShares // Bitwise AND assignment\n                }\n            }\n\n            config.logs = logs\n            config.exps = exps\n\n            if (rngType) {\n                this.setRNG(rngType)\n            }\n\n            if (!isSetRNG()) {\n                this.setRNG()\n            }\n\n            if (\n                !isSetRNG() ||\n                !config.bits ||\n                !config.size ||\n                !config.maxShares ||\n                !config.logs ||\n                !config.exps ||\n                config.logs.length !== config.size ||\n                config.exps.length !== config.size\n            ) {\n                throw new Error(\"Initialization failed.\")\n            }\n        },\n\n        // Evaluates the Lagrange interpolation polynomial at x=`at` for\n        // individual config.bits-length segments of each share in the `shares`\n        // Array. Each share is expressed in base `inputRadix`. The output\n        // is expressed in base `outputRadix'.\n        combine: function(shares, at) {\n            var i,\n                j,\n                len,\n                len2,\n                result = \"\",\n                setBits,\n                share,\n                splitShare,\n                x = [],\n                y = []\n\n            at = at || 0\n\n            for (i = 0, len = shares.length; i < len; i++) {\n                share = this.extractShareComponents(shares[i])\n\n                // All shares must have the same bits settings.\n                if (setBits === undefined) {\n                    setBits = share.bits\n                } else if (share.bits !== setBits) {\n                    throw new Error(\n                        \"Mismatched shares: Different bit settings.\"\n                    )\n                }\n\n                // Reset everything to the bit settings of the shares.\n                if (config.bits !== setBits) {\n                    this.init(setBits)\n                }\n\n                // Proceed if this share.id is not already in the Array 'x' and\n                // then split each share's hex data into an Array of Integers,\n                // then 'rotate' those arrays where the first element of each row is converted to\n                // its own array, the second element of each to its own Array, and so on for all of the rest.\n                // Essentially zipping all of the shares together.\n                //\n                // e.g.\n                //   [ 193, 186, 29, 150, 5, 120, 44, 46, 49, 59, 6, 1, 102, 98, 177, 196 ]\n                //   [ 53, 105, 139, 49, 187, 240, 91, 92, 98, 118, 12, 2, 204, 196, 127, 149 ]\n                //   [ 146, 211, 249, 167, 209, 136, 118, 114, 83, 77, 10, 3, 170, 166, 206, 81 ]\n                //\n                // becomes:\n                //\n                // [ [ 193, 53, 146 ],\n                //   [ 186, 105, 211 ],\n                //   [ 29, 139, 249 ],\n                //   [ 150, 49, 167 ],\n                //   [ 5, 187, 209 ],\n                //   [ 120, 240, 136 ],\n                //   [ 44, 91, 118 ],\n                //   [ 46, 92, 114 ],\n                //   [ 49, 98, 83 ],\n                //   [ 59, 118, 77 ],\n                //   [ 6, 12, 10 ],\n                //   [ 1, 2, 3 ],\n                //   [ 102, 204, 170 ],\n                //   [ 98, 196, 166 ],\n                //   [ 177, 127, 206 ],\n                //   [ 196, 149, 81 ] ]\n                //\n                if (x.indexOf(share.id) === -1) {\n                    x.push(share.id)\n                    splitShare = splitNumStringToIntArray(hex2bin(share.data))\n                    for (j = 0, len2 = splitShare.length; j < len2; j++) {\n                        y[j] = y[j] || []\n                        y[j][x.length - 1] = splitShare[j]\n                    }\n                }\n            }\n\n            // Extract the secret from the 'rotated' share data and return a\n            // string of Binary digits which represent the secret directly. or in the\n            // case of a newShare() return the binary string representing just that\n            // new share.\n            for (i = 0, len = y.length; i < len; i++) {\n                result = padLeft(lagrange(at, x, y[i]).toString(2)) + result\n            }\n\n            // If 'at' is non-zero combine() was called from newShare(). In this\n            // case return the result (the new share data) directly.\n            //\n            // Otherwise find the first '1' which was added in the share() function as a padding marker\n            // and return only the data after the padding and the marker. Convert this Binary string\n            // to hex, which represents the final secret result (which can be converted from hex back\n            // to the original string in user space using `hex2str()`).\n            return bin2hex(\n                at >= 1 ? result : result.slice(result.indexOf(\"1\") + 1)\n            )\n        },\n\n        getConfig: function() {\n            var obj = {}\n            obj.radix = config.radix\n            obj.bits = config.bits\n            obj.maxShares = config.maxShares\n            obj.hasCSPRNG = isSetRNG()\n            obj.typeCSPRNG = config.typeCSPRNG\n            return obj\n        },\n\n        // Given a public share, extract the bits (Integer), share ID (Integer), and share data (Hex)\n        // and return an Object containing those components.\n        extractShareComponents: function(share) {\n            var bits,\n                id,\n                idLen,\n                max,\n                obj = {},\n                regexStr,\n                shareComponents\n\n            // Extract the first char which represents the bits in Base 36\n            bits = parseInt(share.substr(0, 1), 36)\n\n            if (\n                bits &&\n                (typeof bits !== \"number\" ||\n                    bits % 1 !== 0 ||\n                    bits < defaults.minBits ||\n                    bits > defaults.maxBits)\n            ) {\n                throw new Error(\n                    \"Invalid share : Number of bits must be an integer between \" +\n                        defaults.minBits +\n                        \" and \" +\n                        defaults.maxBits +\n                        \", inclusive.\"\n                )\n            }\n\n            // calc the max shares allowed for given bits\n            max = Math.pow(2, bits) - 1\n\n            // Determine the ID length which is variable and based on the bit count.\n            idLen = (Math.pow(2, bits) - 1).toString(config.radix).length\n\n            // Extract all the parts now that the segment sizes are known.\n            regexStr =\n                \"^([a-kA-K3-9]{1})([a-fA-F0-9]{\" + idLen + \"})([a-fA-F0-9]+)$\"\n            shareComponents = new RegExp(regexStr).exec(share)\n\n            // The ID is a Hex number and needs to be converted to an Integer\n            if (shareComponents) {\n                id = parseInt(shareComponents[2], config.radix)\n            }\n\n            if (typeof id !== \"number\" || id % 1 !== 0 || id < 1 || id > max) {\n                throw new Error(\n                    \"Invalid share : Share id must be an integer between 1 and \" +\n                        config.maxShares +\n                        \", inclusive.\"\n                )\n            }\n\n            if (shareComponents && shareComponents[3]) {\n                obj.bits = bits\n                obj.id = id\n                obj.data = shareComponents[3]\n                return obj\n            }\n\n            throw new Error(\"The share data provided is invalid : \" + share)\n        },\n\n        // Set the PRNG to use. If no RNG function is supplied, pick a default using getRNG()\n        setRNG: function(rng) {\n            var errPrefix = \"Random number generator is invalid \",\n                errSuffix =\n                    \" Supply an CSPRNG of the form function(bits){} that returns a string containing 'bits' number of random 1's and 0's.\"\n\n            if (\n                rng &&\n                typeof rng === \"string\" &&\n                CSPRNGTypes.indexOf(rng) === -1\n            ) {\n                throw new Error(\"Invalid RNG type argument : '\" + rng + \"'\")\n            }\n\n            // If RNG was not specified at all,\n            // try to pick one appropriate for this env.\n            if (!rng) {\n                rng = getRNG()\n            }\n\n            // If `rng` is a string, try to forcibly\n            // set the RNG to the type specified.\n            if (rng && typeof rng === \"string\") {\n                rng = getRNG(rng)\n            }\n\n            if (runCSPRNGTest) {\n                if (rng && typeof rng !== \"function\") {\n                    throw new Error(errPrefix + \"(Not a function).\" + errSuffix)\n                }\n\n                if (rng && typeof rng(config.bits) !== \"string\") {\n                    throw new Error(\n                        errPrefix + \"(Output is not a string).\" + errSuffix\n                    )\n                }\n\n                if (rng && !parseInt(rng(config.bits), 2)) {\n                    throw new Error(\n                        errPrefix +\n                            \"(Binary string output not parseable to an Integer).\" +\n                            errSuffix\n                    )\n                }\n\n                if (rng && rng(config.bits).length > config.bits) {\n                    throw new Error(\n                        errPrefix +\n                            \"(Output length is greater than config.bits).\" +\n                            errSuffix\n                    )\n                }\n\n                if (rng && rng(config.bits).length < config.bits) {\n                    throw new Error(\n                        errPrefix +\n                            \"(Output length is less than config.bits).\" +\n                            errSuffix\n                    )\n                }\n            }\n\n            config.rng = rng\n\n            return true\n        },\n\n        // Converts a given UTF16 character string to the HEX representation.\n        // Each character of the input string is represented by\n        // `bytesPerChar` bytes in the output string which defaults to 2.\n        str2hex: function(str, bytesPerChar) {\n            var hexChars,\n                max,\n                out = \"\",\n                neededBytes,\n                num,\n                i,\n                len\n\n            if (typeof str !== \"string\") {\n                throw new Error(\"Input must be a character string.\")\n            }\n\n            if (!bytesPerChar) {\n                bytesPerChar = defaults.bytesPerChar\n            }\n\n            if (\n                typeof bytesPerChar !== \"number\" ||\n                bytesPerChar < 1 ||\n                bytesPerChar > defaults.maxBytesPerChar ||\n                bytesPerChar % 1 !== 0\n            ) {\n                throw new Error(\n                    \"Bytes per character must be an integer between 1 and \" +\n                        defaults.maxBytesPerChar +\n                        \", inclusive.\"\n                )\n            }\n\n            hexChars = 2 * bytesPerChar\n            max = Math.pow(16, hexChars) - 1\n\n            for (i = 0, len = str.length; i < len; i++) {\n                num = str[i].charCodeAt()\n\n                if (isNaN(num)) {\n                    throw new Error(\"Invalid character: \" + str[i])\n                }\n\n                if (num > max) {\n                    neededBytes = Math.ceil(Math.log(num + 1) / Math.log(256))\n                    throw new Error(\n                        \"Invalid character code (\" +\n                            num +\n                            \"). Maximum allowable is 256^bytes-1 (\" +\n                            max +\n                            \"). To convert this character, use at least \" +\n                            neededBytes +\n                            \" bytes.\"\n                    )\n                }\n\n                out = padLeft(num.toString(16), hexChars) + out\n            }\n            return out\n        },\n\n        // Converts a given HEX number string to a UTF16 character string.\n        hex2str: function(str, bytesPerChar) {\n            var hexChars,\n                out = \"\",\n                i,\n                len\n\n            if (typeof str !== \"string\") {\n                throw new Error(\"Input must be a hexadecimal string.\")\n            }\n            bytesPerChar = bytesPerChar || defaults.bytesPerChar\n\n            if (\n                typeof bytesPerChar !== \"number\" ||\n                bytesPerChar % 1 !== 0 ||\n                bytesPerChar < 1 ||\n                bytesPerChar > defaults.maxBytesPerChar\n            ) {\n                throw new Error(\n                    \"Bytes per character must be an integer between 1 and \" +\n                        defaults.maxBytesPerChar +\n                        \", inclusive.\"\n                )\n            }\n\n            hexChars = 2 * bytesPerChar\n\n            str = padLeft(str, hexChars)\n\n            for (i = 0, len = str.length; i < len; i += hexChars) {\n                out =\n                    String.fromCharCode(\n                        parseInt(str.slice(i, i + hexChars), 16)\n                    ) + out\n            }\n\n            return out\n        },\n\n        // Generates a random bits-length number string using the PRNG\n        random: function(bits) {\n            if (\n                typeof bits !== \"number\" ||\n                bits % 1 !== 0 ||\n                bits < 2 ||\n                bits > 65536\n            ) {\n                throw new Error(\n                    \"Number of bits must be an Integer between 1 and 65536.\"\n                )\n            }\n\n            return bin2hex(config.rng(bits))\n        },\n\n        // Divides a `secret` number String str expressed in radix `inputRadix` (optional, default 16)\n        // into `numShares` shares, each expressed in radix `outputRadix` (optional, default to `inputRadix`),\n        // requiring `threshold` number of shares to reconstruct the secret.\n        // Optionally, zero-pads the secret to a length that is a multiple of padLength before sharing.\n        share: function(secret, numShares, threshold, padLength) {\n            var neededBits,\n                subShares,\n                x = new Array(numShares),\n                y = new Array(numShares),\n                i,\n                j,\n                len\n\n            // Security:\n            // For additional security, pad in multiples of 128 bits by default.\n            // A small trade-off in larger share size to help prevent leakage of information\n            // about small-ish secrets and increase the difficulty of attacking them.\n            padLength = padLength || 128\n\n            if (typeof secret !== \"string\") {\n                throw new Error(\"Secret must be a string.\")\n            }\n\n            if (\n                typeof numShares !== \"number\" ||\n                numShares % 1 !== 0 ||\n                numShares < 2\n            ) {\n                throw new Error(\n                    \"Number of shares must be an integer between 2 and 2^bits-1 (\" +\n                        config.maxShares +\n                        \"), inclusive.\"\n                )\n            }\n\n            if (numShares > config.maxShares) {\n                neededBits = Math.ceil(Math.log(numShares + 1) / Math.LN2)\n                throw new Error(\n                    \"Number of shares must be an integer between 2 and 2^bits-1 (\" +\n                        config.maxShares +\n                        \"), inclusive. To create \" +\n                        numShares +\n                        \" shares, use at least \" +\n                        neededBits +\n                        \" bits.\"\n                )\n            }\n\n            if (\n                typeof threshold !== \"number\" ||\n                threshold % 1 !== 0 ||\n                threshold < 2\n            ) {\n                throw new Error(\n                    \"Threshold number of shares must be an integer between 2 and 2^bits-1 (\" +\n                        config.maxShares +\n                        \"), inclusive.\"\n                )\n            }\n\n            if (threshold > config.maxShares) {\n                neededBits = Math.ceil(Math.log(threshold + 1) / Math.LN2)\n                throw new Error(\n                    \"Threshold number of shares must be an integer between 2 and 2^bits-1 (\" +\n                        config.maxShares +\n                        \"), inclusive.  To use a threshold of \" +\n                        threshold +\n                        \", use at least \" +\n                        neededBits +\n                        \" bits.\"\n                )\n            }\n\n            if (threshold > numShares) {\n                throw new Error(\n                    \"Threshold number of shares was \" +\n                        threshold +\n                        \" but must be less than or equal to the \" +\n                        numShares +\n                        \" shares specified as the total to generate.\"\n                )\n            }\n\n            if (\n                typeof padLength !== \"number\" ||\n                padLength % 1 !== 0 ||\n                padLength < 0 ||\n                padLength > 1024\n            ) {\n                throw new Error(\n                    \"Zero-pad length must be an integer between 0 and 1024 inclusive.\"\n                )\n            }\n\n            secret = \"1\" + hex2bin(secret) // prepend a 1 as a marker so that we can preserve the correct number of leading zeros in our secret\n            secret = splitNumStringToIntArray(secret, padLength)\n\n            for (i = 0, len = secret.length; i < len; i++) {\n                subShares = getShares(secret[i], numShares, threshold)\n                for (j = 0; j < numShares; j++) {\n                    x[j] = x[j] || subShares[j].x.toString(config.radix)\n                    y[j] = padLeft(subShares[j].y.toString(2)) + (y[j] || \"\")\n                }\n            }\n\n            for (i = 0; i < numShares; i++) {\n                x[i] = constructPublicShareString(\n                    config.bits,\n                    x[i],\n                    bin2hex(y[i])\n                )\n            }\n\n            return x\n        },\n\n        // Generate a new share with id `id` (a number between 1 and 2^bits-1)\n        // `id` can be a Number or a String in the default radix (16)\n        newShare: function(id, shares) {\n            var share, radid\n\n            if (id && typeof id === \"string\") {\n                id = parseInt(id, config.radix)\n            }\n\n            radid = id.toString(config.radix)\n\n            if (id && radid && shares && shares[0]) {\n                share = this.extractShareComponents(shares[0])\n                return constructPublicShareString(\n                    share.bits,\n                    radid,\n                    this.combine(shares, id)\n                )\n            }\n\n            throw new Error(\n                \"Invalid 'id' or 'shares' Array argument to newShare().\"\n            )\n        },\n\n        /* test-code */\n        // export private functions so they can be unit tested directly.\n        _reset: reset,\n        _padLeft: padLeft,\n        _hex2bin: hex2bin,\n        _bin2hex: bin2hex,\n        _hasCryptoGetRandomValues: hasCryptoGetRandomValues,\n        _hasCryptoRandomBytes: hasCryptoRandomBytes,\n        _getRNG: getRNG,\n        _isSetRNG: isSetRNG,\n        _splitNumStringToIntArray: splitNumStringToIntArray,\n        _horner: horner,\n        _lagrange: lagrange,\n        _getShares: getShares,\n        _constructPublicShareString: constructPublicShareString\n        /* end-test-code */\n    }\n\n    // Always initialize secrets with default settings.\n    secrets.init()\n\n    return secrets\n})\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n, title = '') {\n    if (!Number.isSafeInteger(n) || n < 0) {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(`${prefix}expected integer >= 0, got ${n}`);\n    }\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(value, length, title = '') {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash must wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out, undefined, 'digestInto() output');\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('\"digestInto() output\" expected to be of length >=' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * Built-in doesn't validate input to be string: we do the check.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data, errorTitle = '') {\n    if (typeof data === 'string')\n        return utf8ToBytes(data);\n    return abytes(data, undefined, errorTitle);\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/** Merges default options and passed options. */\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options must be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Creates function with outputLen, blockLen, create properties from a class constructor. */\nexport function createHasher(hashCons, info = {}) {\n    const hashC = (msg, opts) => hashCons(opts).update(msg).digest();\n    const tmp = hashCons(undefined);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    Object.assign(hashC, info);\n    return Object.freeze(hashC);\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    const cr = typeof globalThis === 'object' ? globalThis.crypto : null;\n    if (typeof cr?.getRandomValues !== 'function')\n        throw new Error('crypto.getRandomValues must be defined');\n    return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n/** Creates OID opts for NIST hashes, with prefix 06 09 60 86 48 01 65 03 04 02. */\nexport const oidNist = (suffix) => ({\n    oid: Uint8Array.from([0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, suffix]),\n});\n//# sourceMappingURL=utils.js.map","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { abytes, aexists, aoutput, clean, createView } from \"./utils.js\";\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD {\n    blockLen;\n    outputLen;\n    padOffset;\n    isLE;\n    // For partial updates less than block size\n    buffer;\n    view;\n    finished = false;\n    length = 0;\n    pos = 0;\n    destroyed = false;\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which must be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen must be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to ||= new this.constructor();\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\nimport { clean, createHasher, oidNist, rotr } from \"./utils.js\";\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n/** Internal 32-byte base SHA2 hash class. */\nclass SHA2_32B extends HashMD {\n    constructor(outputLen) {\n        super(64, outputLen, 8, false);\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        clean(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/** Internal SHA2-256 hash class. */\nexport class _SHA256 extends SHA2_32B {\n    // We cannot use array here since array allows indexing by variable\n    // which means optimizer/compiler cannot use registers.\n    A = SHA256_IV[0] | 0;\n    B = SHA256_IV[1] | 0;\n    C = SHA256_IV[2] | 0;\n    D = SHA256_IV[3] | 0;\n    E = SHA256_IV[4] | 0;\n    F = SHA256_IV[5] | 0;\n    G = SHA256_IV[6] | 0;\n    H = SHA256_IV[7] | 0;\n    constructor() {\n        super(32);\n    }\n}\n/** Internal SHA2-224 hash class. */\nexport class _SHA224 extends SHA2_32B {\n    A = SHA224_IV[0] | 0;\n    B = SHA224_IV[1] | 0;\n    C = SHA224_IV[2] | 0;\n    D = SHA224_IV[3] | 0;\n    E = SHA224_IV[4] | 0;\n    F = SHA224_IV[5] | 0;\n    G = SHA224_IV[6] | 0;\n    H = SHA224_IV[7] | 0;\n    constructor() {\n        super(28);\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n/** Internal 64-byte base SHA2 hash class. */\nclass SHA2_64B extends HashMD {\n    constructor(outputLen) {\n        super(128, outputLen, 16, false);\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/** Internal SHA2-512 hash class. */\nexport class _SHA512 extends SHA2_64B {\n    Ah = SHA512_IV[0] | 0;\n    Al = SHA512_IV[1] | 0;\n    Bh = SHA512_IV[2] | 0;\n    Bl = SHA512_IV[3] | 0;\n    Ch = SHA512_IV[4] | 0;\n    Cl = SHA512_IV[5] | 0;\n    Dh = SHA512_IV[6] | 0;\n    Dl = SHA512_IV[7] | 0;\n    Eh = SHA512_IV[8] | 0;\n    El = SHA512_IV[9] | 0;\n    Fh = SHA512_IV[10] | 0;\n    Fl = SHA512_IV[11] | 0;\n    Gh = SHA512_IV[12] | 0;\n    Gl = SHA512_IV[13] | 0;\n    Hh = SHA512_IV[14] | 0;\n    Hl = SHA512_IV[15] | 0;\n    constructor() {\n        super(64);\n    }\n}\n/** Internal SHA2-384 hash class. */\nexport class _SHA384 extends SHA2_64B {\n    Ah = SHA384_IV[0] | 0;\n    Al = SHA384_IV[1] | 0;\n    Bh = SHA384_IV[2] | 0;\n    Bl = SHA384_IV[3] | 0;\n    Ch = SHA384_IV[4] | 0;\n    Cl = SHA384_IV[5] | 0;\n    Dh = SHA384_IV[6] | 0;\n    Dl = SHA384_IV[7] | 0;\n    Eh = SHA384_IV[8] | 0;\n    El = SHA384_IV[9] | 0;\n    Fh = SHA384_IV[10] | 0;\n    Fl = SHA384_IV[11] | 0;\n    Gh = SHA384_IV[12] | 0;\n    Gl = SHA384_IV[13] | 0;\n    Hh = SHA384_IV[14] | 0;\n    Hl = SHA384_IV[15] | 0;\n    constructor() {\n        super(48);\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n/** Internal SHA2-512/224 hash class. */\nexport class _SHA512_224 extends SHA2_64B {\n    Ah = T224_IV[0] | 0;\n    Al = T224_IV[1] | 0;\n    Bh = T224_IV[2] | 0;\n    Bl = T224_IV[3] | 0;\n    Ch = T224_IV[4] | 0;\n    Cl = T224_IV[5] | 0;\n    Dh = T224_IV[6] | 0;\n    Dl = T224_IV[7] | 0;\n    Eh = T224_IV[8] | 0;\n    El = T224_IV[9] | 0;\n    Fh = T224_IV[10] | 0;\n    Fl = T224_IV[11] | 0;\n    Gh = T224_IV[12] | 0;\n    Gl = T224_IV[13] | 0;\n    Hh = T224_IV[14] | 0;\n    Hl = T224_IV[15] | 0;\n    constructor() {\n        super(28);\n    }\n}\n/** Internal SHA2-512/256 hash class. */\nexport class _SHA512_256 extends SHA2_64B {\n    Ah = T256_IV[0] | 0;\n    Al = T256_IV[1] | 0;\n    Bh = T256_IV[2] | 0;\n    Bl = T256_IV[3] | 0;\n    Ch = T256_IV[4] | 0;\n    Cl = T256_IV[5] | 0;\n    Dh = T256_IV[6] | 0;\n    Dl = T256_IV[7] | 0;\n    Eh = T256_IV[8] | 0;\n    El = T256_IV[9] | 0;\n    Fh = T256_IV[10] | 0;\n    Fl = T256_IV[11] | 0;\n    Gh = T256_IV[12] | 0;\n    Gl = T256_IV[13] | 0;\n    Hh = T256_IV[14] | 0;\n    Hl = T256_IV[15] | 0;\n    constructor() {\n        super(32);\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634. In JS it's the fastest: even faster than Blake3. Some info:\n *\n * - Trying 2^128 hashes would get 50% chance of collision, using birthday attack.\n * - BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n * - Each sha256 hash is executing 2^18 bit operations.\n * - Good 2024 ASICs can do 200Th/sec with 3500 watts of power, corresponding to 2^36 hashes/joule.\n */\nexport const sha256 = /* @__PURE__ */ createHasher(() => new _SHA256(), \n/* @__PURE__ */ oidNist(0x01));\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224 = /* @__PURE__ */ createHasher(() => new _SHA224(), \n/* @__PURE__ */ oidNist(0x04));\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512 = /* @__PURE__ */ createHasher(() => new _SHA512(), \n/* @__PURE__ */ oidNist(0x03));\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384 = /* @__PURE__ */ createHasher(() => new _SHA384(), \n/* @__PURE__ */ oidNist(0x02));\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256 = /* @__PURE__ */ createHasher(() => new _SHA512_256(), \n/* @__PURE__ */ oidNist(0x06));\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224 = /* @__PURE__ */ createHasher(() => new _SHA512_224(), \n/* @__PURE__ */ oidNist(0x05));\n//# sourceMappingURL=sha2.js.map","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes as abytes_, anumber, bytesToHex as bytesToHex_, concatBytes as concatBytes_, hexToBytes as hexToBytes_, } from '@noble/hashes/utils.js';\nexport { abytes, anumber, bytesToHex, concatBytes, hexToBytes, isBytes, randomBytes, } from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function abool(value, title = '') {\n    if (typeof value !== 'boolean') {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n    }\n    return value;\n}\n// Used in weierstrass, der\nfunction abignumber(n) {\n    if (typeof n === 'bigint') {\n        if (!isPosBig(n))\n            throw new Error('positive bigint expected, got ' + n);\n    }\n    else\n        anumber(n);\n    return n;\n}\nexport function asafenumber(value, title = '') {\n    if (!Number.isSafeInteger(value)) {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(prefix + 'expected safe integer, got type=' + typeof value);\n    }\n}\nexport function numberToHexUnpadded(num) {\n    const hex = abignumber(num).toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    return hexToNumber(bytesToHex_(copyBytes(abytes_(bytes)).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    anumber(len);\n    n = abignumber(n);\n    const res = hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n    if (res.length !== len)\n        throw new Error('number too large');\n    return res;\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes_(numberToHexUnpadded(abignumber(n)));\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as `TextEncoder` for ASCII or throws.\n */\nexport function asciiToBytes(ascii) {\n    return Uint8Array.from(ascii, (c, i) => {\n        const charCode = c.charCodeAt(0);\n        if (c.length !== 1 || charCode > 127) {\n            throw new Error(`string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`);\n        }\n        return charCode;\n    });\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    anumber(hashLen, 'hashLen');\n    anumber(qByteLen, 'qByteLen');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const NULL = Uint8Array.of();\n    const byte0 = Uint8Array.of(0x00);\n    const byte1 = Uint8Array.of(0x01);\n    const _maxDrbgIters = 1000;\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...msgs) => hmacFn(k, concatBytes_(v, ...msgs)); // hmac(k)(v, ...values)\n    const reseed = (seed = NULL) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(byte0, seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(byte1, seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= _maxDrbgIters)\n            throw new Error('drbg: tried max amount of iterations');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes_(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nexport function validateObject(object, fields = {}, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    const iter = (f, isOpt) => Object.entries(f).forEach(([k, v]) => checkField(k, v, isOpt));\n    iter(fields, false);\n    iter(optFields, true);\n}\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes, anumber, bytesToNumberBE, bytesToNumberLE, numberToBytesBE, numberToBytesLE, validateObject, } from \"../utils.js\";\n// Numbers aren't used in x25519 / x448 builds\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = /* @__PURE__ */ BigInt(1), _2n = /* @__PURE__ */ BigInt(2);\n// prettier-ignore\nconst _3n = /* @__PURE__ */ BigInt(3), _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);\n// prettier-ignore\nconst _7n = /* @__PURE__ */ BigInt(7), _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9);\nconst _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n) => {\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n)\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. P  9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P  3 (mod 4) => n = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P  9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n)\n        return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        BYTES: 'number',\n        BITS: 'number',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    validateObject(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nexport function FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nexport function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        anumber(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\nclass _Field {\n    ORDER;\n    BITS;\n    BYTES;\n    isLE;\n    ZERO = _0n;\n    ONE = _1n;\n    _lengths;\n    _sqrt; // cached sqrt\n    _mod;\n    constructor(ORDER, opts = {}) {\n        if (ORDER <= _0n)\n            throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n        let _nbitLength = undefined;\n        this.isLE = false;\n        if (opts != null && typeof opts === 'object') {\n            if (typeof opts.BITS === 'number')\n                _nbitLength = opts.BITS;\n            if (typeof opts.sqrt === 'function')\n                this.sqrt = opts.sqrt;\n            if (typeof opts.isLE === 'boolean')\n                this.isLE = opts.isLE;\n            if (opts.allowedLengths)\n                this._lengths = opts.allowedLengths?.slice();\n            if (typeof opts.modFromBytes === 'boolean')\n                this._mod = opts.modFromBytes;\n        }\n        const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);\n        if (nByteLength > 2048)\n            throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n        this.ORDER = ORDER;\n        this.BITS = nBitLength;\n        this.BYTES = nByteLength;\n        this._sqrt = undefined;\n        Object.preventExtensions(this);\n    }\n    create(num) {\n        return mod(num, this.ORDER);\n    }\n    isValid(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('invalid field element: expected bigint, got ' + typeof num);\n        return _0n <= num && num < this.ORDER; // 0 is valid element, but it's not invertible\n    }\n    is0(num) {\n        return num === _0n;\n    }\n    // is valid and invertible\n    isValidNot0(num) {\n        return !this.is0(num) && this.isValid(num);\n    }\n    isOdd(num) {\n        return (num & _1n) === _1n;\n    }\n    neg(num) {\n        return mod(-num, this.ORDER);\n    }\n    eql(lhs, rhs) {\n        return lhs === rhs;\n    }\n    sqr(num) {\n        return mod(num * num, this.ORDER);\n    }\n    add(lhs, rhs) {\n        return mod(lhs + rhs, this.ORDER);\n    }\n    sub(lhs, rhs) {\n        return mod(lhs - rhs, this.ORDER);\n    }\n    mul(lhs, rhs) {\n        return mod(lhs * rhs, this.ORDER);\n    }\n    pow(num, power) {\n        return FpPow(this, num, power);\n    }\n    div(lhs, rhs) {\n        return mod(lhs * invert(rhs, this.ORDER), this.ORDER);\n    }\n    // Same as above, but doesn't normalize\n    sqrN(num) {\n        return num * num;\n    }\n    addN(lhs, rhs) {\n        return lhs + rhs;\n    }\n    subN(lhs, rhs) {\n        return lhs - rhs;\n    }\n    mulN(lhs, rhs) {\n        return lhs * rhs;\n    }\n    inv(num) {\n        return invert(num, this.ORDER);\n    }\n    sqrt(num) {\n        // Caching _sqrt speeds up sqrt9mod16 by 5x and tonneli-shanks by 10%\n        if (!this._sqrt)\n            this._sqrt = FpSqrt(this.ORDER);\n        return this._sqrt(this, num);\n    }\n    toBytes(num) {\n        return this.isLE ? numberToBytesLE(num, this.BYTES) : numberToBytesBE(num, this.BYTES);\n    }\n    fromBytes(bytes, skipValidation = false) {\n        abytes(bytes);\n        const { _lengths: allowedLengths, BYTES, isLE, ORDER, _mod: modFromBytes } = this;\n        if (allowedLengths) {\n            if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);\n            }\n            const padded = new Uint8Array(BYTES);\n            // isLE add 0 to right, !isLE to the left.\n            padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n            bytes = padded;\n        }\n        if (bytes.length !== BYTES)\n            throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n        let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        if (modFromBytes)\n            scalar = mod(scalar, ORDER);\n        if (!skipValidation)\n            if (!this.isValid(scalar))\n                throw new Error('invalid field element: outside of range 0..ORDER');\n        // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n        // protocol may allow non-reduced scalar that reduced later or changed some other way.\n        return scalar;\n    }\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch(lst) {\n        return FpInvertBatch(this, lst);\n    }\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov(a, b, condition) {\n        return condition ? b : a;\n    }\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, opts = {}) {\n    return new _Field(ORDER, opts);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.Point.Fn.ORDER)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    abytes(key);\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask } from \"../utils.js\";\nimport { Field, FpInvertBatch, validateField } from \"./modular.js\";\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ(c, points) {\n    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));\n    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = bitMask(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n)\n        throw new Error('invalid wNAF');\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF {\n    BASE;\n    ZERO;\n    Fn;\n    bits;\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits) {\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(1) * (Math.ceil( / ) + 1), where:\n     * -  is the window size\n     * -  is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for (let i = 1; i < windowSize; i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n))\n            throw new Error('invalid scalar');\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            }\n            else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return { p, f };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            if (n === _0n)\n                break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // Window bits are 0: skip processing.\n                // Move to next window.\n                continue;\n            }\n            else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === 'function')\n                    comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1)\n            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n)\n            p1 = p1.add(acc);\n        if (k2 & _1n)\n            p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return { p1, p2 };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger(c, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    const fieldN = c.Fn;\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = bitMask(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar  256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255  32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16  255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    const fieldN = c.Fn;\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = bitMask(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction createField(order, field, isLE) {\n    if (field) {\n        if (field.ORDER !== order)\n            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n        validateField(field);\n        return field;\n    }\n    else {\n        return Field(order, { isLE });\n    }\n}\n/** Validates CURVE opts and creates fields */\nexport function createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === undefined)\n        FpFnLE = type === 'edwards';\n    if (!CURVE || typeof CURVE !== 'object')\n        throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of ['p', 'n', 'h']) {\n        const val = CURVE[p];\n        if (!(typeof val === 'bigint' && val > _0n))\n            throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type === 'weierstrass' ? 'b' : 'd';\n    const params = ['Gx', 'Gy', 'a', _b];\n    for (const p of params) {\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p]))\n            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return { CURVE, Fp, Fn };\n}\nexport function createKeygen(randomSecretKey, getPublicKey) {\n    return function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: getPublicKey(secretKey) };\n    };\n}\n//# sourceMappingURL=curve.js.map","/**\n * Twisted Edwards curve. The formula is: ax + y = 1 + dxy.\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abool, abytes, aInRange, bytesToHex, bytesToNumberLE, concatBytes, copyBytes, hexToBytes, isBytes, memoized, notImplemented, validateObject, randomBytes as wcRandomBytes, } from \"../utils.js\";\nimport { createCurveFields, createKeygen, normalizeZ, wNAF, } from \"./curve.js\";\nimport {} from \"./modular.js\";\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\nfunction isEdValidXY(Fp, CURVE, x, y) {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n}\nexport function edwards(params, extraOpts = {}) {\n    const validated = createCurveFields('edwards', params, extraOpts, extraOpts.FpFnLE);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor } = CURVE;\n    validateObject(extraOpts, {}, { uvRatio: 'function' });\n    // Important:\n    // There are some places where Fp.BYTES is used instead of nByteLength.\n    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n    // TODO: test and find curves which behave otherwise.\n    const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);\n    const modP = (n) => Fp.create(n); // Function overrides\n    // sqrt(u/v)\n    const uvRatio = extraOpts.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    // Validate whether the passed curve params are valid.\n    // equation ax + y = 1 + dxy should work for generator point.\n    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    /**\n     * Asserts coordinate is valid: 0 <= n < MASK.\n     * Coordinates >= Fp.ORDER are allowed for zip215.\n     */\n    function acoord(title, n, banZero = false) {\n        const min = banZero ? _1n : _0n;\n        aInRange('coordinate ' + title, n, min, MASK);\n        return n;\n    }\n    function aedpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('EdwardsPoint expected');\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = memoized((p, iz) => {\n        const { X, Y, Z } = p;\n        const is0 = p.is0();\n        if (iz == null)\n            iz = is0 ? _8n : Fp.inv(Z); // 8 was chosen arbitrarily\n        const x = modP(X * iz);\n        const y = modP(Y * iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0)\n            return { x: _0n, y: _1n };\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return { x, y };\n    });\n    const assertValidMemo = memoized((p) => {\n        const { a, d } = CURVE;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax + y = 1 + dxy\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n        const { X, Y, Z, T } = p;\n        const X2 = modP(X * X); // X\n        const Y2 = modP(Y * Y); // Y\n        const Z2 = modP(Z * Z); // Z\n        const Z4 = modP(Z2 * Z2); // Z\n        const aX2 = modP(X2 * a); // aX\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return true;\n    });\n    // Extended Point works in extended coordinates: (X, Y, Z, T)  (x=X/Z, y=Y/Z, T=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        // base / generator point\n        static BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n        // zero / infinity / identity point\n        static ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n        // math field\n        static Fp = Fp;\n        // scalar field\n        static Fn = Fn;\n        X;\n        Y;\n        Z;\n        T;\n        constructor(X, Y, Z, T) {\n            this.X = acoord('x', X);\n            this.Y = acoord('y', Y);\n            this.Z = acoord('z', Z, true);\n            this.T = acoord('t', T);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            acoord('x', x);\n            acoord('y', y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        // Uses algo from RFC8032 5.1.3.\n        static fromBytes(bytes, zip215 = false) {\n            const len = Fp.BYTES;\n            const { a, d } = CURVE;\n            bytes = copyBytes(abytes(bytes, len, 'point'));\n            abool(zip215, 'zip215');\n            const normed = copyBytes(bytes); // copy again, we'll manipulate it\n            const lastByte = bytes[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = bytesToNumberLE(normed);\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            aInRange('point.y', y, _0n, max);\n            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y - 1\n            const v = modP(d * y2 - a); // v = d y + 1.\n            let { isValid, value: x } = uvRatio(u, v); // (u/v)\n            if (!isValid)\n                throw new Error('bad point: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('bad point: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromHex(hex, zip215 = false) {\n            return Point.fromBytes(hexToBytes(hex), zip215);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy)\n                this.multiply(_2n); // random number\n            return this;\n        }\n        // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            aedpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            aedpoint(other);\n            const { a, d } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n            const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            // 1 <= scalar < L\n            if (!Fn.isValidNot0(scalar))\n                throw new Error('invalid scalar: expected 1 <= sc < curve.n');\n            const { p, f } = wnaf.cached(this, scalar, (p) => normalizeZ(Point, p));\n            return normalizeZ(Point, [p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n        multiplyUnsafe(scalar, acc = Point.ZERO) {\n            // 0 <= scalar < L\n            if (!Fn.isValid(scalar))\n                throw new Error('invalid scalar: expected 0 <= sc < curve.n');\n            if (scalar === _0n)\n                return Point.ZERO;\n            if (this.is0() || scalar === _1n)\n                return this;\n            return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafe(this, CURVE.n).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        clearCofactor() {\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        toBytes() {\n            const { x, y } = this.toAffine();\n            // Fp.toBytes() allows non-canonical encoding of y (>= p).\n            const bytes = Fp.toBytes(y);\n            // Each y has 2 valid points: (x, y), (x,-y).\n            // When compressing, it's enough to store y and use the last byte to encode sign of x\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;\n            return bytes;\n        }\n        toHex() {\n            return bytesToHex(this.toBytes());\n        }\n        toString() {\n            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n        }\n    }\n    const wnaf = new wNAF(Point, Fn.BITS);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */\nexport class PrimeEdwardsPoint {\n    static BASE;\n    static ZERO;\n    static Fp;\n    static Fn;\n    ep;\n    constructor(ep) {\n        this.ep = ep;\n    }\n    // Static methods that must be implemented by subclasses\n    static fromBytes(_bytes) {\n        notImplemented();\n    }\n    static fromHex(_hex) {\n        notImplemented();\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    // Common implementations\n    clearCofactor() {\n        // no-op for prime-order groups\n        return this;\n    }\n    assertValidity() {\n        this.ep.assertValidity();\n    }\n    toAffine(invertedZ) {\n        return this.ep.toAffine(invertedZ);\n    }\n    toHex() {\n        return bytesToHex(this.toBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    isTorsionFree() {\n        return true;\n    }\n    isSmallOrder() {\n        return false;\n    }\n    add(other) {\n        this.assertSame(other);\n        return this.init(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        this.assertSame(other);\n        return this.init(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return this.init(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return this.init(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return this.init(this.ep.double());\n    }\n    negate() {\n        return this.init(this.ep.negate());\n    }\n    precompute(windowSize, isLazy) {\n        return this.init(this.ep.precompute(windowSize, isLazy));\n    }\n}\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nexport function eddsa(Point, cHash, eddsaOpts = {}) {\n    if (typeof cHash !== 'function')\n        throw new Error('\"hash\" function param is required');\n    validateObject(eddsaOpts, {}, {\n        adjustScalarBytes: 'function',\n        randomBytes: 'function',\n        domain: 'function',\n        prehash: 'function',\n        mapToCurve: 'function',\n    });\n    const { prehash } = eddsaOpts;\n    const { BASE, Fp, Fn } = Point;\n    const randomBytes = eddsaOpts.randomBytes || wcRandomBytes;\n    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);\n    const domain = eddsaOpts.domain ||\n        ((data, ctx, phflag) => {\n            abool(phflag, 'phflag');\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return Fn.create(bytesToNumberLE(hash)); // Not Fn.fromBytes: it has length limit\n    }\n    // Get the hashed private scalar per RFC8032 5.1.5\n    function getPrivateScalar(key) {\n        const len = lengths.secretKey;\n        abytes(key, lengths.secretKey, 'secretKey');\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = abytes(cHash(key), 2 * len, 'hashedSecretKey');\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        return { head, prefix, scalar };\n    }\n    /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */\n    function getExtendedPublicKey(secretKey) {\n        const { head, prefix, scalar } = getPrivateScalar(secretKey);\n        const point = BASE.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toBytes();\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    /** Calculates EdDSA pub key. RFC8032 5.1.5. */\n    function getPublicKey(secretKey) {\n        return getExtendedPublicKey(secretKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n        const msg = concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, abytes(context, undefined, 'context'), !!prehash)));\n    }\n    /** Signs message with secret key. RFC8032 5.1.6 */\n    function sign(msg, secretKey, options = {}) {\n        msg = abytes(msg, undefined, 'message');\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = BASE.multiply(r).toBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L\n        if (!Fn.isValid(s))\n            throw new Error('sign failed: invalid s'); // 0 <= s < L\n        const rs = concatBytes(R, Fn.toBytes(s));\n        return abytes(rs, lengths.signature, 'result');\n    }\n    // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n    const verifyOpts = { zip215: true };\n    /**\n     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n     * An extended group equation is checked.\n     */\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = lengths.signature;\n        sig = abytes(sig, len, 'signature');\n        msg = abytes(msg, undefined, 'message');\n        publicKey = abytes(publicKey, lengths.publicKey, 'publicKey');\n        if (zip215 !== undefined)\n            abool(zip215, 'zip215');\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const mid = len / 2;\n        const r = sig.subarray(0, mid);\n        const s = bytesToNumberLE(sig.subarray(mid, len));\n        let A, R, SB;\n        try {\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            A = Point.fromBytes(publicKey, zip215);\n            R = Point.fromBytes(r, zip215);\n            SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false; // zip215 allows public keys of small order\n        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // Extended group equation\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().is0();\n    }\n    const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448\n    const lengths = {\n        secretKey: _size,\n        publicKey: _size,\n        signature: 2 * _size,\n        seed: _size,\n    };\n    function randomSecretKey(seed = randomBytes(lengths.seed)) {\n        return abytes(seed, lengths.seed, 'seed');\n    }\n    function isValidSecretKey(key) {\n        return isBytes(key) && key.length === Fn.BYTES;\n    }\n    function isValidPublicKey(key, zip215) {\n        try {\n            return !!Point.fromBytes(key, zip215);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    const utils = {\n        getExtendedPublicKey,\n        randomSecretKey,\n        isValidSecretKey,\n        isValidPublicKey,\n        /**\n         * Converts ed public key to x public key. Uses formula:\n         * - ed25519:\n         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n         * - ed448:\n         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n         */\n        toMontgomery(publicKey) {\n            const { y } = Point.fromBytes(publicKey);\n            const size = lengths.publicKey;\n            const is25519 = size === 32;\n            if (!is25519 && size !== 57)\n                throw new Error('only defined for 25519 and 448');\n            const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n            return Fp.toBytes(u);\n        },\n        toMontgomerySecret(secretKey) {\n            const size = lengths.secretKey;\n            abytes(secretKey, size);\n            const hashed = cHash(secretKey.subarray(0, size));\n            return adjustScalarBytes(hashed).subarray(0, size);\n        },\n    };\n    return Object.freeze({\n        keygen: createKeygen(randomSecretKey, getPublicKey),\n        getPublicKey,\n        sign,\n        verify,\n        utils,\n        Point,\n        lengths,\n    });\n}\n//# sourceMappingURL=edwards.js.map","/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, concatBytes, hexToBytes } from '@noble/hashes/utils.js';\nimport {} from \"./abstract/curve.js\";\nimport { eddsa, edwards, PrimeEdwardsPoint, } from \"./abstract/edwards.js\";\nimport { _DST_scalar, createHasher, expand_message_xmd, } from \"./abstract/hash-to-curve.js\";\nimport { FpInvertBatch, FpSqrtEven, isNegativeLE, mod, pow2, } from \"./abstract/modular.js\";\nimport { montgomery } from \"./abstract/montgomery.js\";\nimport { createORPF } from \"./abstract/oprf.js\";\nimport { asciiToBytes, bytesToNumberLE, equalBytes } from \"./utils.js\";\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n// P = 2n**255n - 19n\nconst ed25519_CURVE_p = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed');\n// N = 2n**252n + 27742317777372353535851937790883648493n\n// a = Fp.create(BigInt(-1))\n// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\nconst ed25519_CURVE = /* @__PURE__ */ (() => ({\n    p: ed25519_CURVE_p,\n    n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),\n    h: _8n,\n    a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),\n    d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),\n    Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),\n    Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),\n}))();\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ed25519_CURVE_p;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n    const b10 = (pow2(b5, _5n, P) * b5) % P;\n    const b20 = (pow2(b10, _10n, P) * b10) % P;\n    const b40 = (pow2(b20, _20n, P) * b20) % P;\n    const b80 = (pow2(b40, _40n, P) * b40) % P;\n    const b160 = (pow2(b80, _80n, P) * b80) % P;\n    const b240 = (pow2(b160, _80n, P) * b80) % P;\n    const b250 = (pow2(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// (-1) aka (a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ed25519_CURVE_p;\n    const v3 = mod(v * v * v, P); // v\n    const v7 = mod(v3 * v3 * v, P); // v\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n    const vx2 = mod(v * x * x, P); // vx\n    const root1 = x; // First root candidate\n    const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if (isNegativeLE(x, P))\n        x = mod(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nconst ed25519_Point = /* @__PURE__ */ edwards(ed25519_CURVE, { uvRatio });\nconst Fp = /* @__PURE__ */ (() => ed25519_Point.Fp)();\nconst Fn = /* @__PURE__ */ (() => ed25519_Point.Fn)();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return concatBytes(asciiToBytes('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nfunction ed(opts) {\n    return eddsa(ed25519_Point, sha512, Object.assign({ adjustScalarBytes }, opts));\n}\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * ```js\n * import { ed25519 } from '@noble/curves/ed25519.js';\n * const { secretKey, publicKey } = ed25519.keygen();\n * // const publicKey = ed25519.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello noble');\n * const sig = ed25519.sign(msg, secretKey);\n * const isValid = ed25519.verify(sig, msg, pub); // ZIP215\n * // RFC8032 / FIPS 186-5\n * const isValid2 = ed25519.verify(sig, msg, pub, { zip215: false });\n * ```\n */\nexport const ed25519 = /* @__PURE__ */ ed({});\n/** Context version of ed25519 (ctx for domain separation). See {@link ed25519} */\nexport const ed25519ctx = /* @__PURE__ */ ed({ domain: ed25519_domain });\n/** Prehashed version of ed25519. See {@link ed25519} */\nexport const ed25519ph = /* @__PURE__ */ ed({ domain: ed25519_domain, prehash: sha512 });\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * ```js\n * import { x25519 } from '@noble/curves/ed25519.js';\n * const alice = x25519.keygen();\n * const bob = x25519.keygen();\n * const shared = x25519.getSharedSecret(alice.secretKey, bob.publicKey);\n * ```\n */\nexport const x25519 = /* @__PURE__ */ (() => {\n    const P = ed25519_CURVE_p;\n    return montgomery({\n        P,\n        type: 'x25519',\n        powPminus2: (x) => {\n            // x^(p-2) aka x^(2^255-21)\n            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n            return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n        },\n        adjustScalarBytes,\n    });\n})();\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n/**\n * RFC 9380 method `map_to_curve_elligator2_curve25519`. Experimental name: may be renamed later.\n * @private\n */\n// prettier-ignore\nexport function _map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = _map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true); // batch division\n    return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\n/** Hashing to ed25519 points / field. RFC 9380 methods. */\nexport const ed25519_hasher = /* @__PURE__ */ (() => createHasher(ed25519_Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: ed25519_CURVE_p,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha512,\n}))();\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519_CURVE;\n    const P = ed25519_CURVE_p;\n    const mod = (n) => Fp.create(n);\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!isNegativeLE(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519_Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Wrapper over Edwards Point for ristretto255.\n *\n * Each ed25519/EdwardsPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like EdwardsPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass _RistrettoPoint extends PrimeEdwardsPoint {\n    // Do NOT change syntax: the following gymnastics is done,\n    // because typescript strips comments, which makes bundlers disable tree-shaking.\n    // prettier-ignore\n    static BASE = \n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519_Point.BASE))();\n    // prettier-ignore\n    static ZERO = \n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519_Point.ZERO))();\n    // prettier-ignore\n    static Fp = \n    /* @__PURE__ */ (() => Fp)();\n    // prettier-ignore\n    static Fn = \n    /* @__PURE__ */ (() => Fn)();\n    constructor(ep) {\n        super(ep);\n    }\n    static fromAffine(ap) {\n        return new _RistrettoPoint(ed25519_Point.fromAffine(ap));\n    }\n    assertSame(other) {\n        if (!(other instanceof _RistrettoPoint))\n            throw new Error('RistrettoPoint expected');\n    }\n    init(ep) {\n        return new _RistrettoPoint(ep);\n    }\n    static fromBytes(bytes) {\n        abytes(bytes, 32);\n        const { a, d } = ed25519_CURVE;\n        const P = ed25519_CURVE_p;\n        const mod = (n) => Fp.create(n);\n        const s = bytes255ToNumberLE(bytes);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!equalBytes(Fp.toBytes(s), bytes) || isNegativeLE(s, P))\n            throw new Error('invalid ristretto255 encoding 1');\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if (isNegativeLE(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || isNegativeLE(t, P) || y === _0n)\n            throw new Error('invalid ristretto255 encoding 2');\n        return new _RistrettoPoint(new ed25519_Point(x, y, _1n, t));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        return _RistrettoPoint.fromBytes(hexToBytes(hex));\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n     */\n    toBytes() {\n        let { X, Y, Z, T } = this.ep;\n        const P = ed25519_CURVE_p;\n        const mod = (n) => Fp.create(n);\n        const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1\n        const u2 = mod(X * Y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * T); // 6\n        let D; // 7\n        if (isNegativeLE(T * zInv, P)) {\n            let _x = mod(Y * SQRT_M1);\n            let _y = mod(X * SQRT_M1);\n            X = _x;\n            Y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if (isNegativeLE(X * zInv, P))\n            Y = mod(-Y); // 9\n        let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))\n        if (isNegativeLE(s, P))\n            s = mod(-s);\n        return Fp.toBytes(s); // 11\n    }\n    /**\n     * Compares two Ristretto points.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n     */\n    equals(other) {\n        this.assertSame(other);\n        const { X: X1, Y: Y1 } = this.ep;\n        const { X: X2, Y: Y2 } = other.ep;\n        const mod = (n) => Fp.create(n);\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    is0() {\n        return this.equals(_RistrettoPoint.ZERO);\n    }\n}\nexport const ristretto255 = { Point: _RistrettoPoint };\n/** Hashing to ristretto255 points / field. RFC 9380 methods. */\nexport const ristretto255_hasher = {\n    Point: _RistrettoPoint,\n    /**\n    * Spec: https://www.rfc-editor.org/rfc/rfc9380.html#name-hashing-to-ristretto255. Caveats:\n    * * There are no test vectors\n    * * encodeToCurve / mapToCurve is undefined\n    * * mapToCurve would be `calcElligatorRistrettoMap(scalars[0])`, not ristretto255_map!\n    * * hashToScalar is undefined too, so we just use OPRF implementation\n    * * We cannot re-use 'createHasher', because ristretto255_map is different algorithm/RFC\n      (os2ip -> bytes255ToNumberLE)\n    * * mapToCurve == calcElligatorRistrettoMap, hashToCurve == ristretto255_map\n    * * hashToScalar is undefined in RFC9380 for ristretto, we are using version from OPRF here, using bytes255ToNumblerLE will create different result if we use bytes255ToNumberLE as os2ip\n    * * current version is closest to spec.\n    */\n    hashToCurve(msg, options) {\n        // == 'hash_to_ristretto255'\n        const DST = options?.DST || 'ristretto255_XMD:SHA-512_R255MAP_RO_';\n        const xmd = expand_message_xmd(msg, DST, 64, sha512);\n        // NOTE: RFC 9380 incorrectly calls this function 'ristretto255_map', in RFC 9496 map was function inside (per point)\n        // That also lead to confustion that ristretto255_map is mapToCurve (it is not! it is old hashToCurve)\n        return ristretto255_hasher.deriveToCurve(xmd);\n    },\n    hashToScalar(msg, options = { DST: _DST_scalar }) {\n        const xmd = expand_message_xmd(msg, options.DST, 64, sha512);\n        return Fn.create(bytesToNumberLE(xmd));\n    },\n    /**\n     * HashToCurve-like construction based on RFC 9496 (Element Derivation).\n     * Converts 64 uniform random bytes into a curve point.\n     *\n     * WARNING: This represents an older hash-to-curve construction, preceding the finalization of RFC 9380.\n     * It was later reused as a component in the newer `hash_to_ristretto255` function defined in RFC 9380.\n     */\n    deriveToCurve(bytes) {\n        // https://www.rfc-editor.org/rfc/rfc9496.html#name-element-derivation\n        abytes(bytes, 64);\n        const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new _RistrettoPoint(R1.add(R2));\n    },\n};\n/** ristretto255 OPRF, defined in RFC 9497. */\nexport const ristretto255_oprf = /* @__PURE__ */ (() => createORPF({\n    name: 'ristretto255-SHA512',\n    Point: _RistrettoPoint,\n    hash: sha512,\n    hashToGroup: ristretto255_hasher.hashToCurve,\n    hashToScalar: ristretto255_hasher.hashToScalar,\n}))();\n/**\n * Weird / bogus points, useful for debugging.\n * All 8 ed25519 points of 8-torsion subgroup can be generated from the point\n * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.\n * T = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }\n */\nexport const ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n//# sourceMappingURL=ed25519.js.map","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexport const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport const wrapConstructor = createHasher;\nexport const wrapConstructorWithOpts = createOptHasher;\nexport const wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { Hash, abytes, aexists, aoutput, clean, createView, toBytes } from \"./utils.js\";\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\nimport { clean, createHasher, rotr } from \"./utils.js\";\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        clean(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\nexport class SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = SHA224_IV[0] | 0;\n        this.B = SHA224_IV[1] | 0;\n        this.C = SHA224_IV[2] | 0;\n        this.D = SHA224_IV[3] | 0;\n        this.E = SHA224_IV[4] | 0;\n        this.F = SHA224_IV[5] | 0;\n        this.G = SHA224_IV[6] | 0;\n        this.H = SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = SHA512_IV[0] | 0;\n        this.Al = SHA512_IV[1] | 0;\n        this.Bh = SHA512_IV[2] | 0;\n        this.Bl = SHA512_IV[3] | 0;\n        this.Ch = SHA512_IV[4] | 0;\n        this.Cl = SHA512_IV[5] | 0;\n        this.Dh = SHA512_IV[6] | 0;\n        this.Dl = SHA512_IV[7] | 0;\n        this.Eh = SHA512_IV[8] | 0;\n        this.El = SHA512_IV[9] | 0;\n        this.Fh = SHA512_IV[10] | 0;\n        this.Fl = SHA512_IV[11] | 0;\n        this.Gh = SHA512_IV[12] | 0;\n        this.Gl = SHA512_IV[13] | 0;\n        this.Hh = SHA512_IV[14] | 0;\n        this.Hl = SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexport class SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = SHA384_IV[0] | 0;\n        this.Al = SHA384_IV[1] | 0;\n        this.Bh = SHA384_IV[2] | 0;\n        this.Bl = SHA384_IV[3] | 0;\n        this.Ch = SHA384_IV[4] | 0;\n        this.Cl = SHA384_IV[5] | 0;\n        this.Dh = SHA384_IV[6] | 0;\n        this.Dl = SHA384_IV[7] | 0;\n        this.Eh = SHA384_IV[8] | 0;\n        this.El = SHA384_IV[9] | 0;\n        this.Fh = SHA384_IV[10] | 0;\n        this.Fl = SHA384_IV[11] | 0;\n        this.Gh = SHA384_IV[12] | 0;\n        this.Gl = SHA384_IV[13] | 0;\n        this.Hh = SHA384_IV[14] | 0;\n        this.Hl = SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nexport class SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexport class SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256 = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224 = /* @__PURE__ */ createHasher(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512 = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384 = /* @__PURE__ */ createHasher(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256 = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224 = /* @__PURE__ */ createHasher(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map","/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nimport { SHA224 as SHA224n, sha224 as sha224n, SHA256 as SHA256n, sha256 as sha256n, } from \"./sha2.js\";\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA256 = SHA256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha256 = sha256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA224 = SHA224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha224 = sha224n;\n//# sourceMappingURL=sha256.js.map","/**\n * Solana Ed25519 keypair derivation from seed\n *\n * Derives a Solana-compatible Ed25519 keypair from the 16-byte wallet seed.\n * The 16-byte seed is expanded to 32 bytes using SHA-256 for Ed25519 compatibility.\n *\n * ## S-4: Non-Standard Derivation Warning\n *\n * This derivation is **NOT BIP-44/BIP-39 compatible**. A 12-word recovery phrase\n * generated by this system will NOT produce the same Solana address when imported\n * into standard wallets (Phantom, Solflare, Backpack, etc.) because:\n *\n * 1. Standard wallets use BIP-44 path `m/44'/501'/0'/0'` with HMAC-SHA512\n * 2. This system uses SHA-256 expansion of a 16-byte seed (no derivation path)\n *\n * This is an intentional design decision: the wallet is app-locked and recovery\n * is handled within the cedros-login system. Users should NOT attempt to import\n * their recovery phrase into external wallets.\n *\n * Security:\n * - Uses @noble/curves for audited Ed25519 implementation (CRYPTO-1 fix)\n * - Uses SHA-256 to deterministically expand 16-byte seed to 32 bytes\n * - Produces deterministic keypairs from the same seed\n * - Private key material is wiped after derivation when requested\n */\n\nimport { ed25519 } from '@noble/curves/ed25519.js';\nimport { sha256 } from '@noble/hashes/sha256';\nimport type { Seed } from './types';\nimport { wipeBytes } from './secureWipe';\n\n/** Solana keypair with public and secret key */\nexport interface SolanaKeypair {\n  /** 32-byte Ed25519 public key */\n  publicKey: Uint8Array;\n  /** 64-byte Ed25519 secret key (32-byte expanded seed + 32-byte public key) */\n  secretKey: Uint8Array;\n}\n\n/** Base58 alphabet used by Solana */\nconst BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/** UI-20: Pre-computed character-to-index lookup table for O(1) base58 decoding */\nconst BASE58_CHAR_TO_INDEX: Record<string, number> = {};\nfor (let i = 0; i < BASE58_ALPHABET.length; i++) {\n  BASE58_CHAR_TO_INDEX[BASE58_ALPHABET[i]] = i;\n}\n\n/**\n * Derive an Ed25519 keypair from a 16-byte seed\n *\n * The 16-byte seed is expanded to 32 bytes using SHA-256, then used for\n * Ed25519 derivation which internally:\n * - Hashes expanded seed with SHA-512\n * - Clamps lower 32 bytes to form scalar\n * - Multiplies by Ed25519 base point\n *\n * @param seed - 16-byte seed (128-bit entropy)\n * @returns Keypair with 32-byte public key and 64-byte secret key\n *\n * @security **CALLER MUST WIPE secretKey AFTER USE**\n * The returned `secretKey` contains sensitive cryptographic material.\n * Callers are responsible for wiping it when no longer needed:\n * ```ts\n * const keypair = deriveKeypairFromSeed(seed);\n * try {\n *   // use keypair.secretKey for signing\n * } finally {\n *   wipeBytes(keypair.secretKey);\n * }\n * ```\n * Failure to wipe may leave key material in memory, vulnerable to memory\n * dump attacks. The internal `expandedSeed` is automatically wiped.\n */\nexport function deriveKeypairFromSeed(seed: Seed): SolanaKeypair {\n  if (seed.length !== 16) {\n    throw new Error(`Invalid seed length: expected 16, got ${seed.length}`);\n  }\n\n  // Expand 16-byte seed to 32 bytes using SHA-256\n  // This is deterministic and provides the 32 bytes needed for Ed25519\n  const expandedSeed = sha256(seed);\n\n  // Use @noble/curves audited Ed25519 implementation (CRYPTO-1)\n  const publicKey = ed25519.getPublicKey(expandedSeed);\n\n  // Create the 64-byte secret key (expandedSeed || publicKey)\n  // Solana uses this format for compatibility with nacl\n  const secretKey = new Uint8Array(64);\n  secretKey.set(expandedSeed, 0);\n  secretKey.set(publicKey, 32);\n\n  // S-3: Wipe the intermediate expandedSeed buffer. Note: this data is already\n  // copied into secretKey (which the CALLER must wipe), so this wipe only reduces\n  // the number of in-memory copies  it does not eliminate the key material entirely.\n  wipeBytes(expandedSeed);\n\n  return { publicKey, secretKey };\n}\n\n/**\n * Get the public key from a seed without returning the secret key\n *\n * @param seed - 32-byte seed\n * @returns 32-byte Ed25519 public key\n */\nexport function getPublicKeyFromSeed(seed: Seed): Uint8Array {\n  const keypair = deriveKeypairFromSeed(seed);\n  const publicKey = keypair.publicKey;\n\n  // Wipe the secret key\n  wipeBytes(keypair.secretKey);\n\n  return publicKey;\n}\n\n/**\n * Encode a public key as a Base58 Solana address\n *\n * @param publicKey - 32-byte public key\n * @returns Base58-encoded address string\n */\nexport function publicKeyToBase58(publicKey: Uint8Array): string {\n  if (publicKey.length !== 32) {\n    throw new Error(`Invalid public key length: expected 32, got ${publicKey.length}`);\n  }\n\n  return base58Encode(publicKey);\n}\n\n/**\n * Decode a Base58 Solana address to public key bytes\n *\n * @param address - Base58-encoded address\n * @returns 32-byte public key\n */\nexport function base58ToPublicKey(address: string): Uint8Array {\n  const decoded = base58Decode(address);\n\n  if (decoded.length !== 32) {\n    throw new Error(`Invalid address: decoded to ${decoded.length} bytes`);\n  }\n\n  return decoded;\n}\n\n/**\n * Validate a Solana address format\n *\n * @param address - Address string to validate\n * @returns true if valid Base58 and correct length\n */\nexport function isValidSolanaAddress(address: string): boolean {\n  if (typeof address !== 'string') return false;\n  if (address.length < 32 || address.length > 44) return false;\n\n  try {\n    const decoded = base58Decode(address);\n    return decoded.length === 32;\n  } catch {\n    return false;\n  }\n}\n\n// --- Base58 implementation ---\n\nfunction base58Encode(bytes: Uint8Array): string {\n  // Count leading zeros\n  let zeros = 0;\n  for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {\n    zeros++;\n  }\n\n  // Convert to big integer\n  let num = 0n;\n  for (let i = 0; i < bytes.length; i++) {\n    num = num * 256n + BigInt(bytes[i]);\n  }\n\n  // Convert to base58\n  let str = '';\n  while (num > 0n) {\n    const remainder = Number(num % 58n);\n    str = BASE58_ALPHABET[remainder] + str;\n    num = num / 58n;\n  }\n\n  // Add leading '1's for each leading zero byte\n  return '1'.repeat(zeros) + str;\n}\n\nfunction base58Decode(str: string): Uint8Array {\n  // Count leading '1's\n  let zeros = 0;\n  for (let i = 0; i < str.length && str[i] === '1'; i++) {\n    zeros++;\n  }\n\n  // Convert from base58 using pre-computed lookup table (UI-20)\n  let num = 0n;\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    const index = BASE58_CHAR_TO_INDEX[char];\n    if (index === undefined) {\n      throw new Error(`Invalid base58 character: ${char}`);\n    }\n    num = num * 58n + BigInt(index);\n  }\n\n  // Convert to bytes\n  const bytes: number[] = [];\n  while (num > 0n) {\n    bytes.unshift(Number(num % 256n));\n    num = num / 256n;\n  }\n\n  // Add leading zeros\n  const result = new Uint8Array(zeros + bytes.length);\n  result.set(bytes, zeros);\n\n  return result;\n}\n","/**\n * Shamir Secret Sharing using secrets.js-grempe\n *\n * Implements 2-of-3 threshold secret sharing:\n * - Share A: Encrypted with user credential (password/PIN/passkey PRF), stored on server\n * - Share B: Plaintext stored on server (SSS math protects it - 1 share reveals nothing)\n * - Share C: Encoded as BIP-39 mnemonic for recovery (never sent to server)\n *\n * Security:\n * - Any 2 shares can reconstruct the secret\n * - Any 1 share reveals nothing about the secret\n * - Uses GF(2^8) arithmetic for information-theoretic security\n */\n\nimport secrets from 'secrets.js-grempe';\nimport type { Seed, ShamirShare } from './types';\nimport { toSeed, toShamirShare } from './types';\nimport { wipeAll } from './secureWipe';\nimport { getPublicKeyFromSeed } from './solanaKeypair';\n\n/** Shamir threshold (minimum shares to reconstruct) */\nexport const SHAMIR_THRESHOLD = 2;\n\n/** Total number of shares */\nexport const SHAMIR_TOTAL = 3;\n\n/** Share identifiers */\nexport type ShareId = 'A' | 'B' | 'C';\n\n/** Result of splitting a secret into shares */\nexport interface ShamirSplitResult {\n  /** Share A (for password encryption) */\n  shareA: ShamirShare;\n  /** Share B (for device PRF encryption) */\n  shareB: ShamirShare;\n  /** Share C (for recovery phrase) */\n  shareC: ShamirShare;\n}\n\n/**\n * Split a 16-byte seed into 3 shares using Shamir's Secret Sharing\n *\n * @param seed - 16-byte seed to split\n * @returns Three shares (any 2 can reconstruct the seed)\n */\nexport function splitSecret(seed: Seed): ShamirSplitResult {\n  if (seed.length !== 16) {\n    throw new Error(`Invalid seed length: expected 16, got ${seed.length}`);\n  }\n\n  // Convert seed to hex string for secrets.js\n  const seedHex = uint8ArrayToHex(seed);\n\n  // Split into 3 shares with threshold 2\n  const shares = secrets.share(seedHex, SHAMIR_TOTAL, SHAMIR_THRESHOLD);\n\n  if (shares.length !== 3) {\n    throw new Error(`Unexpected share count: ${shares.length}`);\n  }\n\n  // Convert hex shares back to Uint8Array\n  // secrets.js adds a prefix with share index, we keep the full share format\n  const shareA = hexShareToBytes(shares[0]);\n  const shareB = hexShareToBytes(shares[1]);\n  const shareC = hexShareToBytes(shares[2]);\n\n  return {\n    shareA: toShamirShare(shareA),\n    shareB: toShamirShare(shareB),\n    shareC: toShamirShare(shareC),\n  };\n}\n\n/**\n * Combine 2 shares to reconstruct the original seed\n *\n * @param share1 - First share\n * @param share2 - Second share (must be different from first)\n * @param expectedPublicKey - Optional 32-byte Ed25519 public key. When provided,\n *   the reconstructed seed is used to derive the corresponding public key and the\n *   two are compared byte-for-byte. Throws if they do not match, preventing\n *   silent use of a corrupted or wrong-share combination (UI-03).\n * @returns Reconstructed 16-byte seed (MAINT-03: fixed from incorrect \"32-byte\")\n * @throws Error if shares are invalid, cannot reconstruct, or public key mismatch\n */\nexport function combineShares(\n  share1: ShamirShare,\n  share2: ShamirShare,\n  expectedPublicKey?: Uint8Array\n): Seed {\n  // Convert shares back to hex format for secrets.js\n  const hexShare1 = bytesToHexShare(share1);\n  const hexShare2 = bytesToHexShare(share2);\n\n  try {\n    // Combine shares\n    const seedHex = secrets.combine([hexShare1, hexShare2]);\n\n    // Convert back to bytes\n    const seed = hexToUint8Array(seedHex);\n\n    if (seed.length !== 16) {\n      throw new Error(`Reconstructed seed has wrong length: ${seed.length}`);\n    }\n\n    const typedSeed = toSeed(seed);\n\n    // UI-03: Verify reconstructed seed produces the expected public key.\n    if (expectedPublicKey !== undefined) {\n      if (expectedPublicKey.length !== 32) {\n        throw new Error(\n          `Invalid expectedPublicKey length: expected 32, got ${expectedPublicKey.length}`\n        );\n      }\n      const derivedPublicKey = getPublicKeyFromSeed(typedSeed);\n      let mismatch = 0;\n      for (let i = 0; i < 32; i++) {\n        mismatch |= derivedPublicKey[i] ^ expectedPublicKey[i];\n      }\n      if (mismatch !== 0) {\n        wipeAll(typedSeed);\n        throw new Error(\n          'Reconstructed seed does not match expected public key. ' +\n            'The shares may be corrupt or belong to a different wallet.'\n        );\n      }\n    }\n\n    return typedSeed;\n  } catch (err) {\n    if (err instanceof Error && err.message.startsWith('Reconstructed seed')) {\n      throw err;\n    }\n    if (err instanceof Error && err.message.startsWith('Invalid expectedPublicKey')) {\n      throw err;\n    }\n    if (err instanceof Error && err.message.startsWith('Reconstructed seed does not match')) {\n      throw err;\n    }\n    throw new Error('Failed to reconstruct seed from shares');\n  }\n}\n\n/**\n * Verify that shares can successfully reconstruct a seed\n *\n * @param share1 - First share\n * @param share2 - Second share\n * @param expectedSeed - Expected seed after reconstruction\n * @returns true if shares reconstruct to expected seed\n */\nexport function verifyShares(\n  share1: ShamirShare,\n  share2: ShamirShare,\n  expectedSeed: Seed\n): boolean {\n  let reconstructed: Seed | undefined;\n  try {\n    reconstructed = combineShares(share1, share2);\n\n    // Constant-time comparison\n    if (reconstructed.length !== expectedSeed.length) {\n      return false;\n    }\n\n    let result = 0;\n    for (let i = 0; i < reconstructed.length; i++) {\n      result |= reconstructed[i] ^ expectedSeed[i];\n    }\n\n    return result === 0;\n  } catch {\n    return false;\n  } finally {\n    if (reconstructed) {\n      wipeAll(reconstructed);\n    }\n  }\n}\n\n/**\n * Extract share index from a share (useful for debugging)\n *\n * @param share - Share to inspect\n * @returns Share index (1-based)\n */\nexport function getShareIndex(share: ShamirShare): number {\n  // secrets.js encodes the index in the first byte(s)\n  // The hex format is: {bits}{id}{data}\n  const hexShare = bytesToHexShare(share);\n  return secrets.extractShareComponents(hexShare).id;\n}\n\n// --- Internal utilities ---\n\n/**\n * Convert Uint8Array to hex string\n */\nfunction uint8ArrayToHex(bytes: Uint8Array): string {\n  return Array.from(bytes)\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\n/**\n * Convert hex string to Uint8Array\n * CRYPTO-01: Validates hex characters and length before parsing\n */\nfunction hexToUint8Array(hex: string): Uint8Array {\n  // CRYPTO-01: Validate hex characters before parsing\n  if (!/^[0-9a-fA-F]*$/.test(hex)) {\n    throw new Error('Invalid hex string: contains non-hex characters');\n  }\n  // CRYPTO-01: Validate even length (each byte is 2 hex chars)\n  if (hex.length % 2 !== 0) {\n    throw new Error(`Invalid hex string: length ${hex.length} is odd (must be even)`);\n  }\n  const bytes = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * Convert hex share from secrets.js to bytes\n *\n * S-1 FIX: Explicit padding tracking via flag byte.\n *\n * secrets.js shares have format: {bits}{id}{data} where:\n * - bits: 1-2 hex chars indicating bit mode (e.g., \"8\" for 8-bit)\n * - id: 1-2 hex chars for share ID (1-255)\n * - data: the actual share data\n *\n * The hex string can have odd length (e.g., \"801...\" for 8-bit mode).\n * We pad odd-length strings to even by prepending \"0\", and store a flag\n * byte at position 0 to track whether padding was applied:\n * - 0x01 = odd-length hex, padding was added\n * - 0x00 = even-length hex, no padding\n */\nfunction hexShareToBytes(hexShare: string): Uint8Array {\n  const isOdd = hexShare.length % 2 !== 0;\n  const paddedHex = isOdd ? '0' + hexShare : hexShare;\n  const dataBytes = hexToUint8Array(paddedHex);\n  // S-1: Prepend flag byte to explicitly track padding\n  const result = new Uint8Array(1 + dataBytes.length);\n  result[0] = isOdd ? 1 : 0;\n  result.set(dataBytes, 1);\n  return result;\n}\n\n/**\n * Convert bytes back to hex share format for secrets.js\n *\n * S-1 FIX: Uses explicit flag byte instead of heuristic padding detection.\n *\n * New format (flag byte at position 0):\n * - 0x00: even-length hex, return as-is\n * - 0x01: odd-length hex, strip the leading \"0\" that was added as padding\n *\n * UI-23: Ambiguity note  0x01 is used as both the new-format odd-padding\n * marker and could be the first data byte of a legacy share. To distinguish,\n * we validate that the decoded hex looks like a valid secrets.js share\n * (must start with a known bits prefix such as \"8\"). If it does not, fall\n * through to the legacy path.\n *\n * Legacy format (backward compat for shares stored before S-1 fix):\n * - Shares without known version markers: use heuristic stripping\n */\nfunction bytesToHexShare(bytes: Uint8Array): string {\n  const firstByte = bytes[0];\n\n  // S-1: New format  explicit flag byte (0x00 = even, 0x01 = odd with padding)\n  if (firstByte === 0x00 || firstByte === 0x01) {\n    const wasOdd = firstByte === 0x01;\n    const dataBytes = bytes.subarray(1);\n    const candidateHex = uint8ArrayToHex(dataBytes);\n    const resultHex = wasOdd ? candidateHex.substring(1) : candidateHex;\n    // UI-23: Validate the decoded hex is a plausible secrets.js share (starts with\n    // a known bits value). If not, treat this share as legacy format.\n    if (/^[0-9a-f]/.test(resultHex)) {\n      return resultHex;\n    }\n  }\n\n  // Legacy format (pre-S-1): heuristic-based for backward compatibility.\n  // Treat shares without known version markers as legacy.\n  const hex = uint8ArrayToHex(bytes);\n  if (hex.startsWith('0') && !hex.startsWith('00')) {\n    return hex.substring(1);\n  }\n  return hex;\n}\n\n/**\n * Exported for testing only  do not use outside of tests.\n */\nexport const _internal = {\n  hexShareToBytes,\n  bytesToHexShare,\n  uint8ArrayToHex,\n  hexToUint8Array,\n};\n\n/**\n * Pad a Uint8Array to a specific length\n */\nexport function padToLength(data: Uint8Array, targetLength: number): Uint8Array {\n  if (data.length >= targetLength) {\n    return data;\n  }\n  const padded = new Uint8Array(targetLength);\n  padded.set(data);\n  return padded;\n}\n"],"names":["worker","nextId","pending","getWorker","_documentCurrentScript","event","id","key","error","handlers","argon2DeriveInWorker","password","salt","params","DEFAULT_KDF_PARAMS","validateKdfParams","argonWorker","resolve","reject","payload","argon2Derive","cryptoShim","webcrypto","subtle","getRandomValues","randomUUID","root","factory","module","require$$0","this","crypto","defaults","config","preGenPadding","runCSPRNGTest","CSPRNGTypes","reset","isSetRNG","padLeft","str","multipleOfBits","missing","hex2bin","bin","num","i","bin2hex","hex","hasCryptoGetRandomValues","hasCryptoRandomBytes","getRNG","type","construct","bits","arr","radix","size","len","parsedInt","nodeCryptoRandomBytes","buf","bytes","browserCryptoGetRandomValues","elems","testRandom","int","splitNumStringToIntArray","padLength","parts","horner","x","coeffs","logx","fx","lagrange","at","y","sum","product","j","getShares","secret","numShares","threshold","shares","constructPublicShareString","data","bitsBase36","idHex","idMax","idPaddingLen","newShareString","secrets","rngType","logs","exps","primitive","len2","result","setBits","share","splitShare","obj","idLen","max","regexStr","shareComponents","rng","errPrefix","errSuffix","bytesPerChar","hexChars","out","neededBytes","neededBits","subShares","radid","isBytes","a","anumber","n","title","prefix","abytes","value","length","needsLen","ofLen","got","aexists","instance","checkFinished","aoutput","min","clean","arrays","createView","hasHexBuiltin","hexes","_","bytesToHex","asciis","asciiToBase16","ch","hexToBytes","hl","al","array","ai","hi","n1","n2","char","concatBytes","res","pad","createHasher","hashCons","info","hashC","msg","opts","tmp","randomBytes","bytesLength","cr","oidNist","suffix","HashMD$1","blockLen","outputLen","padOffset","isLE","view","buffer","pos","take","dataView","oview","outLen","state","to","finished","destroyed","SHA512_IV","U32_MASK64","_32n","fromBig","le","split","lst","Ah","Al","h","l","shrSH","_l","s","shrSL","rotrSH","rotrSL","rotrBH","rotrBL","add","Bh","Bl","add3L","Cl","add3H","low","Ch","add4L","Dl","add4H","Dh","add5L","El","add5H","Eh","K512","u64.split","SHA512_Kh","SHA512_Kl","SHA512_W_H","SHA512_W_L","SHA2_64B","HashMD","Fh","Fl","Gh","Gl","Hh","Hl","offset","W15h","W15l","s0h","u64.rotrSH","u64.shrSH","s0l","u64.rotrSL","u64.shrSL","W2h","W2l","s1h","u64.rotrBH","s1l","u64.rotrBL","SUMl","u64.add4L","SUMh","u64.add4H","sigma1h","sigma1l","CHIh","CHIl","T1ll","u64.add5L","T1h","u64.add5H","T1l","sigma0h","sigma0l","MAJh","MAJl","u64.add","All","u64.add3L","u64.add3H","_SHA512","sha512","_0n","_1n","abool","abignumber","isPosBig","hexToNumber","bytesToNumberBE","bytesToHex_","bytesToNumberLE","copyBytes","abytes_","numberToBytesBE","hexToBytes_","numberToBytesLE","inRange","aInRange","bitMask","validateObject","object","fields","optFields","checkField","fieldName","expectedType","isOpt","val","current","iter","f","k","v","memoized","fn","map","arg","args","computed","_2n","_3n","_4n","_5n","_7n","_8n","_9n","_16n","mod","b","pow2","power","modulo","invert","number","u","q","r","m","assertIsSquare","Fp","sqrt3mod4","p1div4","sqrt5mod8","p5div8","nv","sqrt9mod16","P","Fp_","Field","tn","tonelliShanks","c1","c2","c3","c4","tv1","tv2","tv3","tv4","e1","e2","e3","Q","S","Z","_Fp","FpLegendre","cc","Q1div2","M","c","t","R","t_tmp","exponent","FpSqrt","isNegativeLE","FIELD_FIELDS","validateField","field","initial","FpPow","p","d","FpInvertBatch","nums","passZero","inverted","multipliedAcc","acc","invertedAcc","p1mod2","powered","yes","zero","no","nLength","nBitLength","_nBitLength","nByteLength","_Field","ORDER","_nbitLength","lhs","rhs","skipValidation","allowedLengths","BYTES","modFromBytes","padded","scalar","condition","negateCt","item","neg","normalizeZ","points","invertedZs","validateW","W","calcWOpts","scalarBits","windows","windowSize","maxNumber","mask","shiftBy","calcOffsets","window","wOpts","wbits","nextN","offsetStart","isZero","isNeg","isNegF","pointPrecomputes","pointWindowSizes","getW","assert0","wNAF","Point","elm","point","base","precomputes","wo","offsetF","transform","comp","prev","createField","order","createCurveFields","CURVE","curveOpts","FpFnLE","Fn","createKeygen","randomSecretKey","getPublicKey","seed","secretKey","isEdValidXY","x2","y2","left","right","edwards","extraOpts","validated","cofactor","MASK","modP","uvRatio","acoord","banZero","aedpoint","other","toAffineMemo","iz","X","Y","is0","zz","assertValidMemo","T","X2","Y2","Z2","Z4","aX2","XY","ZT","zip215","normed","lastByte","isValid","isXOdd","isLastByteOdd","isLazy","wnaf","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","T1","T2","invertedZ","eddsa","cHash","eddsaOpts","prehash","BASE","wcRandomBytes","adjustScalarBytes","domain","ctx","phflag","modN_LE","hash","getPrivateScalar","lengths","hashed","head","getExtendedPublicKey","pointBytes","hashDomainToScalar","context","msgs","sign","options","rs","verifyOpts","verify","sig","publicKey","mid","SB","_size","isValidSecretKey","isValidPublicKey","utils","is25519","ed25519_CURVE_p","ed25519_CURVE","ed25519_pow_2_252_3","_10n","_20n","_40n","_80n","b2","b4","b5","b10","b20","b40","b80","b160","b240","b250","ED25519_SQRT_M1","v3","v7","pow","vx2","root1","root2","useRoot1","useRoot2","noRoot","ed25519_Point","ed","ed25519","rotr","word","shift","utf8ToBytes","toBytes","Hash","setBigUint64","byteOffset","_u32_max","wh","wl","Chi","Maj","SHA256_IV","SHA256_K","SHA256_W","SHA256","W15","W2","s0","s1","sigma1","sha256","sha256n","BASE58_ALPHABET","deriveKeypairFromSeed","expandedSeed","wipeBytes","getPublicKeyFromSeed","keypair","publicKeyToBase58","base58Encode","zeros","remainder","SHAMIR_THRESHOLD","SHAMIR_TOTAL","splitSecret","seedHex","uint8ArrayToHex","shareA","hexShareToBytes","shareB","shareC","toShamirShare","combineShares","share1","share2","expectedPublicKey","hexShare1","bytesToHexShare","hexShare2","hexToUint8Array","toSeed","err","hexShare","isOdd","paddedHex","dataBytes","firstByte","wasOdd","candidateHex","resultHex"],"mappings":"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","x_google_ignoreList":[2,3,4,5,6,7,8,9,10,11,12,13,14,15]}