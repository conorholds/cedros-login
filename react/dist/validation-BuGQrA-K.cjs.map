{"version":3,"file":"validation-BuGQrA-K.cjs","sources":["../src/utils/validation.ts"],"sourcesContent":["import type { PasswordValidation } from '../types';\n\n/**\n * Allowed special characters for password validation (F-07)\n *\n * This explicit list prevents spaces, tabs, and non-printable characters\n * from counting as \"special\" (H-06 fix). Characters included:\n * - Punctuation: ! @ # $ % ^ & * ( ) _ + - = [ ] { } | ; ' : \" , . / < > ? ` ~\n * - Escape character: backslash\n */\nconst SPECIAL_CHARS_PATTERN = /[!@#$%^&*()_+\\-=[\\]{}|;':\",./<>?`~\\\\]/;\n\n/**\n * Password validation rules:\n * - Minimum 10 characters\n * - At least 1 uppercase letter (A-Z)\n * - At least 1 lowercase letter (a-z)\n * - At least 1 number (0-9)\n * - At least 1 special character (@$!%*?&#^())\n *\n * Note: All checks are performed regardless of early failures to prevent\n * timing attacks that could reveal which requirements are met.\n */\nexport function validatePassword(password: string): PasswordValidation {\n  const errors: PasswordValidation['errors'] = {};\n\n  // Perform ALL checks first (constant-time approach to prevent timing attacks)\n  const hasLength = password.length >= 10;\n  const hasUppercase = /[A-Z]/.test(password);\n  const hasLowercase = /[a-z]/.test(password);\n  const hasNumber = /\\d/.test(password);\n  // H-06: Use explicit special character list (see SPECIAL_CHARS_PATTERN)\n  const hasSpecial = SPECIAL_CHARS_PATTERN.test(password);\n\n  // Count criteria met\n  let criteriaMetCount = 0;\n\n  // Then assign errors based on results\n  if (hasLength) {\n    criteriaMetCount++;\n  } else {\n    errors.length = 'At least 10 characters';\n  }\n\n  if (hasUppercase) {\n    criteriaMetCount++;\n  } else {\n    errors.uppercase = 'At least 1 uppercase letter';\n  }\n\n  if (hasLowercase) {\n    criteriaMetCount++;\n  } else {\n    errors.lowercase = 'At least 1 lowercase letter';\n  }\n\n  if (hasNumber) {\n    criteriaMetCount++;\n  } else {\n    errors.number = 'At least 1 number';\n  }\n\n  if (hasSpecial) {\n    criteriaMetCount++;\n  } else {\n    errors.special = 'At least 1 special character (@$!%*?&#^())';\n  }\n\n  // Calculate strength\n  let strength: PasswordValidation['strength'];\n  if (criteriaMetCount <= 2) {\n    strength = 'weak';\n  } else if (criteriaMetCount === 3) {\n    strength = 'fair';\n  } else if (criteriaMetCount === 4) {\n    strength = 'good';\n  } else {\n    strength = 'strong';\n  }\n\n  return {\n    isValid: Object.keys(errors).length === 0,\n    errors,\n    strength,\n  };\n}\n\nconst TYPO_TLDS = new Set([\n  'con',\n  'cmo',\n  'ocm',\n  'cm',\n  'vom',\n  'xom',\n  'cpm',\n  'clm',\n  'ney',\n  'met',\n  'bet',\n  'nrt',\n  'ogr',\n  'rog',\n  'prg',\n  'irg',\n  'edi',\n  'rdu',\n]);\n\n/**\n * Validate email format with robust validation.\n *\n * Validates:\n * - Proper format with @ symbol\n * - Valid characters in local and domain parts\n * - Domain must have at least one dot (TLD required)\n * - Maximum length per RFC 5321\n *\n * UI-13: Note on case normalization - This function validates format only,\n * it does NOT normalize case. Per RFC 5321, local-part is technically\n * case-sensitive (though most providers ignore case). Callers should\n * normalize emails (e.g., toLowerCase) before API calls and storage.\n *\n * @param email - The email address to validate\n * @returns true if the email format is valid\n */\nexport function validateEmail(email: string): boolean {\n  // Check basic constraints\n  if (!email || typeof email !== 'string') {\n    return false;\n  }\n\n  if (email.length > 254) {\n    return false;\n  }\n\n  if (email.includes(' ')) {\n    return false;\n  }\n\n  const parts = email.split('@');\n  if (parts.length !== 2) {\n    return false;\n  }\n\n  const [local, domain] = parts;\n  if (!local || local.length > 64) {\n    return false;\n  }\n\n  if (local.startsWith('.') || local.endsWith('.')) {\n    return false;\n  }\n\n  if (!domain || domain.length > 253) {\n    return false;\n  }\n\n  if (!domain.includes('.')) {\n    return false;\n  }\n\n  if (\n    domain.startsWith('.') ||\n    domain.endsWith('.') ||\n    domain.startsWith('-') ||\n    domain.endsWith('-')\n  ) {\n    return false;\n  }\n\n  for (const label of domain.split('.')) {\n    if (label.startsWith('-') || label.endsWith('-')) {\n      return false;\n    }\n  }\n\n  const tld = domain.split('.').pop();\n  if (!tld || tld.length < 2) {\n    return false;\n  }\n\n  if (!/^[a-zA-Z]+$/.test(tld)) {\n    return false;\n  }\n\n  if (TYPO_TLDS.has(tld.toLowerCase())) {\n    return false;\n  }\n\n  if (!/^[a-zA-Z0-9.-]+$/.test(domain)) {\n    return false;\n  }\n\n  // UI-12: Allow Unicode (non-ASCII) characters in local-part for internationalized emails.\n  // Reject structural delimiters and DEL character that are invalid in unquoted local-parts.\n  // eslint-disable-next-line no-control-regex\n  if (/[\\x00-\\x1f\\x7f\"(),;:<>[\\]\\\\]/.test(local)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Valid Base58 characters (excludes 0, O, I, l to avoid ambiguity)\n */\nconst BASE58_ALPHABET = /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/;\n\n/**\n * Validate Solana public key format.\n *\n * A valid Solana public key:\n * - Is 43-44 characters long (base58 encoding of 32 bytes)\n * - Contains only valid base58 characters\n *\n * @param publicKey - The public key string to validate\n * @returns true if the public key format is valid\n *\n * @example\n * ```ts\n * validateSolanaPublicKey('DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263') // true\n * validateSolanaPublicKey('invalid') // false\n * ```\n */\nexport function validateSolanaPublicKey(publicKey: string): boolean {\n  // Check length (base58 encoding of 32 bytes is 43-44 chars)\n  if (publicKey.length < 43 || publicKey.length > 44) {\n    return false;\n  }\n\n  // Check for valid base58 characters only\n  return BASE58_ALPHABET.test(publicKey);\n}\n"],"names":["SPECIAL_CHARS_PATTERN","validatePassword","password","errors","hasLength","hasUppercase","hasLowercase","hasNumber","hasSpecial","criteriaMetCount","strength","TYPO_TLDS","validateEmail","email","parts","local","domain","label","tld","BASE58_ALPHABET","validateSolanaPublicKey","publicKey"],"mappings":"aAUA,MAAMA,EAAwB,wCAavB,SAASC,EAAiBC,EAAsC,CACrE,MAAMC,EAAuC,CAAA,EAGvCC,EAAYF,EAAS,QAAU,GAC/BG,EAAe,QAAQ,KAAKH,CAAQ,EACpCI,EAAe,QAAQ,KAAKJ,CAAQ,EACpCK,EAAY,KAAK,KAAKL,CAAQ,EAE9BM,EAAaR,EAAsB,KAAKE,CAAQ,EAGtD,IAAIO,EAAmB,EAGnBL,EACFK,IAEAN,EAAO,OAAS,yBAGdE,EACFI,IAEAN,EAAO,UAAY,8BAGjBG,EACFG,IAEAN,EAAO,UAAY,8BAGjBI,EACFE,IAEAN,EAAO,OAAS,oBAGdK,EACFC,IAEAN,EAAO,QAAU,6CAInB,IAAIO,EACJ,OAAID,GAAoB,EACtBC,EAAW,OACFD,IAAqB,EAC9BC,EAAW,OACFD,IAAqB,EAC9BC,EAAW,OAEXA,EAAW,SAGN,CACL,QAAS,OAAO,KAAKP,CAAM,EAAE,SAAW,EACxC,OAAAA,EACA,SAAAO,CAAA,CAEJ,CAEA,MAAMC,MAAgB,IAAI,CACxB,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACF,CAAC,EAmBM,SAASC,EAAcC,EAAwB,CAUpD,GARI,CAACA,GAAS,OAAOA,GAAU,UAI3BA,EAAM,OAAS,KAIfA,EAAM,SAAS,GAAG,EACpB,MAAO,GAGT,MAAMC,EAAQD,EAAM,MAAM,GAAG,EAC7B,GAAIC,EAAM,SAAW,EACnB,MAAO,GAGT,KAAM,CAACC,EAAOC,CAAM,EAAIF,EAiBxB,GAhBI,CAACC,GAASA,EAAM,OAAS,IAIzBA,EAAM,WAAW,GAAG,GAAKA,EAAM,SAAS,GAAG,GAI3C,CAACC,GAAUA,EAAO,OAAS,KAI3B,CAACA,EAAO,SAAS,GAAG,GAKtBA,EAAO,WAAW,GAAG,GACrBA,EAAO,SAAS,GAAG,GACnBA,EAAO,WAAW,GAAG,GACrBA,EAAO,SAAS,GAAG,EAEnB,MAAO,GAGT,UAAWC,KAASD,EAAO,MAAM,GAAG,EAClC,GAAIC,EAAM,WAAW,GAAG,GAAKA,EAAM,SAAS,GAAG,EAC7C,MAAO,GAIX,MAAMC,EAAMF,EAAO,MAAM,GAAG,EAAE,IAAA,EAoB9B,MAnBI,GAACE,GAAOA,EAAI,OAAS,GAIrB,CAAC,cAAc,KAAKA,CAAG,GAIvBP,EAAU,IAAIO,EAAI,YAAA,CAAa,GAI/B,CAAC,mBAAmB,KAAKF,CAAM,GAO/B,+BAA+B,KAAKD,CAAK,EAK/C,CAKA,MAAMI,EAAkB,kEAkBjB,SAASC,EAAwBC,EAA4B,CAElE,OAAIA,EAAU,OAAS,IAAMA,EAAU,OAAS,GACvC,GAIFF,EAAgB,KAAKE,CAAS,CACvC"}